#!/usr/bin/env bash

doc="Moonlight Streaming Script

Stream games using Moonlight with automatic or custom streaming settings.

Usage:
  $(basename "$0") --host <hostname> --app <app> [--resolution <resolution>] [--fps <fps>] [--bitrate <bitrate>] [--min-fps <min_fps>] [--max-fps <max_fps>] [--max-bitrate <max_bitrate>] [--debug] [--dry-run] [--verbose] [--detach] [--quiet]
  $(basename "$0") -h | --help

Options:
  -h, --host <hostname>               Hostname or IP address of the streaming host (required)
  -a, --app <app>                     The app/game to launch with Moonlight (required)
  -r, --resolution <resolution>       Override automatic resolution detection (e.g., 1920x1080)
  -f, --fps <fps>                     Override automatic FPS detection (e.g., 60)
  --min-fps <min_fps>                 Set minimum FPS for automatic detection (e.g., 30)
  --max-fps <max_fps>                 Set maximum FPS for automatic detection (e.g., 120)
  -b, --bitrate <bitrate>             Override automatic bitrate detection (in Kbps, e.g., 10000)
  --max-bitrate <max_bitrate>         Set maximum bitrate for automatic detection (in Kbps, e.g., 50000)
  --debug                             Enable debug mode
  --dry-run                           Perform a dry run without actually launching Moonlight
  --verbose                           Enable verbose logging to console (default: log to /tmp/moonlight.log)
  --detach                            Detach the process after receiving the first video packet
  --quiet                             Suppress all non-error output
  --help                              Show this screen.

Note: --min-fps, --max-fps, and --max-bitrate are ignored if their respective override options are set."

# Default values
HOST=""
MOONLIGHT_APP=""
RESOLUTION=""
MIN_RESOLUTION=""
MAX_RESOLUTION=""
FPS=""
MIN_FPS=""
MAX_FPS=""
BITRATE=""
MAX_BITRATE=""
DEBUG=false
DRY_RUN=false
VERBOSE=false
DETACH=false
QUIET=false
LOG_FILE="/tmp/moonlight.log"

parse_cli() {
  while [[ $# -gt 0 ]]; do
    case $1 in
    -h | --host)
      HOST="$2"
      shift 2
      ;;
    -a | --app)
      MOONLIGHT_APP="$2"
      shift 2
      ;;
    -r | --resolution)
      RESOLUTION="$2"
      shift 2
      ;;
    -f | --fps)
      FPS="$2"
      shift 2
      ;;
    --min-fps)
      MIN_FPS="$2"
      shift 2
      ;;
    --max-fps)
      MAX_FPS="$2"
      if ! validate_input "$MAX_FPS" "max FPS"; then
        return 1
      fi
      shift 2
      ;;
    -b | --bitrate)
      BITRATE="$2"
      shift 2
      ;;
    --max-bitrate)
      MAX_BITRATE="$2"
      if ! validate_input "$MAX_BITRATE" "max bitrate"; then
        return 1
      fi
      shift 2
      ;;
    --debug)
      DEBUG=true
      shift
      ;;
    --dry-run)
      DRY_RUN=true
      shift
      ;;
    --verbose)
      VERBOSE=true
      shift
      ;;
    --detach)
      DETACH=true
      shift
      ;;
    --quiet)
      QUIET=true
      shift
      ;;
    --help)
      echo "$doc"
      exit 0
      ;;
    *)
      echo "Unknown option '$1'" >&2
      echo "$doc" >&2
      return 1
      ;;
    esac
  done

  if [[ -z "$HOST" || -z "$MOONLIGHT_APP" ]]; then
    echo "Host and app are required parameters." >&2
    echo "$doc" >&2
    return 1
  fi

  # Warn if both verbose/debug and quiet are set
  if [[ "$QUIET" == true && ("$VERBOSE" == true || "$DEBUG" == true) ]]; then
    log warn "Both quiet and verbose/debug modes are set. Quiet mode will be disabled."
    QUIET=false
  fi

  return 0
}

# BUG: Doesn't work with `gum log`
log() {
  local level="$1"
  shift
  local message="$1"
  shift

  # Return early if quiet mode is enabled, except for error and fatal levels
  if [[ "$QUIET" == true && "$level" != "error" && "$level" != "fatal" ]]; then
    return
  fi

  local log_command="gum log --level $level"

  # Execute the log command
  if [[ "$level" == "debug" && "$DEBUG" != true ]]; then
    return
  elif [[ "$level" == "fatal" ]]; then
    $log_command "FATAL: $message" "$@"
    exit 1
  else
    $log_command "$message" "$@"
  fi
}

validate_input() {
  local value=$1
  local name=$2
  if ! [[ "$value" =~ ^[0-9]+$ ]]; then
    log error "Invalid $name format. Please provide a positive integer."
    return 1
  fi
  return 0
}

run_speed_test() {
  local retry_count=0
  local MAX_RETRIES=3
  local RETRY_DELAY=5

  while [ "$retry_count" -lt "$MAX_RETRIES" ]; do
    local result
    result=$(gum spin --spinner meter --title "Running speed test..." -- iperf3 -c "$HOST" -p 31347 -t 10 -J)

    if echo "$result" | jq -e '.error' >/dev/null 2>&1; then
      local error_message
      error_message=$(echo "$result" | jq -r '.error')
      echo "$error_message" >&2
      ((retry_count++))
      [ "$retry_count" -lt "$MAX_RETRIES" ] && sleep "$RETRY_DELAY"
    else
      local speed
      speed=$(echo "$result" | jq -r '.end.sum_received.bits_per_second / 1000000' | bc -l | xargs printf "%.2f")
      echo "$speed"
      return 0
    fi
  done

  echo "Failed to connect after $MAX_RETRIES attempts." >&2
  return 1
}

measure_ping() {
  local ping_result
  ping_result=$(gum spin --spinner pulse --title "Measuring ping..." -- ping -c 5 "$HOST" | tail -1 | awk '{print $4}' | cut -d '/' -f 2)

  if [ -z "$ping_result" ]; then
    echo "Failed to measure ping to $HOST. Check your network connection or host." >&2
    return 1
  fi

  echo "$ping_result"
}

get_system_resolution() {
  xrandr |
    grep ' connected' |
    grep -oP '\d+x\d+\+\d+\+\d+' |
    cut -d'+' -f1
}

calculate_resolution() {
  local speed="$1"
  local system_resolution="$2"
  local width height target_resolution

  IFS='x' read -r width height <<<"$system_resolution"

  local scale_factors=(100 75 50 25)

  for scale in "${scale_factors[@]}"; do
    target_width=$(echo "scale=0; $width * $scale / 100" | bc)
    target_height=$(echo "scale=0; $height * $scale / 100" | bc)
    target_resolution="${target_width}x${target_height}"

    # Calculate the speed threshold for this resolution
    speed_threshold=$(echo "scale=2; 15 * $scale / 100" | bc)

    if (($(echo "$speed >= $speed_threshold" | bc -l))); then
      log debug "Selected resolution $target_resolution for speed $speed Mbps (threshold: $speed_threshold Mbps)"
      echo "$target_resolution"
      return
    fi
  done

  # If speed is too low, return the lowest resolution
  log warn "Speed too low, using lowest resolution $target_resolution for speed $speed Mbps"
  echo "${target_resolution}"
}

determine_resolution() {
  local speed="$1"
  local resolution

  if [ -n "$RESOLUTION" ]; then
    resolution="$RESOLUTION"
    log debug "Using provided resolution: $resolution"
  else
    local system_resolution
    system_resolution=$(get_system_resolution)
    log debug "System resolution: $system_resolution"

    resolution=$(calculate_resolution "$speed" "$system_resolution")
    log debug "Calculated resolution based on speed: $resolution"

    resolution=$(apply_resolution_constraints "$resolution")
    log debug "Applied resolution constraints: $resolution"
  fi

  echo "$resolution"
}

apply_resolution_constraints() {
  local resolution="$1"
  local cur_width cur_height

  IFS='x' read -r cur_width cur_height <<<"$resolution"

  if [ -n "$MIN_RESOLUTION" ]; then
    local min_width min_height
    IFS='x' read -r min_width min_height <<<"$MIN_RESOLUTION"
    if ((cur_width < min_width || cur_height < min_height)); then
      resolution="$MIN_RESOLUTION"
    fi
  fi

  if [ -n "$MAX_RESOLUTION" ]; then
    local max_width max_height
    IFS='x' read -r max_width max_height <<<"$MAX_RESOLUTION"
    if ((cur_width > max_width || cur_height > max_height)); then
      resolution="$MAX_RESOLUTION"
    fi
  fi

  echo "$resolution"
}

determine_fps() {
  local speed="$1"
  local ping="$2"
  local fps

  if [ -n "$FPS" ]; then
    fps="$FPS"
    log debug "Using provided FPS: $fps"
  else
    fps=$(calculate_fps "$speed" "$ping")
    log debug "Determined FPS based on system refresh rate, speed, and ping: $fps"

    if [ -n "$MAX_FPS" ] && ((fps > MAX_FPS)); then
      fps="$MAX_FPS"
      log debug "Applied max FPS constraint: $fps"
    fi
  fi

  echo "$fps"
}

calculate_fps() {
  local speed="$1"
  local ping="$2"

  # Get the system's refresh rate
  local system_fps
  system_fps=$(xrandr | grep -A1 ' connected' | grep -oP '\d+\.\d+(?=\*)' | head -n1)
  if [ -z "$system_fps" ]; then
    system_fps=$(xrandr | grep -A1 ' connected' | grep -oP '\d+\.\d+' | head -n1)
  fi

  # Round the system FPS to the nearest integer
  system_fps=$(echo "$system_fps" | awk '{printf "%.0f", $1}')

  # Start with the lower of system FPS or MAX_FPS (if set)
  local max_fps
  if [ -n "$MAX_FPS" ]; then
    max_fps=$((system_fps < MAX_FPS ? system_fps : MAX_FPS))
  else
    max_fps=$system_fps
  fi

  # Calculate common rates that can be multiplied to max_fps
  local common_rates=()
  for ((i = max_fps; i >= 30; i--)); do
    if ((max_fps % i == 0)); then
      common_rates+=("$i")
    fi
  done

  # Start with the highest rate
  local fps=${common_rates[0]}

  # Adjust FPS based on network conditions
  for rate in "${common_rates[@]}"; do
    if (($(echo "$speed >= 30 && $ping < 30" | bc -l))); then
      fps=$rate
      break
    elif (($(echo "$speed >= 20 && $ping < 40" | bc -l))); then
      if ((rate <= 60)); then
        fps=$rate
        break
      fi
    elif (($(echo "$speed >= 15 && $ping < 50" | bc -l))); then
      if ((rate <= 30)); then
        fps=$rate
        break
      fi
    else
      fps=$rate
    fi
  done

  # Ensure FPS is not lower than MIN_FPS (if set) or 30
  local min_fps=${MIN_FPS:-30}
  fps=$((fps > min_fps ? fps : min_fps))

  echo "$fps"
}

determine_bitrate() {
  local resolution="$1"
  local speed="$2"
  local bitrate

  if [ -n "$BITRATE" ]; then
    bitrate="$BITRATE"
    log debug "Using provided bitrate" bitrate "${bitrate}Kbps"
  else
    bitrate=$(calculate_bitrate "$resolution" "$speed")
    log debug "Determined bitrate based on resolution and speed" bitrate "${bitrate}Kbps" resolution "$resolution" speed "$speed"

    if [ -n "$MAX_BITRATE" ] && ((bitrate > MAX_BITRATE)); then
      bitrate="$MAX_BITRATE"
      log debug "Applied max bitrate constraint" bitrate "${bitrate}Kbps" max_bitrate "$MAX_BITRATE"
    fi
  fi

  echo "$bitrate"
}

calculate_bitrate() {
  local resolution="$1"
  local speed="$2"
  local bitrate

  case "$resolution" in
  "1920x1080")
    bitrate=$(echo "scale=0; ($speed * 1000 * 0.75 / 500) * 500" | bc)
    bitrate=$((bitrate < 30000 ? bitrate : 30000)) # Cap at 30 Mbps
    ;;
  "1280x720")
    bitrate=$(echo "scale=0; ($speed * 1000 * 0.75 / 500) * 500" | bc)
    bitrate=$((bitrate < 15000 ? bitrate : 15000)) # Cap at 15 Mbps
    ;;
  *)
    bitrate=$(echo "scale=0; ($speed * 1000 * 0.75 / 500) * 500" | bc)
    bitrate=$((bitrate < 8000 ? bitrate : 8000)) # Cap at 8 Mbps
    ;;
  esac

  echo "$bitrate"
}

determine_settings() {
  local speed=$1
  local ping=$2

  local resolution fps bitrate

  resolution=$(determine_resolution "$speed")
  fps=$(determine_fps "$speed" "$ping")
  bitrate=$(determine_bitrate "$resolution" "$speed")

  echo "$resolution $fps $bitrate"
}

launch_moonlight() {
  local resolution=$1
  local fps=$2
  local bitrate=$3

  local moonlight_cmd="moonlight --resolution $resolution --fps $fps --bitrate $bitrate stream $HOST \"$MOONLIGHT_APP\""

  if [ "$DRY_RUN" = true ]; then
    log info "Command:" cmd "$moonlight_cmd"
    return 0
  fi

  # Create a temporary file to store the output
  local temp_file
  temp_file=$(mktemp)

  # Function to check for the first video packet
  check_for_video_packet() {
    if grep -q "Received first video packet" "$temp_file"; then
      return 0
    fi
    return 1
  }

  # Start Moonlight in the background
  if [ "$VERBOSE" = true ]; then
    eval "$moonlight_cmd 2>&1 | tee $temp_file | tee -a $LOG_FILE &"
  else
    eval "$moonlight_cmd > $temp_file 2>&1 &"
  fi
  local pid=$!

  log info "Waiting for first video packet..." pid $pid

  # Use gum spin, but allow the script to continue after receiving the first video packet
  gum spin --spinner points --title "Connecting to ($HOST)..." -- bash -c "while true; do if check_for_video_packet; then exit 0; fi; if ! kill -0 $pid 2>/dev/null; then exit 1; fi; sleep 0.1; done" &
  local spin_pid=$!

  # Wait for either the first video packet or the Moonlight process to exit
  while true; do
    if check_for_video_packet; then
      kill $spin_pid 2>/dev/null
      wait $spin_pid 2>/dev/null
      break
    fi
    if ! kill -0 $pid 2>/dev/null; then
      kill $spin_pid 2>/dev/null
      wait $spin_pid 2>/dev/null
      log error "Moonlight process exited before receiving first video packet"
      if [ "$VERBOSE" = true ]; then
        tee -a $LOG_FILE <"$temp_file"
      else
        cat "$temp_file" >>$LOG_FILE
      fi
      rm "$temp_file"
      return 1
    fi
    sleep 0.1
  done

  log info "First video packet received."
  if [ "$VERBOSE" = true ]; then
    echo "First video packet received." | tee -a $LOG_FILE
  fi

  if [ "$DETACH" = true ]; then
    log info "Detaching..."
    if [ "$VERBOSE" = true ]; then
      echo "Detaching..." | tee -a $LOG_FILE
    fi
    rm "$temp_file"
    disown $pid
    return 0
  else
    # For non-detached mode, continue to show output
    log info "Continuing in attached mode. Press Ctrl+C to exit."
    if [ "$VERBOSE" = true ]; then
      # Show remaining output in real-time
      tail -f -n +1 "$temp_file" | tee -a $LOG_FILE &
    else
      # Show remaining output only in log file
      tail -f -n +1 "$temp_file" >>$LOG_FILE &
    fi
    wait $pid
    local exit_status=$?
    rm "$temp_file"
    return $exit_status
  fi
}

main() {
  if ! parse_cli "$@"; then
    return 1
  fi

  local speed ping settings

  speed=$(run_speed_test) || return 1
  ping=$(measure_ping) || return 1

  settings=$(determine_settings "$speed" "$ping") || return 1
  read -r resolution fps bitrate <<<"$settings"

  launch_moonlight "$resolution" "$fps" "$bitrate"
}

# Only run the main function if the script is being executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  main "$@"
fi
