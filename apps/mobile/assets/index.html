<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Vite + React + TS</title>
    <script type="module" crossorigin>
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node2 of mutation.addedNodes) {
        if (node2.tagName === "LINK" && node2.rel === "modulepreload")
          processPreload(node2);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity)
      fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy)
      fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$2 = Symbol.for("react.element"), n$3 = Symbol.for("react.portal"), p$4 = Symbol.for("react.fragment"), q$4 = Symbol.for("react.strict_mode"), r$2 = Symbol.for("react.profiler"), t$2 = Symbol.for("react.provider"), u$2 = Symbol.for("react.context"), v$3 = Symbol.for("react.forward_ref"), w$2 = Symbol.for("react.suspense"), x$1 = Symbol.for("react.memo"), y$1 = Symbol.for("react.lazy"), z$2 = Symbol.iterator;
function A$2(a) {
  if (null === a || "object" !== typeof a)
    return null;
  a = z$2 && a[z$2] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var B$2 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$2 = Object.assign, D$2 = {};
function E$1(a, b2, e2) {
  this.props = a;
  this.context = b2;
  this.refs = D$2;
  this.updater = e2 || B$2;
}
E$1.prototype.isReactComponent = {};
E$1.prototype.setState = function(a, b2) {
  if ("object" !== typeof a && "function" !== typeof a && null != a)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a, b2, "setState");
};
E$1.prototype.forceUpdate = function(a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function F$1() {
}
F$1.prototype = E$1.prototype;
function G$2(a, b2, e2) {
  this.props = a;
  this.context = b2;
  this.refs = D$2;
  this.updater = e2 || B$2;
}
var H$3 = G$2.prototype = new F$1();
H$3.constructor = G$2;
C$2(H$3, E$1.prototype);
H$3.isPureReactComponent = true;
var I$2 = Array.isArray, J$1 = Object.prototype.hasOwnProperty, K$3 = { current: null }, L$2 = { key: true, ref: true, __self: true, __source: true };
function M$2(a, b2, e2) {
  var d, c = {}, k2 = null, h2 = null;
  if (null != b2)
    for (d in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2)
      J$1.call(b2, d) && !L$2.hasOwnProperty(d) && (c[d] = b2[d]);
  var g2 = arguments.length - 2;
  if (1 === g2)
    c.children = e2;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
      f2[m2] = arguments[m2 + 2];
    c.children = f2;
  }
  if (a && a.defaultProps)
    for (d in g2 = a.defaultProps, g2)
      void 0 === c[d] && (c[d] = g2[d]);
  return { $$typeof: l$2, type: a, key: k2, ref: h2, props: c, _owner: K$3.current };
}
function N$1(a, b2) {
  return { $$typeof: l$2, type: a.type, key: b2, ref: a.ref, props: a.props, _owner: a._owner };
}
function O$2(a) {
  return "object" === typeof a && null !== a && a.$$typeof === l$2;
}
function escape(a) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a.replace(/[=:]/g, function(a2) {
    return b2[a2];
  });
}
var P$1 = /\/+/g;
function Q$2(a, b2) {
  return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b2.toString(36);
}
function R$2(a, b2, e2, d, c) {
  var k2 = typeof a;
  if ("undefined" === k2 || "boolean" === k2)
    a = null;
  var h2 = false;
  if (null === a)
    h2 = true;
  else
    switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a.$$typeof) {
          case l$2:
          case n$3:
            h2 = true;
        }
    }
  if (h2)
    return h2 = a, c = c(h2), a = "" === d ? "." + Q$2(h2, 0) : d, I$2(c) ? (e2 = "", null != a && (e2 = a.replace(P$1, "$&/") + "/"), R$2(c, b2, e2, "", function(a2) {
      return a2;
    })) : null != c && (O$2(c) && (c = N$1(c, e2 + (!c.key || h2 && h2.key === c.key ? "" : ("" + c.key).replace(P$1, "$&/") + "/") + a)), b2.push(c)), 1;
  h2 = 0;
  d = "" === d ? "." : d + ":";
  if (I$2(a))
    for (var g2 = 0; g2 < a.length; g2++) {
      k2 = a[g2];
      var f2 = d + Q$2(k2, g2);
      h2 += R$2(k2, b2, e2, f2, c);
    }
  else if (f2 = A$2(a), "function" === typeof f2)
    for (a = f2.call(a), g2 = 0; !(k2 = a.next()).done; )
      k2 = k2.value, f2 = d + Q$2(k2, g2++), h2 += R$2(k2, b2, e2, f2, c);
  else if ("object" === k2)
    throw b2 = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
function S$2(a, b2, e2) {
  if (null == a)
    return a;
  var d = [], c = 0;
  R$2(a, d, "", "", function(a2) {
    return b2.call(e2, a2, c++);
  });
  return d;
}
function T$2(a) {
  if (-1 === a._status) {
    var b2 = a._result;
    b2 = b2();
    b2.then(function(b3) {
      if (0 === a._status || -1 === a._status)
        a._status = 1, a._result = b3;
    }, function(b3) {
      if (0 === a._status || -1 === a._status)
        a._status = 2, a._result = b3;
    });
    -1 === a._status && (a._status = 0, a._result = b2);
  }
  if (1 === a._status)
    return a._result.default;
  throw a._result;
}
var U$2 = { current: null }, V$2 = { transition: null }, W$3 = { ReactCurrentDispatcher: U$2, ReactCurrentBatchConfig: V$2, ReactCurrentOwner: K$3 };
react_production_min.Children = { map: S$2, forEach: function(a, b2, e2) {
  S$2(a, function() {
    b2.apply(this, arguments);
  }, e2);
}, count: function(a) {
  var b2 = 0;
  S$2(a, function() {
    b2++;
  });
  return b2;
}, toArray: function(a) {
  return S$2(a, function(a2) {
    return a2;
  }) || [];
}, only: function(a) {
  if (!O$2(a))
    throw Error("React.Children.only expected to receive a single React element child.");
  return a;
} };
react_production_min.Component = E$1;
react_production_min.Fragment = p$4;
react_production_min.Profiler = r$2;
react_production_min.PureComponent = G$2;
react_production_min.StrictMode = q$4;
react_production_min.Suspense = w$2;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$3;
react_production_min.cloneElement = function(a, b2, e2) {
  if (null === a || void 0 === a)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
  var d = C$2({}, a.props), c = a.key, k2 = a.ref, h2 = a._owner;
  if (null != b2) {
    void 0 !== b2.ref && (k2 = b2.ref, h2 = K$3.current);
    void 0 !== b2.key && (c = "" + b2.key);
    if (a.type && a.type.defaultProps)
      var g2 = a.type.defaultProps;
    for (f2 in b2)
      J$1.call(b2, f2) && !L$2.hasOwnProperty(f2) && (d[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2)
    d.children = e2;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++)
      g2[m2] = arguments[m2 + 2];
    d.children = g2;
  }
  return { $$typeof: l$2, type: a.type, key: c, ref: k2, props: d, _owner: h2 };
};
react_production_min.createContext = function(a) {
  a = { $$typeof: u$2, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a.Provider = { $$typeof: t$2, _context: a };
  return a.Consumer = a;
};
react_production_min.createElement = M$2;
react_production_min.createFactory = function(a) {
  var b2 = M$2.bind(null, a);
  b2.type = a;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a) {
  return { $$typeof: v$3, render: a };
};
react_production_min.isValidElement = O$2;
react_production_min.lazy = function(a) {
  return { $$typeof: y$1, _payload: { _status: -1, _result: a }, _init: T$2 };
};
react_production_min.memo = function(a, b2) {
  return { $$typeof: x$1, type: a, compare: void 0 === b2 ? null : b2 };
};
react_production_min.startTransition = function(a) {
  var b2 = V$2.transition;
  V$2.transition = {};
  try {
    a();
  } finally {
    V$2.transition = b2;
  }
};
react_production_min.unstable_act = function() {
  throw Error("act(...) is not supported in production builds of React.");
};
react_production_min.useCallback = function(a, b2) {
  return U$2.current.useCallback(a, b2);
};
react_production_min.useContext = function(a) {
  return U$2.current.useContext(a);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a) {
  return U$2.current.useDeferredValue(a);
};
react_production_min.useEffect = function(a, b2) {
  return U$2.current.useEffect(a, b2);
};
react_production_min.useId = function() {
  return U$2.current.useId();
};
react_production_min.useImperativeHandle = function(a, b2, e2) {
  return U$2.current.useImperativeHandle(a, b2, e2);
};
react_production_min.useInsertionEffect = function(a, b2) {
  return U$2.current.useInsertionEffect(a, b2);
};
react_production_min.useLayoutEffect = function(a, b2) {
  return U$2.current.useLayoutEffect(a, b2);
};
react_production_min.useMemo = function(a, b2) {
  return U$2.current.useMemo(a, b2);
};
react_production_min.useReducer = function(a, b2, e2) {
  return U$2.current.useReducer(a, b2, e2);
};
react_production_min.useRef = function(a) {
  return U$2.current.useRef(a);
};
react_production_min.useState = function(a) {
  return U$2.current.useState(a);
};
react_production_min.useSyncExternalStore = function(a, b2, e2) {
  return U$2.current.useSyncExternalStore(a, b2, e2);
};
react_production_min.useTransition = function() {
  return U$2.current.useTransition();
};
react_production_min.version = "18.2.0";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$1 = reactExports, k$2 = Symbol.for("react.element"), l$1 = Symbol.for("react.fragment"), m$3 = Object.prototype.hasOwnProperty, n$2 = f$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$3 = { key: true, ref: true, __self: true, __source: true };
function q$3(c, a, g2) {
  var b2, d = {}, e2 = null, h2 = null;
  void 0 !== g2 && (e2 = "" + g2);
  void 0 !== a.key && (e2 = "" + a.key);
  void 0 !== a.ref && (h2 = a.ref);
  for (b2 in a)
    m$3.call(a, b2) && !p$3.hasOwnProperty(b2) && (d[b2] = a[b2]);
  if (c && c.defaultProps)
    for (b2 in a = c.defaultProps, a)
      void 0 === d[b2] && (d[b2] = a[b2]);
  return { $$typeof: k$2, type: c, key: e2, ref: h2, props: d, _owner: n$2.current };
}
reactJsxRuntime_production_min.Fragment = l$1;
reactJsxRuntime_production_min.jsx = q$3;
reactJsxRuntime_production_min.jsxs = q$3;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
var client$1 = {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a, b2) {
    var c = a.length;
    a.push(b2);
    a:
      for (; 0 < c; ) {
        var d = c - 1 >>> 1, e2 = a[d];
        if (0 < g2(e2, b2))
          a[d] = b2, a[c] = e2, c = d;
        else
          break a;
      }
  }
  function h2(a) {
    return 0 === a.length ? null : a[0];
  }
  function k2(a) {
    if (0 === a.length)
      return null;
    var b2 = a[0], c = a.pop();
    if (c !== b2) {
      a[0] = c;
      a:
        for (var d = 0, e2 = a.length, w2 = e2 >>> 1; d < w2; ) {
          var m2 = 2 * (d + 1) - 1, C2 = a[m2], n2 = m2 + 1, x2 = a[n2];
          if (0 > g2(C2, c))
            n2 < e2 && 0 > g2(x2, C2) ? (a[d] = x2, a[n2] = c, d = n2) : (a[d] = C2, a[m2] = c, d = m2);
          else if (n2 < e2 && 0 > g2(x2, c))
            a[d] = x2, a[n2] = c, d = n2;
          else
            break a;
        }
    }
    return b2;
  }
  function g2(a, b2) {
    var c = a.sortIndex - b2.sortIndex;
    return 0 !== c ? c : a.id - b2.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a) {
    for (var b2 = h2(t2); null !== b2; ) {
      if (null === b2.callback)
        k2(t2);
      else if (b2.startTime <= a)
        k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
      else
        break;
      b2 = h2(t2);
    }
  }
  function H2(a) {
    B2 = false;
    G2(a);
    if (!A2)
      if (null !== h2(r2))
        A2 = true, I2(J2);
      else {
        var b2 = h2(t2);
        null !== b2 && K2(H2, b2.startTime - a);
      }
  }
  function J2(a, b2) {
    A2 = false;
    B2 && (B2 = false, E2(L2), L2 = -1);
    z2 = true;
    var c = y2;
    try {
      G2(b2);
      for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a && !M2()); ) {
        var d = v2.callback;
        if ("function" === typeof d) {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e2 = d(v2.expirationTime <= b2);
          b2 = exports.unstable_now();
          "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
          G2(b2);
        } else
          k2(r2);
        v2 = h2(r2);
      }
      if (null !== v2)
        var w2 = true;
      else {
        var m2 = h2(t2);
        null !== m2 && K2(H2, m2.startTime - b2);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c, z2 = false;
    }
  }
  var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a = exports.unstable_now();
      Q2 = a;
      var b2 = true;
      try {
        b2 = O2(true, a);
      } finally {
        b2 ? S2() : (N2 = false, O2 = null);
      }
    } else
      N2 = false;
  }
  var S2;
  if ("function" === typeof F2)
    S2 = function() {
      F2(R2);
    };
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = function() {
      U2.postMessage(null);
    };
  } else
    S2 = function() {
      D2(R2, 0);
    };
  function I2(a) {
    O2 = a;
    N2 || (N2 = true, S2());
  }
  function K2(a, b2) {
    L2 = D2(function() {
      a(exports.unstable_now());
    }, b2);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a) {
    a.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports.unstable_forceFrameRate = function(a) {
    0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a ? Math.floor(1e3 / a) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  };
  exports.unstable_next = function(a) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y2;
    }
    var c = y2;
    y2 = b2;
    try {
      return a();
    } finally {
      y2 = c;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a, b2) {
    switch (a) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a = 3;
    }
    var c = y2;
    y2 = a;
    try {
      return b2();
    } finally {
      y2 = c;
    }
  };
  exports.unstable_scheduleCallback = function(a, b2, c) {
    var d = exports.unstable_now();
    "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
    switch (a) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c + e2;
    a = { id: u2++, callback: b2, priorityLevel: a, startTime: c, expirationTime: e2, sortIndex: -1 };
    c > d ? (a.sortIndex = c, f2(t2, a), null === h2(r2) && a === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c - d))) : (a.sortIndex = e2, f2(r2, a), A2 || z2 || (A2 = true, I2(J2)));
    return a;
  };
  exports.unstable_shouldYield = M2;
  exports.unstable_wrapCallback = function(a) {
    var b2 = y2;
    return function() {
      var c = y2;
      y2 = b2;
      try {
        return a.apply(this, arguments);
      } finally {
        y2 = c;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, ca = schedulerExports;
function p$2(a) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++)
    b2 += "&args[]=" + encodeURIComponent(arguments[c]);
  return "Minified React error #" + a + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a, b2) {
  ha(a, b2);
  ha(a + "Capture", b2);
}
function ha(a, b2) {
  ea[a] = b2;
  for (a = 0; a < b2.length; a++)
    da.add(b2[a]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a) {
  if (ja.call(ma, a))
    return true;
  if (ja.call(la, a))
    return false;
  if (ka.test(a))
    return ma[a] = true;
  la[a] = true;
  return false;
}
function pa(a, b2, c, d) {
  if (null !== c && 0 === c.type)
    return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d)
        return false;
      if (null !== c)
        return !c.acceptsBooleans;
      a = a.toLowerCase().slice(0, 5);
      return "data-" !== a && "aria-" !== a;
    default:
      return false;
  }
}
function qa(a, b2, c, d) {
  if (null === b2 || "undefined" === typeof b2 || pa(a, b2, c, d))
    return true;
  if (d)
    return false;
  if (null !== c)
    switch (c.type) {
      case 3:
        return !b2;
      case 4:
        return false === b2;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
  return false;
}
function v$2(a, b2, c, d, e2, f2, g2) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d;
  this.attributeNamespace = e2;
  this.mustUseProperty = c;
  this.propertyName = a;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var z$1 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
  z$1[a] = new v$2(a, 0, false, a, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
  var b2 = a[0];
  z$1[b2] = new v$2(b2, 1, false, a[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
  z$1[a] = new v$2(a, 2, false, a.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
  z$1[a] = new v$2(a, 2, false, a, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
  z$1[a] = new v$2(a, 3, false, a.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a) {
  z$1[a] = new v$2(a, 3, true, a, null, false, false);
});
["capture", "download"].forEach(function(a) {
  z$1[a] = new v$2(a, 4, false, a, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a) {
  z$1[a] = new v$2(a, 6, false, a, null, false, false);
});
["rowSpan", "start"].forEach(function(a) {
  z$1[a] = new v$2(a, 5, false, a.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a) {
  return a[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
  var b2 = a.replace(
    ra,
    sa
  );
  z$1[b2] = new v$2(b2, 1, false, a, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
  var b2 = a.replace(ra, sa);
  z$1[b2] = new v$2(b2, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
  var b2 = a.replace(ra, sa);
  z$1[b2] = new v$2(b2, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a) {
  z$1[a] = new v$2(a, 1, false, a.toLowerCase(), null, false, false);
});
z$1.xlinkHref = new v$2("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a) {
  z$1[a] = new v$2(a, 1, false, a.toLowerCase(), null, true, true);
});
function ta(a, b2, c, d) {
  var e2 = z$1.hasOwnProperty(b2) ? z$1[b2] : null;
  if (null !== e2 ? 0 !== e2.type : d || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1])
    qa(b2, c, e2, d) && (c = null), d || null === e2 ? oa(b2) && (null === c ? a.removeAttribute(b2) : a.setAttribute(b2, "" + c)) : e2.mustUseProperty ? a[e2.propertyName] = null === c ? 3 === e2.type ? false : "" : c : (b2 = e2.attributeName, d = e2.attributeNamespace, null === c ? a.removeAttribute(b2) : (e2 = e2.type, c = 3 === e2 || 4 === e2 && true === c ? "" : "" + c, d ? a.setAttributeNS(d, b2, c) : a.setAttribute(b2, c)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a) {
  if (null === a || "object" !== typeof a)
    return null;
  a = Ja && a[Ja] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var A$1 = Object.assign, La;
function Ma(a) {
  if (void 0 === La)
    try {
      throw Error();
    } catch (c) {
      var b2 = c.stack.trim().match(/\n( *(at )?)/);
      La = b2 && b2[1] || "";
    }
  return "\n" + La + a;
}
var Na = false;
function Oa(a, b2) {
  if (!a || Na)
    return "";
  Na = true;
  var c = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2)
      if (b2 = function() {
        throw Error();
      }, Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (l2) {
          var d = l2;
        }
        Reflect.construct(a, [], b2);
      } else {
        try {
          b2.call();
        } catch (l2) {
          d = l2;
        }
        a.call(b2.prototype);
      }
    else {
      try {
        throw Error();
      } catch (l2) {
        d = l2;
      }
      a();
    }
  } catch (l2) {
    if (l2 && d && "string" === typeof l2.stack) {
      for (var e2 = l2.stack.split("\n"), f2 = d.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
        h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--)
        if (e2[g2] !== f2[h2]) {
          if (1 !== g2 || 1 !== h2) {
            do
              if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
                var k2 = "\n" + e2[g2].replace(" at new ", " at ");
                a.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a.displayName));
                return k2;
              }
            while (1 <= g2 && 0 <= h2);
          }
          break;
        }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c;
  }
  return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
}
function Pa(a) {
  switch (a.tag) {
    case 5:
      return Ma(a.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a = Oa(a.type, false), a;
    case 11:
      return a = Oa(a.type.render, false), a;
    case 1:
      return a = Oa(a.type, true), a;
    default:
      return "";
  }
}
function Qa(a) {
  if (null == a)
    return null;
  if ("function" === typeof a)
    return a.displayName || a.name || null;
  if ("string" === typeof a)
    return a;
  switch (a) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a)
    switch (a.$$typeof) {
      case Ca:
        return (a.displayName || "Context") + ".Consumer";
      case Ba:
        return (a._context.displayName || "Context") + ".Provider";
      case Da:
        var b2 = a.render;
        a = a.displayName;
        a || (a = b2.displayName || b2.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
        return a;
      case Ga:
        return b2 = a.displayName || null, null !== b2 ? b2 : Qa(a.type) || "Memo";
      case Ha:
        b2 = a._payload;
        a = a._init;
        try {
          return Qa(a(b2));
        } catch (c) {
        }
    }
  return null;
}
function Ra(a) {
  var b2 = a.type;
  switch (a.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a = b2.render, a = a.displayName || a.name || "", b2.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b2);
    case 8:
      return b2 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b2)
        return b2.displayName || b2.name || null;
      if ("string" === typeof b2)
        return b2;
  }
  return null;
}
function Sa(a) {
  switch (typeof a) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a;
    case "object":
      return a;
    default:
      return "";
  }
}
function Ta(a) {
  var b2 = a.type;
  return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Ua(a) {
  var b2 = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b2), d = "" + a[b2];
  if (!a.hasOwnProperty(b2) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
    var e2 = c.get, f2 = c.set;
    Object.defineProperty(a, b2, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a2) {
      d = "" + a2;
      f2.call(this, a2);
    } });
    Object.defineProperty(a, b2, { enumerable: c.enumerable });
    return { getValue: function() {
      return d;
    }, setValue: function(a2) {
      d = "" + a2;
    }, stopTracking: function() {
      a._valueTracker = null;
      delete a[b2];
    } };
  }
}
function Va(a) {
  a._valueTracker || (a._valueTracker = Ua(a));
}
function Wa(a) {
  if (!a)
    return false;
  var b2 = a._valueTracker;
  if (!b2)
    return true;
  var c = b2.getValue();
  var d = "";
  a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
  a = d;
  return a !== c ? (b2.setValue(a), true) : false;
}
function Xa(a) {
  a = a || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a)
    return null;
  try {
    return a.activeElement || a.body;
  } catch (b2) {
    return a.body;
  }
}
function Ya(a, b2) {
  var c = b2.checked;
  return A$1({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked });
}
function Za(a, b2) {
  var c = null == b2.defaultValue ? "" : b2.defaultValue, d = null != b2.checked ? b2.checked : b2.defaultChecked;
  c = Sa(null != b2.value ? b2.value : c);
  a._wrapperState = { initialChecked: d, initialValue: c, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function ab(a, b2) {
  b2 = b2.checked;
  null != b2 && ta(a, "checked", b2, false);
}
function bb(a, b2) {
  ab(a, b2);
  var c = Sa(b2.value), d = b2.type;
  if (null != c)
    if ("number" === d) {
      if (0 === c && "" === a.value || a.value != c)
        a.value = "" + c;
    } else
      a.value !== "" + c && (a.value = "" + c);
  else if ("submit" === d || "reset" === d) {
    a.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb(a, b2.type, c) : b2.hasOwnProperty("defaultValue") && cb(a, b2.type, Sa(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a.defaultChecked = !!b2.defaultChecked);
}
function db(a, b2, c) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d = b2.type;
    if (!("submit" !== d && "reset" !== d || void 0 !== b2.value && null !== b2.value))
      return;
    b2 = "" + a._wrapperState.initialValue;
    c || b2 === a.value || (a.value = b2);
    a.defaultValue = b2;
  }
  c = a.name;
  "" !== c && (a.name = "");
  a.defaultChecked = !!a._wrapperState.initialChecked;
  "" !== c && (a.name = c);
}
function cb(a, b2, c) {
  if ("number" !== b2 || Xa(a.ownerDocument) !== a)
    null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
}
var eb = Array.isArray;
function fb(a, b2, c, d) {
  a = a.options;
  if (b2) {
    b2 = {};
    for (var e2 = 0; e2 < c.length; e2++)
      b2["$" + c[e2]] = true;
    for (c = 0; c < a.length; c++)
      e2 = b2.hasOwnProperty("$" + a[c].value), a[c].selected !== e2 && (a[c].selected = e2), e2 && d && (a[c].defaultSelected = true);
  } else {
    c = "" + Sa(c);
    b2 = null;
    for (e2 = 0; e2 < a.length; e2++) {
      if (a[e2].value === c) {
        a[e2].selected = true;
        d && (a[e2].defaultSelected = true);
        return;
      }
      null !== b2 || a[e2].disabled || (b2 = a[e2]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function gb(a, b2) {
  if (null != b2.dangerouslySetInnerHTML)
    throw Error(p$2(91));
  return A$1({}, b2, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
}
function hb(a, b2) {
  var c = b2.value;
  if (null == c) {
    c = b2.children;
    b2 = b2.defaultValue;
    if (null != c) {
      if (null != b2)
        throw Error(p$2(92));
      if (eb(c)) {
        if (1 < c.length)
          throw Error(p$2(93));
        c = c[0];
      }
      b2 = c;
    }
    null == b2 && (b2 = "");
    c = b2;
  }
  a._wrapperState = { initialValue: Sa(c) };
}
function ib(a, b2) {
  var c = Sa(b2.value), d = Sa(b2.defaultValue);
  null != c && (c = "" + c, c !== a.value && (a.value = c), null == b2.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
  null != d && (a.defaultValue = "" + d);
}
function jb(a) {
  var b2 = a.textContent;
  b2 === a._wrapperState.initialValue && "" !== b2 && null !== b2 && (a.value = b2);
}
function kb(a) {
  switch (a) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a, b2) {
  return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b2) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a;
}
var mb, nb = function(a) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c, d, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a(b2, c, d, e2);
    });
  } : a;
}(function(a, b2) {
  if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a)
    a.innerHTML = b2;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = mb.firstChild; a.firstChild; )
      a.removeChild(a.firstChild);
    for (; b2.firstChild; )
      a.appendChild(b2.firstChild);
  }
});
function ob(a, b2) {
  if (b2) {
    var c = a.firstChild;
    if (c && c === a.lastChild && 3 === c.nodeType) {
      c.nodeValue = b2;
      return;
    }
  }
  a.textContent = b2;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a) {
  qb.forEach(function(b2) {
    b2 = b2 + a.charAt(0).toUpperCase() + a.substring(1);
    pb[b2] = pb[a];
  });
});
function rb(a, b2, c) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a) && pb[a] ? ("" + b2).trim() : b2 + "px";
}
function sb(a, b2) {
  a = a.style;
  for (var c in b2)
    if (b2.hasOwnProperty(c)) {
      var d = 0 === c.indexOf("--"), e2 = rb(c, b2[c], d);
      "float" === c && (c = "cssFloat");
      d ? a.setProperty(c, e2) : a[c] = e2;
    }
}
var tb = A$1({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a, b2) {
  if (b2) {
    if (tb[a] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
      throw Error(p$2(137, a));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children)
        throw Error(p$2(60));
      if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML))
        throw Error(p$2(61));
    }
    if (null != b2.style && "object" !== typeof b2.style)
      throw Error(p$2(62));
  }
}
function vb(a, b2) {
  if (-1 === a.indexOf("-"))
    return "string" === typeof b2.is;
  switch (a) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a) {
  a = a.target || a.srcElement || window;
  a.correspondingUseElement && (a = a.correspondingUseElement);
  return 3 === a.nodeType ? a.parentNode : a;
}
var yb = null, zb = null, Ab = null;
function Bb(a) {
  if (a = Cb(a)) {
    if ("function" !== typeof yb)
      throw Error(p$2(280));
    var b2 = a.stateNode;
    b2 && (b2 = Db(b2), yb(a.stateNode, a.type, b2));
  }
}
function Eb(a) {
  zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
}
function Fb() {
  if (zb) {
    var a = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a);
    if (b2)
      for (a = 0; a < b2.length; a++)
        Bb(b2[a]);
  }
}
function Gb(a, b2) {
  return a(b2);
}
function Hb() {
}
var Ib = false;
function Jb(a, b2, c) {
  if (Ib)
    return a(b2, c);
  Ib = true;
  try {
    return Gb(a, b2, c);
  } finally {
    if (Ib = false, null !== zb || null !== Ab)
      Hb(), Fb();
  }
}
function Kb(a, b2) {
  var c = a.stateNode;
  if (null === c)
    return null;
  var d = Db(c);
  if (null === d)
    return null;
  c = d[b2];
  a:
    switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
        a = !d;
        break a;
      default:
        a = false;
    }
  if (a)
    return null;
  if (c && "function" !== typeof c)
    throw Error(p$2(231, b2, typeof c));
  return c;
}
var Lb = false;
if (ia)
  try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a) {
    Lb = false;
  }
function Nb(a, b2, c, d, e2, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a) {
  Ob = true;
  Pb = a;
} };
function Tb(a, b2, c, d, e2, f2, g2, h2, k2) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a, b2, c, d, e2, f2, g2, h2, k2) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else
      throw Error(p$2(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a) {
  var b2 = a, c = a;
  if (a.alternate)
    for (; b2.return; )
      b2 = b2.return;
  else {
    a = b2;
    do
      b2 = a, 0 !== (b2.flags & 4098) && (c = b2.return), a = b2.return;
    while (a);
  }
  return 3 === b2.tag ? c : null;
}
function Wb(a) {
  if (13 === a.tag) {
    var b2 = a.memoizedState;
    null === b2 && (a = a.alternate, null !== a && (b2 = a.memoizedState));
    if (null !== b2)
      return b2.dehydrated;
  }
  return null;
}
function Xb(a) {
  if (Vb(a) !== a)
    throw Error(p$2(188));
}
function Yb(a) {
  var b2 = a.alternate;
  if (!b2) {
    b2 = Vb(a);
    if (null === b2)
      throw Error(p$2(188));
    return b2 !== a ? null : a;
  }
  for (var c = a, d = b2; ; ) {
    var e2 = c.return;
    if (null === e2)
      break;
    var f2 = e2.alternate;
    if (null === f2) {
      d = e2.return;
      if (null !== d) {
        c = d;
        continue;
      }
      break;
    }
    if (e2.child === f2.child) {
      for (f2 = e2.child; f2; ) {
        if (f2 === c)
          return Xb(e2), a;
        if (f2 === d)
          return Xb(e2), b2;
        f2 = f2.sibling;
      }
      throw Error(p$2(188));
    }
    if (c.return !== d.return)
      c = e2, d = f2;
    else {
      for (var g2 = false, h2 = e2.child; h2; ) {
        if (h2 === c) {
          g2 = true;
          c = e2;
          d = f2;
          break;
        }
        if (h2 === d) {
          g2 = true;
          d = e2;
          c = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c) {
            g2 = true;
            c = f2;
            d = e2;
            break;
          }
          if (h2 === d) {
            g2 = true;
            d = f2;
            c = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2)
          throw Error(p$2(189));
      }
    }
    if (c.alternate !== d)
      throw Error(p$2(190));
  }
  if (3 !== c.tag)
    throw Error(p$2(188));
  return c.stateNode.current === c ? a : b2;
}
function Zb(a) {
  a = Yb(a);
  return null !== a ? $b(a) : null;
}
function $b(a) {
  if (5 === a.tag || 6 === a.tag)
    return a;
  for (a = a.child; null !== a; ) {
    var b2 = $b(a);
    if (null !== b2)
      return b2;
    a = a.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B$1 = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a) {
  if (lc && "function" === typeof lc.onCommitFiberRoot)
    try {
      lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
    } catch (b2) {
    }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a) {
  a >>>= 0;
  return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a) {
  switch (a & -a) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a;
  }
}
function uc(a, b2) {
  var c = a.pendingLanes;
  if (0 === c)
    return 0;
  var d = 0, e2 = a.suspendedLanes, f2 = a.pingedLanes, g2 = c & 268435455;
  if (0 !== g2) {
    var h2 = g2 & ~e2;
    0 !== h2 ? d = tc(h2) : (f2 &= g2, 0 !== f2 && (d = tc(f2)));
  } else
    g2 = c & ~e2, 0 !== g2 ? d = tc(g2) : 0 !== f2 && (d = tc(f2));
  if (0 === d)
    return 0;
  if (0 !== b2 && b2 !== d && 0 === (b2 & e2) && (e2 = d & -d, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240)))
    return b2;
  0 !== (d & 4) && (d |= c & 16);
  b2 = a.entangledLanes;
  if (0 !== b2)
    for (a = a.entanglements, b2 &= d; 0 < b2; )
      c = 31 - oc(b2), e2 = 1 << c, d |= a[c], b2 &= ~e2;
  return d;
}
function vc(a, b2) {
  switch (a) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a, b2) {
  for (var c = a.suspendedLanes, d = a.pingedLanes, e2 = a.expirationTimes, f2 = a.pendingLanes; 0 < f2; ) {
    var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
    if (-1 === k2) {
      if (0 === (h2 & c) || 0 !== (h2 & d))
        e2[g2] = vc(h2, b2);
    } else
      k2 <= b2 && (a.expiredLanes |= h2);
    f2 &= ~h2;
  }
}
function xc(a) {
  a = a.pendingLanes & -1073741825;
  return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a;
}
function zc(a) {
  for (var b2 = [], c = 0; 31 > c; c++)
    b2.push(a);
  return b2;
}
function Ac(a, b2, c) {
  a.pendingLanes |= b2;
  536870912 !== b2 && (a.suspendedLanes = 0, a.pingedLanes = 0);
  a = a.eventTimes;
  b2 = 31 - oc(b2);
  a[b2] = c;
}
function Bc(a, b2) {
  var c = a.pendingLanes & ~b2;
  a.pendingLanes = b2;
  a.suspendedLanes = 0;
  a.pingedLanes = 0;
  a.expiredLanes &= b2;
  a.mutableReadLanes &= b2;
  a.entangledLanes &= b2;
  b2 = a.entanglements;
  var d = a.eventTimes;
  for (a = a.expirationTimes; 0 < c; ) {
    var e2 = 31 - oc(c), f2 = 1 << e2;
    b2[e2] = 0;
    d[e2] = -1;
    a[e2] = -1;
    c &= ~f2;
  }
}
function Cc(a, b2) {
  var c = a.entangledLanes |= b2;
  for (a = a.entanglements; c; ) {
    var d = 31 - oc(c), e2 = 1 << d;
    e2 & b2 | a[d] & b2 && (a[d] |= b2);
    c &= ~e2;
  }
}
var C$1 = 0;
function Dc(a) {
  a &= -a;
  return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a, b2) {
  switch (a) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b2.pointerId);
  }
}
function Tc(a, b2, c, d, e2, f2) {
  if (null === a || a.nativeEvent !== f2)
    return a = { blockedOn: b2, domEventName: c, eventSystemFlags: d, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a;
  a.eventSystemFlags |= d;
  b2 = a.targetContainers;
  null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
  return a;
}
function Uc(a, b2, c, d, e2) {
  switch (b2) {
    case "focusin":
      return Lc = Tc(Lc, a, b2, c, d, e2), true;
    case "dragenter":
      return Mc = Tc(Mc, a, b2, c, d, e2), true;
    case "mouseover":
      return Nc = Tc(Nc, a, b2, c, d, e2), true;
    case "pointerover":
      var f2 = e2.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a, b2, c, d, e2));
      return true;
    case "gotpointercapture":
      return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a, b2, c, d, e2)), true;
  }
  return false;
}
function Vc(a) {
  var b2 = Wc(a.target);
  if (null !== b2) {
    var c = Vb(b2);
    if (null !== c) {
      if (b2 = c.tag, 13 === b2) {
        if (b2 = Wb(c), null !== b2) {
          a.blockedOn = b2;
          Ic(a.priority, function() {
            Gc(c);
          });
          return;
        }
      } else if (3 === b2 && c.stateNode.current.memoizedState.isDehydrated) {
        a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a.blockedOn = null;
}
function Xc(a) {
  if (null !== a.blockedOn)
    return false;
  for (var b2 = a.targetContainers; 0 < b2.length; ) {
    var c = Yc(a.domEventName, a.eventSystemFlags, b2[0], a.nativeEvent);
    if (null === c) {
      c = a.nativeEvent;
      var d = new c.constructor(c.type, c);
      wb = d;
      c.target.dispatchEvent(d);
      wb = null;
    } else
      return b2 = Cb(c), null !== b2 && Fc(b2), a.blockedOn = c, false;
    b2.shift();
  }
  return true;
}
function Zc(a, b2, c) {
  Xc(a) && c.delete(b2);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a, b2) {
  a.blockedOn === b2 && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a) {
  function b2(b3) {
    return ad(b3, a);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a);
    for (var c = 1; c < Kc.length; c++) {
      var d = Kc[c];
      d.blockedOn === a && (d.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a);
  null !== Mc && ad(Mc, a);
  null !== Nc && ad(Nc, a);
  Oc.forEach(b2);
  Pc.forEach(b2);
  for (c = 0; c < Qc.length; c++)
    d = Qc[c], d.blockedOn === a && (d.blockedOn = null);
  for (; 0 < Qc.length && (c = Qc[0], null === c.blockedOn); )
    Vc(c), null === c.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a, b2, c, d) {
  var e2 = C$1, f2 = cd.transition;
  cd.transition = null;
  try {
    C$1 = 1, fd(a, b2, c, d);
  } finally {
    C$1 = e2, cd.transition = f2;
  }
}
function gd(a, b2, c, d) {
  var e2 = C$1, f2 = cd.transition;
  cd.transition = null;
  try {
    C$1 = 4, fd(a, b2, c, d);
  } finally {
    C$1 = e2, cd.transition = f2;
  }
}
function fd(a, b2, c, d) {
  if (dd) {
    var e2 = Yc(a, b2, c, d);
    if (null === e2)
      hd(a, b2, d, id, c), Sc(a, d);
    else if (Uc(e2, a, b2, c, d))
      d.stopPropagation();
    else if (Sc(a, d), b2 & 4 && -1 < Rc.indexOf(a)) {
      for (; null !== e2; ) {
        var f2 = Cb(e2);
        null !== f2 && Ec(f2);
        f2 = Yc(a, b2, c, d);
        null === f2 && hd(a, b2, d, id, c);
        if (f2 === e2)
          break;
        e2 = f2;
      }
      null !== e2 && d.stopPropagation();
    } else
      hd(a, b2, d, null, c);
  }
}
var id = null;
function Yc(a, b2, c, d) {
  id = null;
  a = xb(d);
  a = Wc(a);
  if (null !== a)
    if (b2 = Vb(a), null === b2)
      a = null;
    else if (c = b2.tag, 13 === c) {
      a = Wb(b2);
      if (null !== a)
        return a;
      a = null;
    } else if (3 === c) {
      if (b2.stateNode.current.memoizedState.isDehydrated)
        return 3 === b2.tag ? b2.stateNode.containerInfo : null;
      a = null;
    } else
      b2 !== a && (a = null);
  id = a;
  return null;
}
function jd(a) {
  switch (a) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a, b2 = ld, c = b2.length, d, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
  for (a = 0; a < c && b2[a] === e2[a]; a++)
    ;
  var g2 = c - a;
  for (d = 1; d <= g2 && b2[c - d] === e2[f2 - d]; d++)
    ;
  return md = e2.slice(a, 1 < d ? 1 - d : void 0);
}
function od(a) {
  var b2 = a.keyCode;
  "charCode" in a ? (a = a.charCode, 0 === a && 13 === b2 && (a = 13)) : a = b2;
  10 === a && (a = 13);
  return 32 <= a || 13 === a ? a : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a) {
  function b2(b3, d, e2, f2, g2) {
    this._reactName = b3;
    this._targetInst = e2;
    this.type = d;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c in a)
      a.hasOwnProperty(c) && (b3 = a[c], this[c] = b3 ? b3(f2) : f2[c]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A$1(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a2 = this.nativeEvent;
    a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a2 = this.nativeEvent;
    a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b2;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
  return a.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$1({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$1({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
  return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
}, movementX: function(a) {
  if ("movementX" in a)
    return a.movementX;
  a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
  return wd;
}, movementY: function(a) {
  return "movementY" in a ? a.movementY : xd;
} }), Bd = rd(Ad), Cd = A$1({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$1({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$1({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$1({}, sd, { clipboardData: function(a) {
  return "clipboardData" in a ? a.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A$1({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a) : (a = Od[a]) ? !!b2[a] : false;
}
function zd() {
  return Pd;
}
var Qd = A$1({}, ud, { key: function(a) {
  if (a.key) {
    var b2 = Md[a.key] || a.key;
    if ("Unidentified" !== b2)
      return b2;
  }
  return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
  return "keypress" === a.type ? od(a) : 0;
}, keyCode: function(a) {
  return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
}, which: function(a) {
  return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
} }), Rd = rd(Qd), Sd = A$1({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$1({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$1({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$1({}, Ad, {
  deltaX: function(a) {
    return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
  },
  deltaY: function(a) {
    return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae$1 = ia && "CompositionEvent" in window, be$1 = null;
ia && "documentMode" in document && (be$1 = document.documentMode);
var ce$1 = ia && "TextEvent" in window && !be$1, de = ia && (!ae$1 || be$1 && 8 < be$1 && 11 >= be$1), ee$1 = String.fromCharCode(32), fe$1 = false;
function ge$1(a, b2) {
  switch (a) {
    case "keyup":
      return -1 !== $d.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he$1(a) {
  a = a.detail;
  return "object" === typeof a && "data" in a ? a.data : null;
}
var ie$1 = false;
function je$1(a, b2) {
  switch (a) {
    case "compositionend":
      return he$1(b2);
    case "keypress":
      if (32 !== b2.which)
        return null;
      fe$1 = true;
      return ee$1;
    case "textInput":
      return a = b2.data, a === ee$1 && fe$1 ? null : a;
    default:
      return null;
  }
}
function ke$1(a, b2) {
  if (ie$1)
    return "compositionend" === a || !ae$1 && ge$1(a, b2) ? (a = nd(), md = ld = kd = null, ie$1 = false, a) : null;
  switch (a) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length)
          return b2.char;
        if (b2.which)
          return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
var le$1 = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me$1(a) {
  var b2 = a && a.nodeName && a.nodeName.toLowerCase();
  return "input" === b2 ? !!le$1[a.type] : "textarea" === b2 ? true : false;
}
function ne$1(a, b2, c, d) {
  Eb(d);
  b2 = oe$1(b2, "onChange");
  0 < b2.length && (c = new td("onChange", "change", null, c, d), a.push({ event: c, listeners: b2 }));
}
var pe = null, qe$1 = null;
function re$1(a) {
  se$1(a, 0);
}
function te$1(a) {
  var b2 = ue$1(a);
  if (Wa(b2))
    return a;
}
function ve$1(a, b2) {
  if ("change" === a)
    return b2;
}
var we$1 = false;
if (ia) {
  var xe$1;
  if (ia) {
    var ye$1 = "oninput" in document;
    if (!ye$1) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye$1 = "function" === typeof ze.oninput;
    }
    xe$1 = ye$1;
  } else
    xe$1 = false;
  we$1 = xe$1 && (!document.documentMode || 9 < document.documentMode);
}
function Ae$1() {
  pe && (pe.detachEvent("onpropertychange", Be$1), qe$1 = pe = null);
}
function Be$1(a) {
  if ("value" === a.propertyName && te$1(qe$1)) {
    var b2 = [];
    ne$1(b2, qe$1, a, xb(a));
    Jb(re$1, b2);
  }
}
function Ce$1(a, b2, c) {
  "focusin" === a ? (Ae$1(), pe = b2, qe$1 = c, pe.attachEvent("onpropertychange", Be$1)) : "focusout" === a && Ae$1();
}
function De$1(a) {
  if ("selectionchange" === a || "keyup" === a || "keydown" === a)
    return te$1(qe$1);
}
function Ee$1(a, b2) {
  if ("click" === a)
    return te$1(b2);
}
function Fe$1(a, b2) {
  if ("input" === a || "change" === a)
    return te$1(b2);
}
function Ge$1(a, b2) {
  return a === b2 && (0 !== a || 1 / a === 1 / b2) || a !== a && b2 !== b2;
}
var He$1 = "function" === typeof Object.is ? Object.is : Ge$1;
function Ie$1(a, b2) {
  if (He$1(a, b2))
    return true;
  if ("object" !== typeof a || null === a || "object" !== typeof b2 || null === b2)
    return false;
  var c = Object.keys(a), d = Object.keys(b2);
  if (c.length !== d.length)
    return false;
  for (d = 0; d < c.length; d++) {
    var e2 = c[d];
    if (!ja.call(b2, e2) || !He$1(a[e2], b2[e2]))
      return false;
  }
  return true;
}
function Je$1(a) {
  for (; a && a.firstChild; )
    a = a.firstChild;
  return a;
}
function Ke$1(a, b2) {
  var c = Je$1(a);
  a = 0;
  for (var d; c; ) {
    if (3 === c.nodeType) {
      d = a + c.textContent.length;
      if (a <= b2 && d >= b2)
        return { node: c, offset: b2 - a };
      a = d;
    }
    a: {
      for (; c; ) {
        if (c.nextSibling) {
          c = c.nextSibling;
          break a;
        }
        c = c.parentNode;
      }
      c = void 0;
    }
    c = Je$1(c);
  }
}
function Le(a, b2) {
  return a && b2 ? a === b2 ? true : a && 3 === a.nodeType ? false : b2 && 3 === b2.nodeType ? Le(a, b2.parentNode) : "contains" in a ? a.contains(b2) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b2) & 16) : false : false;
}
function Me$1() {
  for (var a = window, b2 = Xa(); b2 instanceof a.HTMLIFrameElement; ) {
    try {
      var c = "string" === typeof b2.contentWindow.location.href;
    } catch (d) {
      c = false;
    }
    if (c)
      a = b2.contentWindow;
    else
      break;
    b2 = Xa(a.document);
  }
  return b2;
}
function Ne$1(a) {
  var b2 = a && a.nodeName && a.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b2 || "true" === a.contentEditable);
}
function Oe$1(a) {
  var b2 = Me$1(), c = a.focusedElem, d = a.selectionRange;
  if (b2 !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
    if (null !== d && Ne$1(c)) {
      if (b2 = d.start, a = d.end, void 0 === a && (a = b2), "selectionStart" in c)
        c.selectionStart = b2, c.selectionEnd = Math.min(a, c.value.length);
      else if (a = (b2 = c.ownerDocument || document) && b2.defaultView || window, a.getSelection) {
        a = a.getSelection();
        var e2 = c.textContent.length, f2 = Math.min(d.start, e2);
        d = void 0 === d.end ? f2 : Math.min(d.end, e2);
        !a.extend && f2 > d && (e2 = d, d = f2, f2 = e2);
        e2 = Ke$1(c, f2);
        var g2 = Ke$1(
          c,
          d
        );
        e2 && g2 && (1 !== a.rangeCount || a.anchorNode !== e2.node || a.anchorOffset !== e2.offset || a.focusNode !== g2.node || a.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a.removeAllRanges(), f2 > d ? (a.addRange(b2), a.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a.addRange(b2)));
      }
    }
    b2 = [];
    for (a = c; a = a.parentNode; )
      1 === a.nodeType && b2.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
    "function" === typeof c.focus && c.focus();
    for (c = 0; c < b2.length; c++)
      a = b2[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
  }
}
var Pe$1 = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re$1 = null, Se$1 = null, Te$1 = false;
function Ue$1(a, b2, c) {
  var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
  Te$1 || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Ne$1(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se$1 && Ie$1(Se$1, d) || (Se$1 = d, d = oe$1(Re$1, "onSelect"), 0 < d.length && (b2 = new td("onSelect", "select", null, b2, c), a.push({ event: b2, listeners: d }), b2.target = Qe)));
}
function Ve$1(a, b2) {
  var c = {};
  c[a.toLowerCase()] = b2.toLowerCase();
  c["Webkit" + a] = "webkit" + b2;
  c["Moz" + a] = "moz" + b2;
  return c;
}
var We$1 = { animationend: Ve$1("Animation", "AnimationEnd"), animationiteration: Ve$1("Animation", "AnimationIteration"), animationstart: Ve$1("Animation", "AnimationStart"), transitionend: Ve$1("Transition", "TransitionEnd") }, Xe$1 = {}, Ye$1 = {};
ia && (Ye$1 = document.createElement("div").style, "AnimationEvent" in window || (delete We$1.animationend.animation, delete We$1.animationiteration.animation, delete We$1.animationstart.animation), "TransitionEvent" in window || delete We$1.transitionend.transition);
function Ze$1(a) {
  if (Xe$1[a])
    return Xe$1[a];
  if (!We$1[a])
    return a;
  var b2 = We$1[a], c;
  for (c in b2)
    if (b2.hasOwnProperty(c) && c in Ye$1)
      return Xe$1[a] = b2[c];
  return a;
}
var $e = Ze$1("animationend"), af = Ze$1("animationiteration"), bf = Ze$1("animationstart"), cf = Ze$1("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a, b2) {
  df.set(a, b2);
  fa(b2, [a]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a, b2, c) {
  var d = a.type || "unknown-event";
  a.currentTarget = c;
  Ub(d, b2, void 0, a);
  a.currentTarget = null;
}
function se$1(a, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c = 0; c < a.length; c++) {
    var d = a[c], e2 = d.event;
    d = d.listeners;
    a: {
      var f2 = void 0;
      if (b2)
        for (var g2 = d.length - 1; 0 <= g2; g2--) {
          var h2 = d[g2], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
      else
        for (g2 = 0; g2 < d.length; g2++) {
          h2 = d[g2];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
    }
  }
  if (Qb)
    throw a = Rb, Qb = false, Rb = null, a;
}
function D$1(a, b2) {
  var c = b2[of$2];
  void 0 === c && (c = b2[of$2] = /* @__PURE__ */ new Set());
  var d = a + "__bubble";
  c.has(d) || (pf(b2, a, 2, false), c.add(d));
}
function qf(a, b2, c) {
  var d = 0;
  b2 && (d |= 4);
  pf(c, a, d, b2);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a) {
  if (!a[rf]) {
    a[rf] = true;
    da.forEach(function(b3) {
      "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a), qf(b3, true, a));
    });
    var b2 = 9 === a.nodeType ? a : a.ownerDocument;
    null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
  }
}
function pf(a, b2, c, d) {
  switch (jd(b2)) {
    case 1:
      var e2 = ed;
      break;
    case 4:
      e2 = gd;
      break;
    default:
      e2 = fd;
  }
  c = e2.bind(null, b2, c, a);
  e2 = void 0;
  !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
  d ? void 0 !== e2 ? a.addEventListener(b2, c, { capture: true, passive: e2 }) : a.addEventListener(b2, c, true) : void 0 !== e2 ? a.addEventListener(b2, c, { passive: e2 }) : a.addEventListener(b2, c, false);
}
function hd(a, b2, c, d, e2) {
  var f2 = d;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d)
    a:
      for (; ; ) {
        if (null === d)
          return;
        var g2 = d.tag;
        if (3 === g2 || 4 === g2) {
          var h2 = d.stateNode.containerInfo;
          if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2)
            break;
          if (4 === g2)
            for (g2 = d.return; null !== g2; ) {
              var k2 = g2.tag;
              if (3 === k2 || 4 === k2) {
                if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2)
                  return;
              }
              g2 = g2.return;
            }
          for (; null !== h2; ) {
            g2 = Wc(h2);
            if (null === g2)
              return;
            k2 = g2.tag;
            if (5 === k2 || 6 === k2) {
              d = f2 = g2;
              continue a;
            }
            h2 = h2.parentNode;
          }
        }
        d = d.return;
      }
  Jb(function() {
    var d2 = f2, e3 = xb(c), g3 = [];
    a: {
      var h3 = df.get(a);
      if (void 0 !== h3) {
        var k3 = td, n2 = a;
        switch (a) {
          case "keypress":
            if (0 === od(c))
              break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
        t2 = [];
        for (var w2 = d2, u2; null !== w2; ) {
          u2 = w2;
          var F2 = u2.stateNode;
          5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
          if (J2)
            break;
          w2 = w2.return;
        }
        0 < t2.length && (h3 = new k3(h3, n2, null, c, e3), g3.push({ event: h3, listeners: t2 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h3 = "mouseover" === a || "pointerover" === a;
        k3 = "mouseout" === a || "pointerout" === a;
        if (h3 && c !== wb && (n2 = c.relatedTarget || c.fromElement) && (Wc(n2) || n2[uf]))
          break a;
        if (k3 || h3) {
          h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (n2 = c.relatedTarget || c.toElement, k3 = d2, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
              n2 = null;
          } else
            k3 = null, n2 = d2;
          if (k3 !== n2) {
            t2 = Bd;
            F2 = "onMouseLeave";
            x2 = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a || "pointerover" === a)
              t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
            J2 = null == k3 ? h3 : ue$1(k3);
            u2 = null == n2 ? h3 : ue$1(n2);
            h3 = new t2(F2, w2 + "leave", k3, c, e3);
            h3.target = J2;
            h3.relatedTarget = u2;
            F2 = null;
            Wc(e3) === d2 && (t2 = new t2(x2, w2 + "enter", n2, c, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
            J2 = F2;
            if (k3 && n2)
              b: {
                t2 = k3;
                x2 = n2;
                w2 = 0;
                for (u2 = t2; u2; u2 = vf(u2))
                  w2++;
                u2 = 0;
                for (F2 = x2; F2; F2 = vf(F2))
                  u2++;
                for (; 0 < w2 - u2; )
                  t2 = vf(t2), w2--;
                for (; 0 < u2 - w2; )
                  x2 = vf(x2), u2--;
                for (; w2--; ) {
                  if (t2 === x2 || null !== x2 && t2 === x2.alternate)
                    break b;
                  t2 = vf(t2);
                  x2 = vf(x2);
                }
                t2 = null;
              }
            else
              t2 = null;
            null !== k3 && wf(g3, h3, k3, t2, false);
            null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
          }
        }
      }
      a: {
        h3 = d2 ? ue$1(d2) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type)
          var na = ve$1;
        else if (me$1(h3))
          if (we$1)
            na = Fe$1;
          else {
            na = De$1;
            var xa = Ce$1;
          }
        else
          (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee$1);
        if (na && (na = na(a, d2))) {
          ne$1(g3, na, c, e3);
          break a;
        }
        xa && xa(a, h3, d2);
        "focusout" === a && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
      }
      xa = d2 ? ue$1(d2) : window;
      switch (a) {
        case "focusin":
          if (me$1(xa) || "true" === xa.contentEditable)
            Qe = xa, Re$1 = d2, Se$1 = null;
          break;
        case "focusout":
          Se$1 = Re$1 = Qe = null;
          break;
        case "mousedown":
          Te$1 = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te$1 = false;
          Ue$1(g3, c, e3);
          break;
        case "selectionchange":
          if (Pe$1)
            break;
        case "keydown":
        case "keyup":
          Ue$1(g3, c, e3);
      }
      var $a;
      if (ae$1)
        b: {
          switch (a) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
      else
        ie$1 ? ge$1(a, c) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (ba = "onCompositionStart");
      ba && (de && "ko" !== c.locale && (ie$1 || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie$1 && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie$1 = true)), xa = oe$1(d2, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he$1(c), null !== $a && (ba.data = $a))));
      if ($a = ce$1 ? je$1(a, c) : ke$1(a, c))
        d2 = oe$1(d2, "onBeforeInput"), 0 < d2.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c, e3), g3.push({ event: e3, listeners: d2 }), e3.data = $a);
    }
    se$1(g3, b2);
  });
}
function tf(a, b2, c) {
  return { instance: a, listener: b2, currentTarget: c };
}
function oe$1(a, b2) {
  for (var c = b2 + "Capture", d = []; null !== a; ) {
    var e2 = a, f2 = e2.stateNode;
    5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a, c), null != f2 && d.unshift(tf(a, f2, e2)), f2 = Kb(a, b2), null != f2 && d.push(tf(a, f2, e2)));
    a = a.return;
  }
  return d;
}
function vf(a) {
  if (null === a)
    return null;
  do
    a = a.return;
  while (a && 5 !== a.tag);
  return a ? a : null;
}
function wf(a, b2, c, d, e2) {
  for (var f2 = b2._reactName, g2 = []; null !== c && c !== d; ) {
    var h2 = c, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d)
      break;
    5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c, f2), null != k2 && g2.unshift(tf(c, k2, h2))) : e2 || (k2 = Kb(c, f2), null != k2 && g2.push(tf(c, k2, h2))));
    c = c.return;
  }
  0 !== g2.length && a.push({ event: b2, listeners: g2 });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a) {
  return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
}
function Af(a, b2, c) {
  b2 = zf(b2);
  if (zf(a) !== b2 && c)
    throw Error(p$2(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a, b2) {
  return "textarea" === a || "noscript" === a || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
  return Hf.resolve(null).then(a).catch(If);
} : Ff;
function If(a) {
  setTimeout(function() {
    throw a;
  });
}
function Kf(a, b2) {
  var c = b2, d = 0;
  do {
    var e2 = c.nextSibling;
    a.removeChild(c);
    if (e2 && 8 === e2.nodeType)
      if (c = e2.data, "/$" === c) {
        if (0 === d) {
          a.removeChild(e2);
          bd(b2);
          return;
        }
        d--;
      } else
        "$" !== c && "$?" !== c && "$!" !== c || d++;
    c = e2;
  } while (c);
  bd(b2);
}
function Lf(a) {
  for (; null != a; a = a.nextSibling) {
    var b2 = a.nodeType;
    if (1 === b2 || 3 === b2)
      break;
    if (8 === b2) {
      b2 = a.data;
      if ("$" === b2 || "$!" === b2 || "$?" === b2)
        break;
      if ("/$" === b2)
        return null;
    }
  }
  return a;
}
function Mf(a) {
  a = a.previousSibling;
  for (var b2 = 0; a; ) {
    if (8 === a.nodeType) {
      var c = a.data;
      if ("$" === c || "$!" === c || "$?" === c) {
        if (0 === b2)
          return a;
        b2--;
      } else
        "/$" === c && b2++;
    }
    a = a.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of$2 = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a) {
  var b2 = a[Of];
  if (b2)
    return b2;
  for (var c = a.parentNode; c; ) {
    if (b2 = c[uf] || c[Of]) {
      c = b2.alternate;
      if (null !== b2.child || null !== c && null !== c.child)
        for (a = Mf(a); null !== a; ) {
          if (c = a[Of])
            return c;
          a = Mf(a);
        }
      return b2;
    }
    a = c;
    c = a.parentNode;
  }
  return null;
}
function Cb(a) {
  a = a[Of] || a[uf];
  return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
}
function ue$1(a) {
  if (5 === a.tag || 6 === a.tag)
    return a.stateNode;
  throw Error(p$2(33));
}
function Db(a) {
  return a[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a) {
  return { current: a };
}
function E(a) {
  0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G$1(a, b2) {
  Tf++;
  Sf[Tf] = a.current;
  a.current = b2;
}
var Vf = {}, H$2 = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a, b2) {
  var c = a.type.contextTypes;
  if (!c)
    return Vf;
  var d = a.stateNode;
  if (d && d.__reactInternalMemoizedUnmaskedChildContext === b2)
    return d.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c)
    e2[f2] = b2[f2];
  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b2, a.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Zf(a) {
  a = a.childContextTypes;
  return null !== a && void 0 !== a;
}
function $f() {
  E(Wf);
  E(H$2);
}
function ag(a, b2, c) {
  if (H$2.current !== Vf)
    throw Error(p$2(168));
  G$1(H$2, b2);
  G$1(Wf, c);
}
function bg(a, b2, c) {
  var d = a.stateNode;
  b2 = b2.childContextTypes;
  if ("function" !== typeof d.getChildContext)
    return c;
  d = d.getChildContext();
  for (var e2 in d)
    if (!(e2 in b2))
      throw Error(p$2(108, Ra(a) || "Unknown", e2));
  return A$1({}, c, d);
}
function cg(a) {
  a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H$2.current;
  G$1(H$2, a);
  G$1(Wf, Wf.current);
  return true;
}
function dg(a, b2, c) {
  var d = a.stateNode;
  if (!d)
    throw Error(p$2(169));
  c ? (a = bg(a, b2, Xf), d.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H$2), G$1(H$2, a)) : E(Wf);
  G$1(Wf, c);
}
var eg = null, fg = false, gg = false;
function hg(a) {
  null === eg ? eg = [a] : eg.push(a);
}
function ig(a) {
  fg = true;
  hg(a);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a = 0, b2 = C$1;
    try {
      var c = eg;
      for (C$1 = 1; a < c.length; a++) {
        var d = c[a];
        do
          d = d(true);
        while (null !== d);
      }
      eg = null;
      fg = false;
    } catch (e2) {
      throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e2;
    } finally {
      C$1 = b2, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a, b2) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a;
  ng = b2;
}
function ug(a, b2, c) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a;
  var d = rg;
  a = sg;
  var e2 = 32 - oc(d) - 1;
  d &= ~(1 << e2);
  c += 1;
  var f2 = 32 - oc(b2) + e2;
  if (30 < f2) {
    var g2 = e2 - e2 % 5;
    f2 = (d & (1 << g2) - 1).toString(32);
    d >>= g2;
    e2 -= g2;
    rg = 1 << 32 - oc(b2) + e2 | c << e2 | d;
    sg = f2 + a;
  } else
    rg = 1 << f2 | c << e2 | d, sg = a;
}
function vg(a) {
  null !== a.return && (tg(a, 1), ug(a, 1, 0));
}
function wg(a) {
  for (; a === mg; )
    mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a === qg; )
    qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I$1 = false, zg = null;
function Ag(a, b2) {
  var c = Bg(5, null, null, 0);
  c.elementType = "DELETED";
  c.stateNode = b2;
  c.return = a;
  b2 = a.deletions;
  null === b2 ? (a.deletions = [c], a.flags |= 16) : b2.push(c);
}
function Cg(a, b2) {
  switch (a.tag) {
    case 5:
      var c = a.type;
      b2 = 1 !== b2.nodeType || c.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a.stateNode = b2, xg = a, yg = Lf(b2.firstChild), true) : false;
    case 6:
      return b2 = "" === a.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a.stateNode = b2, xg = a, yg = null, true) : false;
    case 13:
      return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b2, treeContext: c, retryLane: 1073741824 }, c = Bg(18, null, null, 0), c.stateNode = b2, c.return = a, a.child = c, xg = a, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a) {
  return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
}
function Eg(a) {
  if (I$1) {
    var b2 = yg;
    if (b2) {
      var c = b2;
      if (!Cg(a, b2)) {
        if (Dg(a))
          throw Error(p$2(418));
        b2 = Lf(c.nextSibling);
        var d = xg;
        b2 && Cg(a, b2) ? Ag(d, c) : (a.flags = a.flags & -4097 | 2, I$1 = false, xg = a);
      }
    } else {
      if (Dg(a))
        throw Error(p$2(418));
      a.flags = a.flags & -4097 | 2;
      I$1 = false;
      xg = a;
    }
  }
}
function Fg(a) {
  for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; )
    a = a.return;
  xg = a;
}
function Gg(a) {
  if (a !== xg)
    return false;
  if (!I$1)
    return Fg(a), I$1 = true, false;
  var b2;
  (b2 = 3 !== a.tag) && !(b2 = 5 !== a.tag) && (b2 = a.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a.type, a.memoizedProps));
  if (b2 && (b2 = yg)) {
    if (Dg(a))
      throw Hg(), Error(p$2(418));
    for (; b2; )
      Ag(a, b2), b2 = Lf(b2.nextSibling);
  }
  Fg(a);
  if (13 === a.tag) {
    a = a.memoizedState;
    a = null !== a ? a.dehydrated : null;
    if (!a)
      throw Error(p$2(317));
    a: {
      a = a.nextSibling;
      for (b2 = 0; a; ) {
        if (8 === a.nodeType) {
          var c = a.data;
          if ("/$" === c) {
            if (0 === b2) {
              yg = Lf(a.nextSibling);
              break a;
            }
            b2--;
          } else
            "$" !== c && "$!" !== c && "$?" !== c || b2++;
        }
        a = a.nextSibling;
      }
      yg = null;
    }
  } else
    yg = xg ? Lf(a.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a = yg; a; )
    a = Lf(a.nextSibling);
}
function Ig() {
  yg = xg = null;
  I$1 = false;
}
function Jg(a) {
  null === zg ? zg = [a] : zg.push(a);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a, b2) {
  if (a && a.defaultProps) {
    b2 = A$1({}, b2);
    a = a.defaultProps;
    for (var c in a)
      void 0 === b2[c] && (b2[c] = a[c]);
    return b2;
  }
  return b2;
}
var Mg = Uf(null), Ng = null, Og = null, Pg = null;
function Qg() {
  Pg = Og = Ng = null;
}
function Rg(a) {
  var b2 = Mg.current;
  E(Mg);
  a._currentValue = b2;
}
function Sg(a, b2, c) {
  for (; null !== a; ) {
    var d = a.alternate;
    (a.childLanes & b2) !== b2 ? (a.childLanes |= b2, null !== d && (d.childLanes |= b2)) : null !== d && (d.childLanes & b2) !== b2 && (d.childLanes |= b2);
    if (a === c)
      break;
    a = a.return;
  }
}
function Tg(a, b2) {
  Ng = a;
  Pg = Og = null;
  a = a.dependencies;
  null !== a && null !== a.firstContext && (0 !== (a.lanes & b2) && (Ug = true), a.firstContext = null);
}
function Vg(a) {
  var b2 = a._currentValue;
  if (Pg !== a)
    if (a = { context: a, memoizedValue: b2, next: null }, null === Og) {
      if (null === Ng)
        throw Error(p$2(308));
      Og = a;
      Ng.dependencies = { lanes: 0, firstContext: a };
    } else
      Og = Og.next = a;
  return b2;
}
var Wg = null;
function Xg(a) {
  null === Wg ? Wg = [a] : Wg.push(a);
}
function Yg(a, b2, c, d) {
  var e2 = b2.interleaved;
  null === e2 ? (c.next = c, Xg(b2)) : (c.next = e2.next, e2.next = c);
  b2.interleaved = c;
  return Zg(a, d);
}
function Zg(a, b2) {
  a.lanes |= b2;
  var c = a.alternate;
  null !== c && (c.lanes |= b2);
  c = a;
  for (a = a.return; null !== a; )
    a.childLanes |= b2, c = a.alternate, null !== c && (c.childLanes |= b2), c = a, a = a.return;
  return 3 === c.tag ? c.stateNode : null;
}
var $g = false;
function ah(a) {
  a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function bh(a, b2) {
  a = a.updateQueue;
  b2.updateQueue === a && (b2.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
}
function ch(a, b2) {
  return { eventTime: a, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function dh(a, b2, c) {
  var d = a.updateQueue;
  if (null === d)
    return null;
  d = d.shared;
  if (0 !== (K$2 & 2)) {
    var e2 = d.pending;
    null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
    d.pending = b2;
    return Zg(a, c);
  }
  e2 = d.interleaved;
  null === e2 ? (b2.next = b2, Xg(d)) : (b2.next = e2.next, e2.next = b2);
  d.interleaved = b2;
  return Zg(a, c);
}
function eh(a, b2, c) {
  b2 = b2.updateQueue;
  if (null !== b2 && (b2 = b2.shared, 0 !== (c & 4194240))) {
    var d = b2.lanes;
    d &= a.pendingLanes;
    c |= d;
    b2.lanes = c;
    Cc(a, c);
  }
}
function fh(a, b2) {
  var c = a.updateQueue, d = a.alternate;
  if (null !== d && (d = d.updateQueue, c === d)) {
    var e2 = null, f2 = null;
    c = c.firstBaseUpdate;
    if (null !== c) {
      do {
        var g2 = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
        null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
        c = c.next;
      } while (null !== c);
      null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
    } else
      e2 = f2 = b2;
    c = { baseState: d.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d.shared, effects: d.effects };
    a.updateQueue = c;
    return;
  }
  a = c.lastBaseUpdate;
  null === a ? c.firstBaseUpdate = b2 : a.next = b2;
  c.lastBaseUpdate = b2;
}
function gh(a, b2, c, d) {
  var e2 = a.updateQueue;
  $g = false;
  var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (null !== h2) {
    e2.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k2;
    var m2 = a.alternate;
    null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (null !== f2) {
    var q2 = e2.baseState;
    g2 = 0;
    m2 = l2 = k2 = null;
    h2 = f2;
    do {
      var r2 = h2.lane, y2 = h2.eventTime;
      if ((d & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n2 = a, t2 = h2;
          r2 = b2;
          y2 = c;
          switch (t2.tag) {
            case 1:
              n2 = t2.payload;
              if ("function" === typeof n2) {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t2.payload;
              r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
              if (null === r2 || void 0 === r2)
                break a;
              q2 = A$1({}, q2, r2);
              break a;
            case 2:
              $g = true;
          }
        }
        null !== h2.callback && 0 !== h2.lane && (a.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
      } else
        y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
      h2 = h2.next;
      if (null === h2)
        if (h2 = e2.shared.pending, null === h2)
          break;
        else
          r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
    } while (1);
    null === m2 && (k2 = q2);
    e2.baseState = k2;
    e2.firstBaseUpdate = l2;
    e2.lastBaseUpdate = m2;
    b2 = e2.shared.interleaved;
    if (null !== b2) {
      e2 = b2;
      do
        g2 |= e2.lane, e2 = e2.next;
      while (e2 !== b2);
    } else
      null === f2 && (e2.shared.lanes = 0);
    hh |= g2;
    a.lanes = g2;
    a.memoizedState = q2;
  }
}
function ih(a, b2, c) {
  a = b2.effects;
  b2.effects = null;
  if (null !== a)
    for (b2 = 0; b2 < a.length; b2++) {
      var d = a[b2], e2 = d.callback;
      if (null !== e2) {
        d.callback = null;
        d = c;
        if ("function" !== typeof e2)
          throw Error(p$2(191, e2));
        e2.call(d);
      }
    }
}
var jh = new aa.Component().refs;
function kh(a, b2, c, d) {
  b2 = a.memoizedState;
  c = c(d, b2);
  c = null === c || void 0 === c ? b2 : A$1({}, b2, c);
  a.memoizedState = c;
  0 === a.lanes && (a.updateQueue.baseState = c);
}
var nh = { isMounted: function(a) {
  return (a = a._reactInternals) ? Vb(a) === a : false;
}, enqueueSetState: function(a, b2, c) {
  a = a._reactInternals;
  var d = L$1(), e2 = lh(a), f2 = ch(d, e2);
  f2.payload = b2;
  void 0 !== c && null !== c && (f2.callback = c);
  b2 = dh(a, f2, e2);
  null !== b2 && (mh(b2, a, e2, d), eh(b2, a, e2));
}, enqueueReplaceState: function(a, b2, c) {
  a = a._reactInternals;
  var d = L$1(), e2 = lh(a), f2 = ch(d, e2);
  f2.tag = 1;
  f2.payload = b2;
  void 0 !== c && null !== c && (f2.callback = c);
  b2 = dh(a, f2, e2);
  null !== b2 && (mh(b2, a, e2, d), eh(b2, a, e2));
}, enqueueForceUpdate: function(a, b2) {
  a = a._reactInternals;
  var c = L$1(), d = lh(a), e2 = ch(c, d);
  e2.tag = 2;
  void 0 !== b2 && null !== b2 && (e2.callback = b2);
  b2 = dh(a, e2, d);
  null !== b2 && (mh(b2, a, d, c), eh(b2, a, d));
} };
function oh(a, b2, c, d, e2, f2, g2) {
  a = a.stateNode;
  return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie$1(c, d) || !Ie$1(e2, f2) : true;
}
function ph(a, b2, c) {
  var d = false, e2 = Vf;
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = Vg(f2) : (e2 = Zf(b2) ? Xf : H$2.current, d = b2.contextTypes, f2 = (d = null !== d && void 0 !== d) ? Yf(a, e2) : Vf);
  b2 = new b2(c, f2);
  a.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = nh;
  a.stateNode = b2;
  b2._reactInternals = a;
  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e2, a.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function qh(a, b2, c, d) {
  a = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c, d);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c, d);
  b2.state !== a && nh.enqueueReplaceState(b2, b2.state, null);
}
function rh(a, b2, c, d) {
  var e2 = a.stateNode;
  e2.props = c;
  e2.state = a.memoizedState;
  e2.refs = jh;
  ah(a);
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? e2.context = Vg(f2) : (f2 = Zf(b2) ? Xf : H$2.current, e2.context = Yf(a, f2));
  e2.state = a.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  "function" === typeof f2 && (kh(a, b2, f2, c), e2.state = a.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && nh.enqueueReplaceState(e2, e2.state, null), gh(a, c, e2, d), e2.state = a.memoizedState);
  "function" === typeof e2.componentDidMount && (a.flags |= 4194308);
}
function sh(a, b2, c) {
  a = c.ref;
  if (null !== a && "function" !== typeof a && "object" !== typeof a) {
    if (c._owner) {
      c = c._owner;
      if (c) {
        if (1 !== c.tag)
          throw Error(p$2(309));
        var d = c.stateNode;
      }
      if (!d)
        throw Error(p$2(147, a));
      var e2 = d, f2 = "" + a;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2)
        return b2.ref;
      b2 = function(a2) {
        var b3 = e2.refs;
        b3 === jh && (b3 = e2.refs = {});
        null === a2 ? delete b3[f2] : b3[f2] = a2;
      };
      b2._stringRef = f2;
      return b2;
    }
    if ("string" !== typeof a)
      throw Error(p$2(284));
    if (!c._owner)
      throw Error(p$2(290, a));
  }
  return a;
}
function th(a, b2) {
  a = Object.prototype.toString.call(b2);
  throw Error(p$2(31, "[object Object]" === a ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a));
}
function uh(a) {
  var b2 = a._init;
  return b2(a._payload);
}
function vh(a) {
  function b2(b3, c2) {
    if (a) {
      var d2 = b3.deletions;
      null === d2 ? (b3.deletions = [c2], b3.flags |= 16) : d2.push(c2);
    }
  }
  function c(c2, d2) {
    if (!a)
      return null;
    for (; null !== d2; )
      b2(c2, d2), d2 = d2.sibling;
    return null;
  }
  function d(a2, b3) {
    for (a2 = /* @__PURE__ */ new Map(); null !== b3; )
      null !== b3.key ? a2.set(b3.key, b3) : a2.set(b3.index, b3), b3 = b3.sibling;
    return a2;
  }
  function e2(a2, b3) {
    a2 = wh(a2, b3);
    a2.index = 0;
    a2.sibling = null;
    return a2;
  }
  function f2(b3, c2, d2) {
    b3.index = d2;
    if (!a)
      return b3.flags |= 1048576, c2;
    d2 = b3.alternate;
    if (null !== d2)
      return d2 = d2.index, d2 < c2 ? (b3.flags |= 2, c2) : d2;
    b3.flags |= 2;
    return c2;
  }
  function g2(b3) {
    a && null === b3.alternate && (b3.flags |= 2);
    return b3;
  }
  function h2(a2, b3, c2, d2) {
    if (null === b3 || 6 !== b3.tag)
      return b3 = xh(c2, a2.mode, d2), b3.return = a2, b3;
    b3 = e2(b3, c2);
    b3.return = a2;
    return b3;
  }
  function k2(a2, b3, c2, d2) {
    var f3 = c2.type;
    if (f3 === ya)
      return m2(a2, b3, c2.props.children, d2, c2.key);
    if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && uh(f3) === b3.type))
      return d2 = e2(b3, c2.props), d2.ref = sh(a2, b3, c2), d2.return = a2, d2;
    d2 = yh(c2.type, c2.key, c2.props, null, a2.mode, d2);
    d2.ref = sh(a2, b3, c2);
    d2.return = a2;
    return d2;
  }
  function l2(a2, b3, c2, d2) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c2.containerInfo || b3.stateNode.implementation !== c2.implementation)
      return b3 = zh(c2, a2.mode, d2), b3.return = a2, b3;
    b3 = e2(b3, c2.children || []);
    b3.return = a2;
    return b3;
  }
  function m2(a2, b3, c2, d2, f3) {
    if (null === b3 || 7 !== b3.tag)
      return b3 = Ah(c2, a2.mode, d2, f3), b3.return = a2, b3;
    b3 = e2(b3, c2);
    b3.return = a2;
    return b3;
  }
  function q2(a2, b3, c2) {
    if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3)
      return b3 = xh("" + b3, a2.mode, c2), b3.return = a2, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case va:
          return c2 = yh(b3.type, b3.key, b3.props, null, a2.mode, c2), c2.ref = sh(a2, null, b3), c2.return = a2, c2;
        case wa:
          return b3 = zh(b3, a2.mode, c2), b3.return = a2, b3;
        case Ha:
          var d2 = b3._init;
          return q2(a2, d2(b3._payload), c2);
      }
      if (eb(b3) || Ka(b3))
        return b3 = Ah(b3, a2.mode, c2, null), b3.return = a2, b3;
      th(a2, b3);
    }
    return null;
  }
  function r2(a2, b3, c2, d2) {
    var e3 = null !== b3 ? b3.key : null;
    if ("string" === typeof c2 && "" !== c2 || "number" === typeof c2)
      return null !== e3 ? null : h2(a2, b3, "" + c2, d2);
    if ("object" === typeof c2 && null !== c2) {
      switch (c2.$$typeof) {
        case va:
          return c2.key === e3 ? k2(a2, b3, c2, d2) : null;
        case wa:
          return c2.key === e3 ? l2(a2, b3, c2, d2) : null;
        case Ha:
          return e3 = c2._init, r2(
            a2,
            b3,
            e3(c2._payload),
            d2
          );
      }
      if (eb(c2) || Ka(c2))
        return null !== e3 ? null : m2(a2, b3, c2, d2, null);
      th(a2, c2);
    }
    return null;
  }
  function y2(a2, b3, c2, d2, e3) {
    if ("string" === typeof d2 && "" !== d2 || "number" === typeof d2)
      return a2 = a2.get(c2) || null, h2(b3, a2, "" + d2, e3);
    if ("object" === typeof d2 && null !== d2) {
      switch (d2.$$typeof) {
        case va:
          return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, k2(b3, a2, d2, e3);
        case wa:
          return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, l2(b3, a2, d2, e3);
        case Ha:
          var f3 = d2._init;
          return y2(a2, b3, c2, f3(d2._payload), e3);
      }
      if (eb(d2) || Ka(d2))
        return a2 = a2.get(c2) || null, m2(b3, a2, d2, e3, null);
      th(b3, d2);
    }
    return null;
  }
  function n2(e3, g3, h3, k3) {
    for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
      u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
      var n3 = r2(e3, u2, h3[w2], k3);
      if (null === n3) {
        null === u2 && (u2 = x2);
        break;
      }
      a && u2 && null === n3.alternate && b2(e3, u2);
      g3 = f2(n3, g3, w2);
      null === m3 ? l3 = n3 : m3.sibling = n3;
      m3 = n3;
      u2 = x2;
    }
    if (w2 === h3.length)
      return c(e3, u2), I$1 && tg(e3, w2), l3;
    if (null === u2) {
      for (; w2 < h3.length; w2++)
        u2 = q2(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I$1 && tg(e3, w2);
      return l3;
    }
    for (u2 = d(e3, u2); w2 < h3.length; w2++)
      x2 = y2(u2, e3, w2, h3[w2], k3), null !== x2 && (a && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
    a && u2.forEach(function(a2) {
      return b2(e3, a2);
    });
    I$1 && tg(e3, w2);
    return l3;
  }
  function t2(e3, g3, h3, k3) {
    var l3 = Ka(h3);
    if ("function" !== typeof l3)
      throw Error(p$2(150));
    h3 = l3.call(h3);
    if (null == h3)
      throw Error(p$2(151));
    for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
      m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
      var t3 = r2(e3, m3, n3.value, k3);
      if (null === t3) {
        null === m3 && (m3 = x2);
        break;
      }
      a && m3 && null === t3.alternate && b2(e3, m3);
      g3 = f2(t3, g3, w2);
      null === u2 ? l3 = t3 : u2.sibling = t3;
      u2 = t3;
      m3 = x2;
    }
    if (n3.done)
      return c(
        e3,
        m3
      ), I$1 && tg(e3, w2), l3;
    if (null === m3) {
      for (; !n3.done; w2++, n3 = h3.next())
        n3 = q2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      I$1 && tg(e3, w2);
      return l3;
    }
    for (m3 = d(e3, m3); !n3.done; w2++, n3 = h3.next())
      n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
    a && m3.forEach(function(a2) {
      return b2(e3, a2);
    });
    I$1 && tg(e3, w2);
    return l3;
  }
  function J2(a2, d2, f3, h3) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k3 = f3.key, l3 = d2; null !== l3; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === ya) {
                  if (7 === l3.tag) {
                    c(a2, l3.sibling);
                    d2 = e2(l3, f3.props.children);
                    d2.return = a2;
                    a2 = d2;
                    break a;
                  }
                } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && uh(k3) === l3.type) {
                  c(a2, l3.sibling);
                  d2 = e2(l3, f3.props);
                  d2.ref = sh(a2, l3, f3);
                  d2.return = a2;
                  a2 = d2;
                  break a;
                }
                c(a2, l3);
                break;
              } else
                b2(a2, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d2 = Ah(f3.props.children, a2.mode, h3, f3.key), d2.return = a2, a2 = d2) : (h3 = yh(f3.type, f3.key, f3.props, null, a2.mode, h3), h3.ref = sh(a2, d2, f3), h3.return = a2, a2 = h3);
          }
          return g2(a2);
        case wa:
          a: {
            for (l3 = f3.key; null !== d2; ) {
              if (d2.key === l3)
                if (4 === d2.tag && d2.stateNode.containerInfo === f3.containerInfo && d2.stateNode.implementation === f3.implementation) {
                  c(a2, d2.sibling);
                  d2 = e2(d2, f3.children || []);
                  d2.return = a2;
                  a2 = d2;
                  break a;
                } else {
                  c(a2, d2);
                  break;
                }
              else
                b2(a2, d2);
              d2 = d2.sibling;
            }
            d2 = zh(f3, a2.mode, h3);
            d2.return = a2;
            a2 = d2;
          }
          return g2(a2);
        case Ha:
          return l3 = f3._init, J2(a2, d2, l3(f3._payload), h3);
      }
      if (eb(f3))
        return n2(a2, d2, f3, h3);
      if (Ka(f3))
        return t2(a2, d2, f3, h3);
      th(a2, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d2 && 6 === d2.tag ? (c(a2, d2.sibling), d2 = e2(d2, f3), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = xh(f3, a2.mode, h3), d2.return = a2, a2 = d2), g2(a2)) : c(a2, d2);
  }
  return J2;
}
var Bh = vh(true), Ch = vh(false), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
function Hh(a) {
  if (a === Dh)
    throw Error(p$2(174));
  return a;
}
function Ih(a, b2) {
  G$1(Gh, b2);
  G$1(Fh, a);
  G$1(Eh, Dh);
  a = b2.nodeType;
  switch (a) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
      break;
    default:
      a = 8 === a ? b2.parentNode : b2, b2 = a.namespaceURI || null, a = a.tagName, b2 = lb(b2, a);
  }
  E(Eh);
  G$1(Eh, b2);
}
function Jh() {
  E(Eh);
  E(Fh);
  E(Gh);
}
function Kh(a) {
  Hh(Gh.current);
  var b2 = Hh(Eh.current);
  var c = lb(b2, a.type);
  b2 !== c && (G$1(Fh, a), G$1(Eh, c));
}
function Lh(a) {
  Fh.current === a && (E(Eh), E(Fh));
}
var M$1 = Uf(0);
function Mh(a) {
  for (var b2 = a; null !== b2; ) {
    if (13 === b2.tag) {
      var c = b2.memoizedState;
      if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data))
        return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 128))
        return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a)
      break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a)
        return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var Nh = [];
function Oh() {
  for (var a = 0; a < Nh.length; a++)
    Nh[a]._workInProgressVersionPrimary = null;
  Nh.length = 0;
}
var Ph = ua.ReactCurrentDispatcher, Qh = ua.ReactCurrentBatchConfig, Rh = 0, N = null, O$1 = null, P = null, Sh = false, Th = false, Uh = 0, Vh = 0;
function Q$1() {
  throw Error(p$2(321));
}
function Wh(a, b2) {
  if (null === b2)
    return false;
  for (var c = 0; c < b2.length && c < a.length; c++)
    if (!He$1(a[c], b2[c]))
      return false;
  return true;
}
function Xh(a, b2, c, d, e2, f2) {
  Rh = f2;
  N = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Ph.current = null === a || null === a.memoizedState ? Yh : Zh;
  a = c(d, e2);
  if (Th) {
    f2 = 0;
    do {
      Th = false;
      Uh = 0;
      if (25 <= f2)
        throw Error(p$2(301));
      f2 += 1;
      P = O$1 = null;
      b2.updateQueue = null;
      Ph.current = $h;
      a = c(d, e2);
    } while (Th);
  }
  Ph.current = ai;
  b2 = null !== O$1 && null !== O$1.next;
  Rh = 0;
  P = O$1 = N = null;
  Sh = false;
  if (b2)
    throw Error(p$2(300));
  return a;
}
function bi() {
  var a = 0 !== Uh;
  Uh = 0;
  return a;
}
function ci() {
  var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === P ? N.memoizedState = P = a : P = P.next = a;
  return P;
}
function di() {
  if (null === O$1) {
    var a = N.alternate;
    a = null !== a ? a.memoizedState : null;
  } else
    a = O$1.next;
  var b2 = null === P ? N.memoizedState : P.next;
  if (null !== b2)
    P = b2, O$1 = a;
  else {
    if (null === a)
      throw Error(p$2(310));
    O$1 = a;
    a = { memoizedState: O$1.memoizedState, baseState: O$1.baseState, baseQueue: O$1.baseQueue, queue: O$1.queue, next: null };
    null === P ? N.memoizedState = P = a : P = P.next = a;
  }
  return P;
}
function ei(a, b2) {
  return "function" === typeof b2 ? b2(a) : b2;
}
function fi(a) {
  var b2 = di(), c = b2.queue;
  if (null === c)
    throw Error(p$2(311));
  c.lastRenderedReducer = a;
  var d = O$1, e2 = d.baseQueue, f2 = c.pending;
  if (null !== f2) {
    if (null !== e2) {
      var g2 = e2.next;
      e2.next = f2.next;
      f2.next = g2;
    }
    d.baseQueue = e2 = f2;
    c.pending = null;
  }
  if (null !== e2) {
    f2 = e2.next;
    d = d.baseState;
    var h2 = g2 = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Rh & m2) === m2)
        null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d = l2.hasEagerState ? l2.eagerState : a(d, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k2 ? (h2 = k2 = q2, g2 = d) : k2 = k2.next = q2;
        N.lanes |= m2;
        hh |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k2 ? g2 = d : k2.next = h2;
    He$1(d, b2.memoizedState) || (Ug = true);
    b2.memoizedState = d;
    b2.baseState = g2;
    b2.baseQueue = k2;
    c.lastRenderedState = d;
  }
  a = c.interleaved;
  if (null !== a) {
    e2 = a;
    do
      f2 = e2.lane, N.lanes |= f2, hh |= f2, e2 = e2.next;
    while (e2 !== a);
  } else
    null === e2 && (c.lanes = 0);
  return [b2.memoizedState, c.dispatch];
}
function gi(a) {
  var b2 = di(), c = b2.queue;
  if (null === c)
    throw Error(p$2(311));
  c.lastRenderedReducer = a;
  var d = c.dispatch, e2 = c.pending, f2 = b2.memoizedState;
  if (null !== e2) {
    c.pending = null;
    var g2 = e2 = e2.next;
    do
      f2 = a(f2, g2.action), g2 = g2.next;
    while (g2 !== e2);
    He$1(f2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = f2;
    null === b2.baseQueue && (b2.baseState = f2);
    c.lastRenderedState = f2;
  }
  return [f2, d];
}
function hi() {
}
function ii(a, b2) {
  var c = N, d = di(), e2 = b2(), f2 = !He$1(d.memoizedState, e2);
  f2 && (d.memoizedState = e2, Ug = true);
  d = d.queue;
  ji(ki.bind(null, c, d, a), [a]);
  if (d.getSnapshot !== b2 || f2 || null !== P && P.memoizedState.tag & 1) {
    c.flags |= 2048;
    li(9, mi.bind(null, c, d, e2, b2), void 0, null);
    if (null === R$1)
      throw Error(p$2(349));
    0 !== (Rh & 30) || ni(c, b2, e2);
  }
  return e2;
}
function ni(a, b2, c) {
  a.flags |= 16384;
  a = { getSnapshot: b2, value: c };
  b2 = N.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N.updateQueue = b2, b2.stores = [a]) : (c = b2.stores, null === c ? b2.stores = [a] : c.push(a));
}
function mi(a, b2, c, d) {
  b2.value = c;
  b2.getSnapshot = d;
  oi(b2) && pi(a);
}
function ki(a, b2, c) {
  return c(function() {
    oi(b2) && pi(a);
  });
}
function oi(a) {
  var b2 = a.getSnapshot;
  a = a.value;
  try {
    var c = b2();
    return !He$1(a, c);
  } catch (d) {
    return true;
  }
}
function pi(a) {
  var b2 = Zg(a, 1);
  null !== b2 && mh(b2, a, 1, -1);
}
function qi(a) {
  var b2 = ci();
  "function" === typeof a && (a = a());
  b2.memoizedState = b2.baseState = a;
  a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a };
  b2.queue = a;
  a = a.dispatch = ri.bind(null, N, a);
  return [b2.memoizedState, a];
}
function li(a, b2, c, d) {
  a = { tag: a, create: b2, destroy: c, deps: d, next: null };
  b2 = N.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N.updateQueue = b2, b2.lastEffect = a.next = a) : (c = b2.lastEffect, null === c ? b2.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b2.lastEffect = a));
  return a;
}
function si() {
  return di().memoizedState;
}
function ti(a, b2, c, d) {
  var e2 = ci();
  N.flags |= a;
  e2.memoizedState = li(1 | b2, c, void 0, void 0 === d ? null : d);
}
function ui(a, b2, c, d) {
  var e2 = di();
  d = void 0 === d ? null : d;
  var f2 = void 0;
  if (null !== O$1) {
    var g2 = O$1.memoizedState;
    f2 = g2.destroy;
    if (null !== d && Wh(d, g2.deps)) {
      e2.memoizedState = li(b2, c, f2, d);
      return;
    }
  }
  N.flags |= a;
  e2.memoizedState = li(1 | b2, c, f2, d);
}
function vi(a, b2) {
  return ti(8390656, 8, a, b2);
}
function ji(a, b2) {
  return ui(2048, 8, a, b2);
}
function wi(a, b2) {
  return ui(4, 2, a, b2);
}
function xi(a, b2) {
  return ui(4, 4, a, b2);
}
function yi(a, b2) {
  if ("function" === typeof b2)
    return a = a(), b2(a), function() {
      b2(null);
    };
  if (null !== b2 && void 0 !== b2)
    return a = a(), b2.current = a, function() {
      b2.current = null;
    };
}
function zi(a, b2, c) {
  c = null !== c && void 0 !== c ? c.concat([a]) : null;
  return ui(4, 4, yi.bind(null, b2, a), c);
}
function Ai() {
}
function Bi(a, b2) {
  var c = di();
  b2 = void 0 === b2 ? null : b2;
  var d = c.memoizedState;
  if (null !== d && null !== b2 && Wh(b2, d[1]))
    return d[0];
  c.memoizedState = [a, b2];
  return a;
}
function Ci(a, b2) {
  var c = di();
  b2 = void 0 === b2 ? null : b2;
  var d = c.memoizedState;
  if (null !== d && null !== b2 && Wh(b2, d[1]))
    return d[0];
  a = a();
  c.memoizedState = [a, b2];
  return a;
}
function Di(a, b2, c) {
  if (0 === (Rh & 21))
    return a.baseState && (a.baseState = false, Ug = true), a.memoizedState = c;
  He$1(c, b2) || (c = yc(), N.lanes |= c, hh |= c, a.baseState = true);
  return b2;
}
function Ei(a, b2) {
  var c = C$1;
  C$1 = 0 !== c && 4 > c ? c : 4;
  a(true);
  var d = Qh.transition;
  Qh.transition = {};
  try {
    a(false), b2();
  } finally {
    C$1 = c, Qh.transition = d;
  }
}
function Fi() {
  return di().memoizedState;
}
function Gi(a, b2, c) {
  var d = lh(a);
  c = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a))
    Ii(b2, c);
  else if (c = Yg(a, b2, c, d), null !== c) {
    var e2 = L$1();
    mh(c, a, d, e2);
    Ji(c, b2, d);
  }
}
function ri(a, b2, c) {
  var d = lh(a), e2 = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a))
    Ii(b2, e2);
  else {
    var f2 = a.alternate;
    if (0 === a.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2))
      try {
        var g2 = b2.lastRenderedState, h2 = f2(g2, c);
        e2.hasEagerState = true;
        e2.eagerState = h2;
        if (He$1(h2, g2)) {
          var k2 = b2.interleaved;
          null === k2 ? (e2.next = e2, Xg(b2)) : (e2.next = k2.next, k2.next = e2);
          b2.interleaved = e2;
          return;
        }
      } catch (l2) {
      } finally {
      }
    c = Yg(a, b2, e2, d);
    null !== c && (e2 = L$1(), mh(c, a, d, e2), Ji(c, b2, d));
  }
}
function Hi(a) {
  var b2 = a.alternate;
  return a === N || null !== b2 && b2 === N;
}
function Ii(a, b2) {
  Th = Sh = true;
  var c = a.pending;
  null === c ? b2.next = b2 : (b2.next = c.next, c.next = b2);
  a.pending = b2;
}
function Ji(a, b2, c) {
  if (0 !== (c & 4194240)) {
    var d = b2.lanes;
    d &= a.pendingLanes;
    c |= d;
    b2.lanes = c;
    Cc(a, c);
  }
}
var ai = { readContext: Vg, useCallback: Q$1, useContext: Q$1, useEffect: Q$1, useImperativeHandle: Q$1, useInsertionEffect: Q$1, useLayoutEffect: Q$1, useMemo: Q$1, useReducer: Q$1, useRef: Q$1, useState: Q$1, useDebugValue: Q$1, useDeferredValue: Q$1, useTransition: Q$1, useMutableSource: Q$1, useSyncExternalStore: Q$1, useId: Q$1, unstable_isNewReconciler: false }, Yh = { readContext: Vg, useCallback: function(a, b2) {
  ci().memoizedState = [a, void 0 === b2 ? null : b2];
  return a;
}, useContext: Vg, useEffect: vi, useImperativeHandle: function(a, b2, c) {
  c = null !== c && void 0 !== c ? c.concat([a]) : null;
  return ti(
    4194308,
    4,
    yi.bind(null, b2, a),
    c
  );
}, useLayoutEffect: function(a, b2) {
  return ti(4194308, 4, a, b2);
}, useInsertionEffect: function(a, b2) {
  return ti(4, 2, a, b2);
}, useMemo: function(a, b2) {
  var c = ci();
  b2 = void 0 === b2 ? null : b2;
  a = a();
  c.memoizedState = [a, b2];
  return a;
}, useReducer: function(a, b2, c) {
  var d = ci();
  b2 = void 0 !== c ? c(b2) : b2;
  d.memoizedState = d.baseState = b2;
  a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b2 };
  d.queue = a;
  a = a.dispatch = Gi.bind(null, N, a);
  return [d.memoizedState, a];
}, useRef: function(a) {
  var b2 = ci();
  a = { current: a };
  return b2.memoizedState = a;
}, useState: qi, useDebugValue: Ai, useDeferredValue: function(a) {
  return ci().memoizedState = a;
}, useTransition: function() {
  var a = qi(false), b2 = a[0];
  a = Ei.bind(null, a[1]);
  ci().memoizedState = a;
  return [b2, a];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a, b2, c) {
  var d = N, e2 = ci();
  if (I$1) {
    if (void 0 === c)
      throw Error(p$2(407));
    c = c();
  } else {
    c = b2();
    if (null === R$1)
      throw Error(p$2(349));
    0 !== (Rh & 30) || ni(d, b2, c);
  }
  e2.memoizedState = c;
  var f2 = { value: c, getSnapshot: b2 };
  e2.queue = f2;
  vi(ki.bind(
    null,
    d,
    f2,
    a
  ), [a]);
  d.flags |= 2048;
  li(9, mi.bind(null, d, f2, c, b2), void 0, null);
  return c;
}, useId: function() {
  var a = ci(), b2 = R$1.identifierPrefix;
  if (I$1) {
    var c = sg;
    var d = rg;
    c = (d & ~(1 << 32 - oc(d) - 1)).toString(32) + c;
    b2 = ":" + b2 + "R" + c;
    c = Uh++;
    0 < c && (b2 += "H" + c.toString(32));
    b2 += ":";
  } else
    c = Vh++, b2 = ":" + b2 + "r" + c.toString(32) + ":";
  return a.memoizedState = b2;
}, unstable_isNewReconciler: false }, Zh = {
  readContext: Vg,
  useCallback: Bi,
  useContext: Vg,
  useEffect: ji,
  useImperativeHandle: zi,
  useInsertionEffect: wi,
  useLayoutEffect: xi,
  useMemo: Ci,
  useReducer: fi,
  useRef: si,
  useState: function() {
    return fi(ei);
  },
  useDebugValue: Ai,
  useDeferredValue: function(a) {
    var b2 = di();
    return Di(b2, O$1.memoizedState, a);
  },
  useTransition: function() {
    var a = fi(ei)[0], b2 = di().memoizedState;
    return [a, b2];
  },
  useMutableSource: hi,
  useSyncExternalStore: ii,
  useId: Fi,
  unstable_isNewReconciler: false
}, $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function() {
  return gi(ei);
}, useDebugValue: Ai, useDeferredValue: function(a) {
  var b2 = di();
  return null === O$1 ? b2.memoizedState = a : Di(b2, O$1.memoizedState, a);
}, useTransition: function() {
  var a = gi(ei)[0], b2 = di().memoizedState;
  return [a, b2];
}, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false };
function Ki(a, b2) {
  try {
    var c = "", d = b2;
    do
      c += Pa(d), d = d.return;
    while (d);
    var e2 = c;
  } catch (f2) {
    e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a, source: b2, stack: e2, digest: null };
}
function Li(a, b2, c) {
  return { value: a, source: null, stack: null != c ? c : null, digest: null != b2 ? b2 : null };
}
function Mi(a, b2) {
  try {
    console.error(b2.value);
  } catch (c) {
    setTimeout(function() {
      throw c;
    });
  }
}
var Ni = "function" === typeof WeakMap ? WeakMap : Map;
function Oi(a, b2, c) {
  c = ch(-1, c);
  c.tag = 3;
  c.payload = { element: null };
  var d = b2.value;
  c.callback = function() {
    Pi || (Pi = true, Qi = d);
    Mi(a, b2);
  };
  return c;
}
function Ri(a, b2, c) {
  c = ch(-1, c);
  c.tag = 3;
  var d = a.type.getDerivedStateFromError;
  if ("function" === typeof d) {
    var e2 = b2.value;
    c.payload = function() {
      return d(e2);
    };
    c.callback = function() {
      Mi(a, b2);
    };
  }
  var f2 = a.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c.callback = function() {
    Mi(a, b2);
    "function" !== typeof d && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
    var c2 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c2 ? c2 : "" });
  });
  return c;
}
function Ti(a, b2, c) {
  var d = a.pingCache;
  if (null === d) {
    d = a.pingCache = new Ni();
    var e2 = /* @__PURE__ */ new Set();
    d.set(b2, e2);
  } else
    e2 = d.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d.set(b2, e2));
  e2.has(c) || (e2.add(c), a = Ui.bind(null, a, b2, c), b2.then(a, a));
}
function Vi(a) {
  do {
    var b2;
    if (b2 = 13 === a.tag)
      b2 = a.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
    if (b2)
      return a;
    a = a.return;
  } while (null !== a);
  return null;
}
function Wi(a, b2, c, d, e2) {
  if (0 === (a.mode & 1))
    return a === b2 ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b2 = ch(-1, 1), b2.tag = 2, dh(c, b2, 1))), c.lanes |= 1), a;
  a.flags |= 65536;
  a.lanes = e2;
  return a;
}
var Xi = ua.ReactCurrentOwner, Ug = false;
function Yi(a, b2, c, d) {
  b2.child = null === a ? Ch(b2, null, c, d) : Bh(b2, a.child, c, d);
}
function Zi(a, b2, c, d, e2) {
  c = c.render;
  var f2 = b2.ref;
  Tg(b2, e2);
  d = Xh(a, b2, c, d, f2, e2);
  c = bi();
  if (null !== a && !Ug)
    return b2.updateQueue = a.updateQueue, b2.flags &= -2053, a.lanes &= ~e2, $i(a, b2, e2);
  I$1 && c && vg(b2);
  b2.flags |= 1;
  Yi(a, b2, d, e2);
  return b2.child;
}
function aj(a, b2, c, d, e2) {
  if (null === a) {
    var f2 = c.type;
    if ("function" === typeof f2 && !bj(f2) && void 0 === f2.defaultProps && null === c.compare && void 0 === c.defaultProps)
      return b2.tag = 15, b2.type = f2, cj(a, b2, f2, d, e2);
    a = yh(c.type, null, d, b2, b2.mode, e2);
    a.ref = b2.ref;
    a.return = b2;
    return b2.child = a;
  }
  f2 = a.child;
  if (0 === (a.lanes & e2)) {
    var g2 = f2.memoizedProps;
    c = c.compare;
    c = null !== c ? c : Ie$1;
    if (c(g2, d) && a.ref === b2.ref)
      return $i(a, b2, e2);
  }
  b2.flags |= 1;
  a = wh(f2, d);
  a.ref = b2.ref;
  a.return = b2;
  return b2.child = a;
}
function cj(a, b2, c, d, e2) {
  if (null !== a) {
    var f2 = a.memoizedProps;
    if (Ie$1(f2, d) && a.ref === b2.ref)
      if (Ug = false, b2.pendingProps = d = f2, 0 !== (a.lanes & e2))
        0 !== (a.flags & 131072) && (Ug = true);
      else
        return b2.lanes = a.lanes, $i(a, b2, e2);
  }
  return dj(a, b2, c, d, e2);
}
function ej(a, b2, c) {
  var d = b2.pendingProps, e2 = d.children, f2 = null !== a ? a.memoizedState : null;
  if ("hidden" === d.mode)
    if (0 === (b2.mode & 1))
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G$1(fj, gj), gj |= c;
    else {
      if (0 === (c & 1073741824))
        return a = null !== f2 ? f2.baseLanes | c : c, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b2.updateQueue = null, G$1(fj, gj), gj |= a, null;
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d = null !== f2 ? f2.baseLanes : c;
      G$1(fj, gj);
      gj |= d;
    }
  else
    null !== f2 ? (d = f2.baseLanes | c, b2.memoizedState = null) : d = c, G$1(fj, gj), gj |= d;
  Yi(a, b2, e2, c);
  return b2.child;
}
function hj(a, b2) {
  var c = b2.ref;
  if (null === a && null !== c || null !== a && a.ref !== c)
    b2.flags |= 512, b2.flags |= 2097152;
}
function dj(a, b2, c, d, e2) {
  var f2 = Zf(c) ? Xf : H$2.current;
  f2 = Yf(b2, f2);
  Tg(b2, e2);
  c = Xh(a, b2, c, d, f2, e2);
  d = bi();
  if (null !== a && !Ug)
    return b2.updateQueue = a.updateQueue, b2.flags &= -2053, a.lanes &= ~e2, $i(a, b2, e2);
  I$1 && d && vg(b2);
  b2.flags |= 1;
  Yi(a, b2, c, e2);
  return b2.child;
}
function ij(a, b2, c, d, e2) {
  if (Zf(c)) {
    var f2 = true;
    cg(b2);
  } else
    f2 = false;
  Tg(b2, e2);
  if (null === b2.stateNode)
    jj(a, b2), ph(b2, c, d), rh(b2, c, d, e2), d = true;
  else if (null === a) {
    var g2 = b2.stateNode, h2 = b2.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = Vg(l2) : (l2 = Zf(c) ? Xf : H$2.current, l2 = Yf(b2, l2));
    var m2 = c.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d || k2 !== l2) && qh(b2, g2, d, l2);
    $g = false;
    var r2 = b2.memoizedState;
    g2.state = r2;
    gh(b2, d, g2, e2);
    k2 = b2.memoizedState;
    h2 !== d || r2 !== k2 || Wf.current || $g ? ("function" === typeof m2 && (kh(b2, c, m2, d), k2 = b2.memoizedState), (h2 = $g || oh(b2, c, h2, d, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d, b2.memoizedState = k2), g2.props = d, g2.state = k2, g2.context = l2, d = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d = false);
  } else {
    g2 = b2.stateNode;
    bh(a, b2);
    h2 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h2 : Lg(b2.type, h2);
    g2.props = l2;
    q2 = b2.pendingProps;
    r2 = g2.context;
    k2 = c.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = Vg(k2) : (k2 = Zf(c) ? Xf : H$2.current, k2 = Yf(b2, k2));
    var y2 = c.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && qh(b2, g2, d, k2);
    $g = false;
    r2 = b2.memoizedState;
    g2.state = r2;
    gh(b2, d, g2, e2);
    var n2 = b2.memoizedState;
    h2 !== q2 || r2 !== n2 || Wf.current || $g ? ("function" === typeof y2 && (kh(b2, c, y2, d), n2 = b2.memoizedState), (l2 = $g || oh(b2, c, l2, d, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d, b2.memoizedState = n2), g2.props = d, g2.state = n2, g2.context = k2, d = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b2.flags |= 1024), d = false);
  }
  return kj(a, b2, c, d, f2, e2);
}
function kj(a, b2, c, d, e2, f2) {
  hj(a, b2);
  var g2 = 0 !== (b2.flags & 128);
  if (!d && !g2)
    return e2 && dg(b2, c, false), $i(a, b2, f2);
  d = b2.stateNode;
  Xi.current = b2;
  var h2 = g2 && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
  b2.flags |= 1;
  null !== a && g2 ? (b2.child = Bh(b2, a.child, null, f2), b2.child = Bh(b2, null, h2, f2)) : Yi(a, b2, h2, f2);
  b2.memoizedState = d.state;
  e2 && dg(b2, c, true);
  return b2.child;
}
function lj(a) {
  var b2 = a.stateNode;
  b2.pendingContext ? ag(a, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a, b2.context, false);
  Ih(a, b2.containerInfo);
}
function mj(a, b2, c, d, e2) {
  Ig();
  Jg(e2);
  b2.flags |= 256;
  Yi(a, b2, c, d);
  return b2.child;
}
var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
function oj(a) {
  return { baseLanes: a, cachePool: null, transitions: null };
}
function pj(a, b2, c) {
  var d = b2.pendingProps, e2 = M$1.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
  (h2 = g2) || (h2 = null !== a && null === a.memoizedState ? false : 0 !== (e2 & 2));
  if (h2)
    f2 = true, b2.flags &= -129;
  else if (null === a || null !== a.memoizedState)
    e2 |= 1;
  G$1(M$1, e2 & 1);
  if (null === a) {
    Eg(b2);
    a = b2.memoizedState;
    if (null !== a && (a = a.dehydrated, null !== a))
      return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    g2 = d.children;
    a = d.fallback;
    return f2 ? (d = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = qj(g2, d, 0, null), a = Ah(a, d, c, null), f2.return = b2, a.return = b2, f2.sibling = a, b2.child = f2, b2.child.memoizedState = oj(c), b2.memoizedState = nj, a) : rj(b2, g2);
  }
  e2 = a.memoizedState;
  if (null !== e2 && (h2 = e2.dehydrated, null !== h2))
    return sj(a, b2, g2, d, h2, e2, c);
  if (f2) {
    f2 = d.fallback;
    g2 = b2.mode;
    e2 = a.child;
    h2 = e2.sibling;
    var k2 = { mode: "hidden", children: d.children };
    0 === (g2 & 1) && b2.child !== e2 ? (d = b2.child, d.childLanes = 0, d.pendingProps = k2, b2.deletions = null) : (d = wh(e2, k2), d.subtreeFlags = e2.subtreeFlags & 14680064);
    null !== h2 ? f2 = wh(h2, f2) : (f2 = Ah(f2, g2, c, null), f2.flags |= 2);
    f2.return = b2;
    d.return = b2;
    d.sibling = f2;
    b2.child = d;
    d = f2;
    f2 = b2.child;
    g2 = a.child.memoizedState;
    g2 = null === g2 ? oj(c) : { baseLanes: g2.baseLanes | c, cachePool: null, transitions: g2.transitions };
    f2.memoizedState = g2;
    f2.childLanes = a.childLanes & ~c;
    b2.memoizedState = nj;
    return d;
  }
  f2 = a.child;
  a = f2.sibling;
  d = wh(f2, { mode: "visible", children: d.children });
  0 === (b2.mode & 1) && (d.lanes = c);
  d.return = b2;
  d.sibling = null;
  null !== a && (c = b2.deletions, null === c ? (b2.deletions = [a], b2.flags |= 16) : c.push(a));
  b2.child = d;
  b2.memoizedState = null;
  return d;
}
function rj(a, b2) {
  b2 = qj({ mode: "visible", children: b2 }, a.mode, 0, null);
  b2.return = a;
  return a.child = b2;
}
function tj(a, b2, c, d) {
  null !== d && Jg(d);
  Bh(b2, a.child, null, c);
  a = rj(b2, b2.pendingProps.children);
  a.flags |= 2;
  b2.memoizedState = null;
  return a;
}
function sj(a, b2, c, d, e2, f2, g2) {
  if (c) {
    if (b2.flags & 256)
      return b2.flags &= -257, d = Li(Error(p$2(422))), tj(a, b2, g2, d);
    if (null !== b2.memoizedState)
      return b2.child = a.child, b2.flags |= 128, null;
    f2 = d.fallback;
    e2 = b2.mode;
    d = qj({ mode: "visible", children: d.children }, e2, 0, null);
    f2 = Ah(f2, e2, g2, null);
    f2.flags |= 2;
    d.return = b2;
    f2.return = b2;
    d.sibling = f2;
    b2.child = d;
    0 !== (b2.mode & 1) && Bh(b2, a.child, null, g2);
    b2.child.memoizedState = oj(g2);
    b2.memoizedState = nj;
    return f2;
  }
  if (0 === (b2.mode & 1))
    return tj(a, b2, g2, null);
  if ("$!" === e2.data) {
    d = e2.nextSibling && e2.nextSibling.dataset;
    if (d)
      var h2 = d.dgst;
    d = h2;
    f2 = Error(p$2(419));
    d = Li(f2, d, void 0);
    return tj(a, b2, g2, d);
  }
  h2 = 0 !== (g2 & a.childLanes);
  if (Ug || h2) {
    d = R$1;
    if (null !== d) {
      switch (g2 & -g2) {
        case 4:
          e2 = 2;
          break;
        case 16:
          e2 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e2 = 32;
          break;
        case 536870912:
          e2 = 268435456;
          break;
        default:
          e2 = 0;
      }
      e2 = 0 !== (e2 & (d.suspendedLanes | g2)) ? 0 : e2;
      0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, Zg(a, e2), mh(d, a, e2, -1));
    }
    uj();
    d = Li(Error(p$2(421)));
    return tj(a, b2, g2, d);
  }
  if ("$?" === e2.data)
    return b2.flags |= 128, b2.child = a.child, b2 = vj.bind(null, a), e2._reactRetry = b2, null;
  a = f2.treeContext;
  yg = Lf(e2.nextSibling);
  xg = b2;
  I$1 = true;
  zg = null;
  null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b2);
  b2 = rj(b2, d.children);
  b2.flags |= 4096;
  return b2;
}
function wj(a, b2, c) {
  a.lanes |= b2;
  var d = a.alternate;
  null !== d && (d.lanes |= b2);
  Sg(a.return, b2, c);
}
function xj(a, b2, c, d, e2) {
  var f2 = a.memoizedState;
  null === f2 ? a.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d, f2.tail = c, f2.tailMode = e2);
}
function yj(a, b2, c) {
  var d = b2.pendingProps, e2 = d.revealOrder, f2 = d.tail;
  Yi(a, b2, d.children, c);
  d = M$1.current;
  if (0 !== (d & 2))
    d = d & 1 | 2, b2.flags |= 128;
  else {
    if (null !== a && 0 !== (a.flags & 128))
      a:
        for (a = b2.child; null !== a; ) {
          if (13 === a.tag)
            null !== a.memoizedState && wj(a, c, b2);
          else if (19 === a.tag)
            wj(a, c, b2);
          else if (null !== a.child) {
            a.child.return = a;
            a = a.child;
            continue;
          }
          if (a === b2)
            break a;
          for (; null === a.sibling; ) {
            if (null === a.return || a.return === b2)
              break a;
            a = a.return;
          }
          a.sibling.return = a.return;
          a = a.sibling;
        }
    d &= 1;
  }
  G$1(M$1, d);
  if (0 === (b2.mode & 1))
    b2.memoizedState = null;
  else
    switch (e2) {
      case "forwards":
        c = b2.child;
        for (e2 = null; null !== c; )
          a = c.alternate, null !== a && null === Mh(a) && (e2 = c), c = c.sibling;
        c = e2;
        null === c ? (e2 = b2.child, b2.child = null) : (e2 = c.sibling, c.sibling = null);
        xj(b2, false, e2, c, f2);
        break;
      case "backwards":
        c = null;
        e2 = b2.child;
        for (b2.child = null; null !== e2; ) {
          a = e2.alternate;
          if (null !== a && null === Mh(a)) {
            b2.child = e2;
            break;
          }
          a = e2.sibling;
          e2.sibling = c;
          c = e2;
          e2 = a;
        }
        xj(b2, true, c, null, f2);
        break;
      case "together":
        xj(b2, false, null, null, void 0);
        break;
      default:
        b2.memoizedState = null;
    }
  return b2.child;
}
function jj(a, b2) {
  0 === (b2.mode & 1) && null !== a && (a.alternate = null, b2.alternate = null, b2.flags |= 2);
}
function $i(a, b2, c) {
  null !== a && (b2.dependencies = a.dependencies);
  hh |= b2.lanes;
  if (0 === (c & b2.childLanes))
    return null;
  if (null !== a && b2.child !== a.child)
    throw Error(p$2(153));
  if (null !== b2.child) {
    a = b2.child;
    c = wh(a, a.pendingProps);
    b2.child = c;
    for (c.return = b2; null !== a.sibling; )
      a = a.sibling, c = c.sibling = wh(a, a.pendingProps), c.return = b2;
    c.sibling = null;
  }
  return b2.child;
}
function zj(a, b2, c) {
  switch (b2.tag) {
    case 3:
      lj(b2);
      Ig();
      break;
    case 5:
      Kh(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      Ih(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d = b2.type._context, e2 = b2.memoizedProps.value;
      G$1(Mg, d._currentValue);
      d._currentValue = e2;
      break;
    case 13:
      d = b2.memoizedState;
      if (null !== d) {
        if (null !== d.dehydrated)
          return G$1(M$1, M$1.current & 1), b2.flags |= 128, null;
        if (0 !== (c & b2.child.childLanes))
          return pj(a, b2, c);
        G$1(M$1, M$1.current & 1);
        a = $i(a, b2, c);
        return null !== a ? a.sibling : null;
      }
      G$1(M$1, M$1.current & 1);
      break;
    case 19:
      d = 0 !== (c & b2.childLanes);
      if (0 !== (a.flags & 128)) {
        if (d)
          return yj(a, b2, c);
        b2.flags |= 128;
      }
      e2 = b2.memoizedState;
      null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
      G$1(M$1, M$1.current);
      if (d)
        break;
      else
        return null;
    case 22:
    case 23:
      return b2.lanes = 0, ej(a, b2, c);
  }
  return $i(a, b2, c);
}
var Aj, Bj, Cj, Dj;
Aj = function(a, b2) {
  for (var c = b2.child; null !== c; ) {
    if (5 === c.tag || 6 === c.tag)
      a.appendChild(c.stateNode);
    else if (4 !== c.tag && null !== c.child) {
      c.child.return = c;
      c = c.child;
      continue;
    }
    if (c === b2)
      break;
    for (; null === c.sibling; ) {
      if (null === c.return || c.return === b2)
        return;
      c = c.return;
    }
    c.sibling.return = c.return;
    c = c.sibling;
  }
};
Bj = function() {
};
Cj = function(a, b2, c, d) {
  var e2 = a.memoizedProps;
  if (e2 !== d) {
    a = b2.stateNode;
    Hh(Eh.current);
    var f2 = null;
    switch (c) {
      case "input":
        e2 = Ya(a, e2);
        d = Ya(a, d);
        f2 = [];
        break;
      case "select":
        e2 = A$1({}, e2, { value: void 0 });
        d = A$1({}, d, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e2 = gb(a, e2);
        d = gb(a, d);
        f2 = [];
        break;
      default:
        "function" !== typeof e2.onClick && "function" === typeof d.onClick && (a.onclick = Bf);
    }
    ub(c, d);
    var g2;
    c = null;
    for (l2 in e2)
      if (!d.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
        if ("style" === l2) {
          var h2 = e2[l2];
          for (g2 in h2)
            h2.hasOwnProperty(g2) && (c || (c = {}), c[g2] = "");
        } else
          "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d) {
      var k2 = d[l2];
      h2 = null != e2 ? e2[l2] : void 0;
      if (d.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
        if ("style" === l2)
          if (h2) {
            for (g2 in h2)
              !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c || (c = {}), c[g2] = "");
            for (g2 in k2)
              k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c || (c = {}), c[g2] = k2[g2]);
          } else
            c || (f2 || (f2 = []), f2.push(
              l2,
              c
            )), c = k2;
        else
          "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D$1("scroll", a), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c && (f2 = f2 || []).push("style", c);
    var l2 = f2;
    if (b2.updateQueue = l2)
      b2.flags |= 4;
  }
};
Dj = function(a, b2, c, d) {
  c !== d && (b2.flags |= 4);
};
function Ej(a, b2) {
  if (!I$1)
    switch (a.tailMode) {
      case "hidden":
        b2 = a.tail;
        for (var c = null; null !== b2; )
          null !== b2.alternate && (c = b2), b2 = b2.sibling;
        null === c ? a.tail = null : c.sibling = null;
        break;
      case "collapsed":
        c = a.tail;
        for (var d = null; null !== c; )
          null !== c.alternate && (d = c), c = c.sibling;
        null === d ? b2 || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
    }
}
function S$1(a) {
  var b2 = null !== a.alternate && a.alternate.child === a.child, c = 0, d = 0;
  if (b2)
    for (var e2 = a.child; null !== e2; )
      c |= e2.lanes | e2.childLanes, d |= e2.subtreeFlags & 14680064, d |= e2.flags & 14680064, e2.return = a, e2 = e2.sibling;
  else
    for (e2 = a.child; null !== e2; )
      c |= e2.lanes | e2.childLanes, d |= e2.subtreeFlags, d |= e2.flags, e2.return = a, e2 = e2.sibling;
  a.subtreeFlags |= d;
  a.childLanes = c;
  return b2;
}
function Fj(a, b2, c) {
  var d = b2.pendingProps;
  wg(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S$1(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S$1(b2), null;
    case 3:
      d = b2.stateNode;
      Jh();
      E(Wf);
      E(H$2);
      Oh();
      d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
      if (null === a || null === a.child)
        Gg(b2) ? b2.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Gj(zg), zg = null));
      Bj(a, b2);
      S$1(b2);
      return null;
    case 5:
      Lh(b2);
      var e2 = Hh(Gh.current);
      c = b2.type;
      if (null !== a && null != b2.stateNode)
        Cj(a, b2, c, d, e2), a.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d) {
          if (null === b2.stateNode)
            throw Error(p$2(166));
          S$1(b2);
          return null;
        }
        a = Hh(Eh.current);
        if (Gg(b2)) {
          d = b2.stateNode;
          c = b2.type;
          var f2 = b2.memoizedProps;
          d[Of] = b2;
          d[Pf] = f2;
          a = 0 !== (b2.mode & 1);
          switch (c) {
            case "dialog":
              D$1("cancel", d);
              D$1("close", d);
              break;
            case "iframe":
            case "object":
            case "embed":
              D$1("load", d);
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < lf.length; e2++)
                D$1(lf[e2], d);
              break;
            case "source":
              D$1("error", d);
              break;
            case "img":
            case "image":
            case "link":
              D$1(
                "error",
                d
              );
              D$1("load", d);
              break;
            case "details":
              D$1("toggle", d);
              break;
            case "input":
              Za(d, f2);
              D$1("invalid", d);
              break;
            case "select":
              d._wrapperState = { wasMultiple: !!f2.multiple };
              D$1("invalid", d);
              break;
            case "textarea":
              hb(d, f2), D$1("invalid", d);
          }
          ub(c, f2);
          e2 = null;
          for (var g2 in f2)
            if (f2.hasOwnProperty(g2)) {
              var h2 = f2[g2];
              "children" === g2 ? "string" === typeof h2 ? d.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d.textContent, h2, a), e2 = ["children", h2]) : "number" === typeof h2 && d.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                d.textContent,
                h2,
                a
              ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D$1("scroll", d);
            }
          switch (c) {
            case "input":
              Va(d);
              db(d, f2, true);
              break;
            case "textarea":
              Va(d);
              jb(d);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d.onclick = Bf);
          }
          d = e2;
          b2.updateQueue = d;
          null !== d && (b2.flags |= 4);
        } else {
          g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a && (a = kb(c));
          "http://www.w3.org/1999/xhtml" === a ? "script" === c ? (a = g2.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g2.createElement(c, { is: d.is }) : (a = g2.createElement(c), "select" === c && (g2 = a, d.multiple ? g2.multiple = true : d.size && (g2.size = d.size))) : a = g2.createElementNS(a, c);
          a[Of] = b2;
          a[Pf] = d;
          Aj(a, b2, false, false);
          b2.stateNode = a;
          a: {
            g2 = vb(c, d);
            switch (c) {
              case "dialog":
                D$1("cancel", a);
                D$1("close", a);
                e2 = d;
                break;
              case "iframe":
              case "object":
              case "embed":
                D$1("load", a);
                e2 = d;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++)
                  D$1(lf[e2], a);
                e2 = d;
                break;
              case "source":
                D$1("error", a);
                e2 = d;
                break;
              case "img":
              case "image":
              case "link":
                D$1(
                  "error",
                  a
                );
                D$1("load", a);
                e2 = d;
                break;
              case "details":
                D$1("toggle", a);
                e2 = d;
                break;
              case "input":
                Za(a, d);
                e2 = Ya(a, d);
                D$1("invalid", a);
                break;
              case "option":
                e2 = d;
                break;
              case "select":
                a._wrapperState = { wasMultiple: !!d.multiple };
                e2 = A$1({}, d, { value: void 0 });
                D$1("invalid", a);
                break;
              case "textarea":
                hb(a, d);
                e2 = gb(a, d);
                D$1("invalid", a);
                break;
              default:
                e2 = d;
            }
            ub(c, e2);
            h2 = e2;
            for (f2 in h2)
              if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                "style" === f2 ? sb(a, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c || "" !== k2) && ob(a, k2) : "number" === typeof k2 && ob(a, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D$1("scroll", a) : null != k2 && ta(a, f2, k2, g2));
              }
            switch (c) {
              case "input":
                Va(a);
                db(a, d, false);
                break;
              case "textarea":
                Va(a);
                jb(a);
                break;
              case "option":
                null != d.value && a.setAttribute("value", "" + Sa(d.value));
                break;
              case "select":
                a.multiple = !!d.multiple;
                f2 = d.value;
                null != f2 ? fb(a, !!d.multiple, f2, false) : null != d.defaultValue && fb(
                  a,
                  !!d.multiple,
                  d.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e2.onClick && (a.onclick = Bf);
            }
            switch (c) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d = !!d.autoFocus;
                break a;
              case "img":
                d = true;
                break a;
              default:
                d = false;
            }
          }
          d && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      }
      S$1(b2);
      return null;
    case 6:
      if (a && null != b2.stateNode)
        Dj(a, b2, a.memoizedProps, d);
      else {
        if ("string" !== typeof d && null === b2.stateNode)
          throw Error(p$2(166));
        c = Hh(Gh.current);
        Hh(Eh.current);
        if (Gg(b2)) {
          d = b2.stateNode;
          c = b2.memoizedProps;
          d[Of] = b2;
          if (f2 = d.nodeValue !== c) {
            if (a = xg, null !== a)
              switch (a.tag) {
                case 3:
                  Af(d.nodeValue, c, 0 !== (a.mode & 1));
                  break;
                case 5:
                  true !== a.memoizedProps.suppressHydrationWarning && Af(d.nodeValue, c, 0 !== (a.mode & 1));
              }
          }
          f2 && (b2.flags |= 4);
        } else
          d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[Of] = b2, b2.stateNode = d;
      }
      S$1(b2);
      return null;
    case 13:
      E(M$1);
      d = b2.memoizedState;
      if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
        if (I$1 && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128))
          Hg(), Ig(), b2.flags |= 98560, f2 = false;
        else if (f2 = Gg(b2), null !== d && null !== d.dehydrated) {
          if (null === a) {
            if (!f2)
              throw Error(p$2(318));
            f2 = b2.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2)
              throw Error(p$2(317));
            f2[Of] = b2;
          } else
            Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S$1(b2);
          f2 = false;
        } else
          null !== zg && (Gj(zg), zg = null), f2 = true;
        if (!f2)
          return b2.flags & 65536 ? b2 : null;
      }
      if (0 !== (b2.flags & 128))
        return b2.lanes = c, b2;
      d = null !== d;
      d !== (null !== a && null !== a.memoizedState) && d && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a || 0 !== (M$1.current & 1) ? 0 === T$1 && (T$1 = 3) : uj()));
      null !== b2.updateQueue && (b2.flags |= 4);
      S$1(b2);
      return null;
    case 4:
      return Jh(), Bj(a, b2), null === a && sf(b2.stateNode.containerInfo), S$1(b2), null;
    case 10:
      return Rg(b2.type._context), S$1(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S$1(b2), null;
    case 19:
      E(M$1);
      f2 = b2.memoizedState;
      if (null === f2)
        return S$1(b2), null;
      d = 0 !== (b2.flags & 128);
      g2 = f2.rendering;
      if (null === g2)
        if (d)
          Ej(f2, false);
        else {
          if (0 !== T$1 || null !== a && 0 !== (a.flags & 128))
            for (a = b2.child; null !== a; ) {
              g2 = Mh(a);
              if (null !== g2) {
                b2.flags |= 128;
                Ej(f2, false);
                d = g2.updateQueue;
                null !== d && (b2.updateQueue = d, b2.flags |= 4);
                b2.subtreeFlags = 0;
                d = c;
                for (c = b2.child; null !== c; )
                  f2 = c, a = d, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a = g2.dependencies, f2.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
                G$1(M$1, M$1.current & 1 | 2);
                return b2.child;
              }
              a = a.sibling;
            }
          null !== f2.tail && B$1() > Hj && (b2.flags |= 128, d = true, Ej(f2, false), b2.lanes = 4194304);
        }
      else {
        if (!d)
          if (a = Mh(g2), null !== a) {
            if (b2.flags |= 128, d = true, c = a.updateQueue, null !== c && (b2.updateQueue = c, b2.flags |= 4), Ej(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I$1)
              return S$1(b2), null;
          } else
            2 * B$1() - f2.renderingStartTime > Hj && 1073741824 !== c && (b2.flags |= 128, d = true, Ej(f2, false), b2.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c = f2.last, null !== c ? c.sibling = g2 : b2.child = g2, f2.last = g2);
      }
      if (null !== f2.tail)
        return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B$1(), b2.sibling = null, c = M$1.current, G$1(M$1, d ? c & 1 | 2 : c & 1), b2;
      S$1(b2);
      return null;
    case 22:
    case 23:
      return Ij(), d = null !== b2.memoizedState, null !== a && null !== a.memoizedState !== d && (b2.flags |= 8192), d && 0 !== (b2.mode & 1) ? 0 !== (gj & 1073741824) && (S$1(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S$1(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$2(156, b2.tag));
}
function Jj(a, b2) {
  wg(b2);
  switch (b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a = b2.flags, a & 65536 ? (b2.flags = a & -65537 | 128, b2) : null;
    case 3:
      return Jh(), E(Wf), E(H$2), Oh(), a = b2.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b2.flags = a & -65537 | 128, b2) : null;
    case 5:
      return Lh(b2), null;
    case 13:
      E(M$1);
      a = b2.memoizedState;
      if (null !== a && null !== a.dehydrated) {
        if (null === b2.alternate)
          throw Error(p$2(340));
        Ig();
      }
      a = b2.flags;
      return a & 65536 ? (b2.flags = a & -65537 | 128, b2) : null;
    case 19:
      return E(M$1), null;
    case 4:
      return Jh(), null;
    case 10:
      return Rg(b2.type._context), null;
    case 22:
    case 23:
      return Ij(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Kj = false, U$1 = false, Lj = "function" === typeof WeakSet ? WeakSet : Set, V$1 = null;
function Mj(a, b2) {
  var c = a.ref;
  if (null !== c)
    if ("function" === typeof c)
      try {
        c(null);
      } catch (d) {
        W$2(a, b2, d);
      }
    else
      c.current = null;
}
function Nj(a, b2, c) {
  try {
    c();
  } catch (d) {
    W$2(a, b2, d);
  }
}
var Oj = false;
function Pj(a, b2) {
  Cf = dd;
  a = Me$1();
  if (Ne$1(a)) {
    if ("selectionStart" in a)
      var c = { start: a.selectionStart, end: a.selectionEnd };
    else
      a: {
        c = (c = a.ownerDocument) && c.defaultView || window;
        var d = c.getSelection && c.getSelection();
        if (d && 0 !== d.rangeCount) {
          c = d.anchorNode;
          var e2 = d.anchorOffset, f2 = d.focusNode;
          d = d.focusOffset;
          try {
            c.nodeType, f2.nodeType;
          } catch (F2) {
            c = null;
            break a;
          }
          var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a, r2 = null;
          b:
            for (; ; ) {
              for (var y2; ; ) {
                q2 !== c || 0 !== e2 && 3 !== q2.nodeType || (h2 = g2 + e2);
                q2 !== f2 || 0 !== d && 3 !== q2.nodeType || (k2 = g2 + d);
                3 === q2.nodeType && (g2 += q2.nodeValue.length);
                if (null === (y2 = q2.firstChild))
                  break;
                r2 = q2;
                q2 = y2;
              }
              for (; ; ) {
                if (q2 === a)
                  break b;
                r2 === c && ++l2 === e2 && (h2 = g2);
                r2 === f2 && ++m2 === d && (k2 = g2);
                if (null !== (y2 = q2.nextSibling))
                  break;
                q2 = r2;
                r2 = q2.parentNode;
              }
              q2 = y2;
            }
          c = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
        } else
          c = null;
      }
    c = c || { start: 0, end: 0 };
  } else
    c = null;
  Df = { focusedElem: a, selectionRange: c };
  dd = false;
  for (V$1 = b2; null !== V$1; )
    if (b2 = V$1, a = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a)
      a.return = b2, V$1 = a;
    else
      for (; null !== V$1; ) {
        b2 = V$1;
        try {
          var n2 = b2.alternate;
          if (0 !== (b2.flags & 1024))
            switch (b2.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n2) {
                  var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Lg(b2.type, t2), J2);
                  x2.__reactInternalSnapshotBeforeUpdate = w2;
                }
                break;
              case 3:
                var u2 = b2.stateNode.containerInfo;
                1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p$2(163));
            }
        } catch (F2) {
          W$2(b2, b2.return, F2);
        }
        a = b2.sibling;
        if (null !== a) {
          a.return = b2.return;
          V$1 = a;
          break;
        }
        V$1 = b2.return;
      }
  n2 = Oj;
  Oj = false;
  return n2;
}
function Qj(a, b2, c) {
  var d = b2.updateQueue;
  d = null !== d ? d.lastEffect : null;
  if (null !== d) {
    var e2 = d = d.next;
    do {
      if ((e2.tag & a) === a) {
        var f2 = e2.destroy;
        e2.destroy = void 0;
        void 0 !== f2 && Nj(b2, c, f2);
      }
      e2 = e2.next;
    } while (e2 !== d);
  }
}
function Rj(a, b2) {
  b2 = b2.updateQueue;
  b2 = null !== b2 ? b2.lastEffect : null;
  if (null !== b2) {
    var c = b2 = b2.next;
    do {
      if ((c.tag & a) === a) {
        var d = c.create;
        c.destroy = d();
      }
      c = c.next;
    } while (c !== b2);
  }
}
function Sj(a) {
  var b2 = a.ref;
  if (null !== b2) {
    var c = a.stateNode;
    switch (a.tag) {
      case 5:
        a = c;
        break;
      default:
        a = c;
    }
    "function" === typeof b2 ? b2(a) : b2.current = a;
  }
}
function Tj(a) {
  var b2 = a.alternate;
  null !== b2 && (a.alternate = null, Tj(b2));
  a.child = null;
  a.deletions = null;
  a.sibling = null;
  5 === a.tag && (b2 = a.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of$2], delete b2[Qf], delete b2[Rf]));
  a.stateNode = null;
  a.return = null;
  a.dependencies = null;
  a.memoizedProps = null;
  a.memoizedState = null;
  a.pendingProps = null;
  a.stateNode = null;
  a.updateQueue = null;
}
function Uj(a) {
  return 5 === a.tag || 3 === a.tag || 4 === a.tag;
}
function Vj(a) {
  a:
    for (; ; ) {
      for (; null === a.sibling; ) {
        if (null === a.return || Uj(a.return))
          return null;
        a = a.return;
      }
      a.sibling.return = a.return;
      for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
        if (a.flags & 2)
          continue a;
        if (null === a.child || 4 === a.tag)
          continue a;
        else
          a.child.return = a, a = a.child;
      }
      if (!(a.flags & 2))
        return a.stateNode;
    }
}
function Wj(a, b2, c) {
  var d = a.tag;
  if (5 === d || 6 === d)
    a = a.stateNode, b2 ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b2) : c.insertBefore(a, b2) : (8 === c.nodeType ? (b2 = c.parentNode, b2.insertBefore(a, c)) : (b2 = c, b2.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b2.onclick || (b2.onclick = Bf));
  else if (4 !== d && (a = a.child, null !== a))
    for (Wj(a, b2, c), a = a.sibling; null !== a; )
      Wj(a, b2, c), a = a.sibling;
}
function Xj(a, b2, c) {
  var d = a.tag;
  if (5 === d || 6 === d)
    a = a.stateNode, b2 ? c.insertBefore(a, b2) : c.appendChild(a);
  else if (4 !== d && (a = a.child, null !== a))
    for (Xj(a, b2, c), a = a.sibling; null !== a; )
      Xj(a, b2, c), a = a.sibling;
}
var X$1 = null, Yj = false;
function Zj(a, b2, c) {
  for (c = c.child; null !== c; )
    ak(a, b2, c), c = c.sibling;
}
function ak(a, b2, c) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount)
    try {
      lc.onCommitFiberUnmount(kc, c);
    } catch (h2) {
    }
  switch (c.tag) {
    case 5:
      U$1 || Mj(c, b2);
    case 6:
      var d = X$1, e2 = Yj;
      X$1 = null;
      Zj(a, b2, c);
      X$1 = d;
      Yj = e2;
      null !== X$1 && (Yj ? (a = X$1, c = c.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : X$1.removeChild(c.stateNode));
      break;
    case 18:
      null !== X$1 && (Yj ? (a = X$1, c = c.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c) : 1 === a.nodeType && Kf(a, c), bd(a)) : Kf(X$1, c.stateNode));
      break;
    case 4:
      d = X$1;
      e2 = Yj;
      X$1 = c.stateNode.containerInfo;
      Yj = true;
      Zj(a, b2, c);
      X$1 = d;
      Yj = e2;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U$1 && (d = c.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
        e2 = d = d.next;
        do {
          var f2 = e2, g2 = f2.destroy;
          f2 = f2.tag;
          void 0 !== g2 && (0 !== (f2 & 2) ? Nj(c, b2, g2) : 0 !== (f2 & 4) && Nj(c, b2, g2));
          e2 = e2.next;
        } while (e2 !== d);
      }
      Zj(a, b2, c);
      break;
    case 1:
      if (!U$1 && (Mj(c, b2), d = c.stateNode, "function" === typeof d.componentWillUnmount))
        try {
          d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
        } catch (h2) {
          W$2(c, b2, h2);
        }
      Zj(a, b2, c);
      break;
    case 21:
      Zj(a, b2, c);
      break;
    case 22:
      c.mode & 1 ? (U$1 = (d = U$1) || null !== c.memoizedState, Zj(a, b2, c), U$1 = d) : Zj(a, b2, c);
      break;
    default:
      Zj(a, b2, c);
  }
}
function bk(a) {
  var b2 = a.updateQueue;
  if (null !== b2) {
    a.updateQueue = null;
    var c = a.stateNode;
    null === c && (c = a.stateNode = new Lj());
    b2.forEach(function(b3) {
      var d = ck.bind(null, a, b3);
      c.has(b3) || (c.add(b3), b3.then(d, d));
    });
  }
}
function dk(a, b2) {
  var c = b2.deletions;
  if (null !== c)
    for (var d = 0; d < c.length; d++) {
      var e2 = c[d];
      try {
        var f2 = a, g2 = b2, h2 = g2;
        a:
          for (; null !== h2; ) {
            switch (h2.tag) {
              case 5:
                X$1 = h2.stateNode;
                Yj = false;
                break a;
              case 3:
                X$1 = h2.stateNode.containerInfo;
                Yj = true;
                break a;
              case 4:
                X$1 = h2.stateNode.containerInfo;
                Yj = true;
                break a;
            }
            h2 = h2.return;
          }
        if (null === X$1)
          throw Error(p$2(160));
        ak(f2, g2, e2);
        X$1 = null;
        Yj = false;
        var k2 = e2.alternate;
        null !== k2 && (k2.return = null);
        e2.return = null;
      } catch (l2) {
        W$2(e2, b2, l2);
      }
    }
  if (b2.subtreeFlags & 12854)
    for (b2 = b2.child; null !== b2; )
      ek(b2, a), b2 = b2.sibling;
}
function ek(a, b2) {
  var c = a.alternate, d = a.flags;
  switch (a.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      dk(b2, a);
      fk(a);
      if (d & 4) {
        try {
          Qj(3, a, a.return), Rj(3, a);
        } catch (t2) {
          W$2(a, a.return, t2);
        }
        try {
          Qj(5, a, a.return);
        } catch (t2) {
          W$2(a, a.return, t2);
        }
      }
      break;
    case 1:
      dk(b2, a);
      fk(a);
      d & 512 && null !== c && Mj(c, c.return);
      break;
    case 5:
      dk(b2, a);
      fk(a);
      d & 512 && null !== c && Mj(c, c.return);
      if (a.flags & 32) {
        var e2 = a.stateNode;
        try {
          ob(e2, "");
        } catch (t2) {
          W$2(a, a.return, t2);
        }
      }
      if (d & 4 && (e2 = a.stateNode, null != e2)) {
        var f2 = a.memoizedProps, g2 = null !== c ? c.memoizedProps : f2, h2 = a.type, k2 = a.updateQueue;
        a.updateQueue = null;
        if (null !== k2)
          try {
            "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
            vb(h2, g2);
            var l2 = vb(h2, f2);
            for (g2 = 0; g2 < k2.length; g2 += 2) {
              var m2 = k2[g2], q2 = k2[g2 + 1];
              "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
            }
            switch (h2) {
              case "input":
                bb(e2, f2);
                break;
              case "textarea":
                ib(e2, f2);
                break;
              case "select":
                var r2 = e2._wrapperState.wasMultiple;
                e2._wrapperState.wasMultiple = !!f2.multiple;
                var y2 = f2.value;
                null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                  e2,
                  !!f2.multiple,
                  f2.defaultValue,
                  true
                ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
            }
            e2[Pf] = f2;
          } catch (t2) {
            W$2(a, a.return, t2);
          }
      }
      break;
    case 6:
      dk(b2, a);
      fk(a);
      if (d & 4) {
        if (null === a.stateNode)
          throw Error(p$2(162));
        e2 = a.stateNode;
        f2 = a.memoizedProps;
        try {
          e2.nodeValue = f2;
        } catch (t2) {
          W$2(a, a.return, t2);
        }
      }
      break;
    case 3:
      dk(b2, a);
      fk(a);
      if (d & 4 && null !== c && c.memoizedState.isDehydrated)
        try {
          bd(b2.containerInfo);
        } catch (t2) {
          W$2(a, a.return, t2);
        }
      break;
    case 4:
      dk(b2, a);
      fk(a);
      break;
    case 13:
      dk(b2, a);
      fk(a);
      e2 = a.child;
      e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (gk = B$1()));
      d & 4 && bk(a);
      break;
    case 22:
      m2 = null !== c && null !== c.memoizedState;
      a.mode & 1 ? (U$1 = (l2 = U$1) || m2, dk(b2, a), U$1 = l2) : dk(b2, a);
      fk(a);
      if (d & 8192) {
        l2 = null !== a.memoizedState;
        if ((a.stateNode.isHidden = l2) && !m2 && 0 !== (a.mode & 1))
          for (V$1 = a, m2 = a.child; null !== m2; ) {
            for (q2 = V$1 = m2; null !== V$1; ) {
              r2 = V$1;
              y2 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Qj(4, r2, r2.return);
                  break;
                case 1:
                  Mj(r2, r2.return);
                  var n2 = r2.stateNode;
                  if ("function" === typeof n2.componentWillUnmount) {
                    d = r2;
                    c = r2.return;
                    try {
                      b2 = d, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                    } catch (t2) {
                      W$2(d, c, t2);
                    }
                  }
                  break;
                case 5:
                  Mj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    hk(q2);
                    continue;
                  }
              }
              null !== y2 ? (y2.return = r2, V$1 = y2) : hk(q2);
            }
            m2 = m2.sibling;
          }
        a:
          for (m2 = null, q2 = a; ; ) {
            if (5 === q2.tag) {
              if (null === m2) {
                m2 = q2;
                try {
                  e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                } catch (t2) {
                  W$2(a, a.return, t2);
                }
              }
            } else if (6 === q2.tag) {
              if (null === m2)
                try {
                  q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                } catch (t2) {
                  W$2(a, a.return, t2);
                }
            } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a) && null !== q2.child) {
              q2.child.return = q2;
              q2 = q2.child;
              continue;
            }
            if (q2 === a)
              break a;
            for (; null === q2.sibling; ) {
              if (null === q2.return || q2.return === a)
                break a;
              m2 === q2 && (m2 = null);
              q2 = q2.return;
            }
            m2 === q2 && (m2 = null);
            q2.sibling.return = q2.return;
            q2 = q2.sibling;
          }
      }
      break;
    case 19:
      dk(b2, a);
      fk(a);
      d & 4 && bk(a);
      break;
    case 21:
      break;
    default:
      dk(
        b2,
        a
      ), fk(a);
  }
}
function fk(a) {
  var b2 = a.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c = a.return; null !== c; ) {
          if (Uj(c)) {
            var d = c;
            break a;
          }
          c = c.return;
        }
        throw Error(p$2(160));
      }
      switch (d.tag) {
        case 5:
          var e2 = d.stateNode;
          d.flags & 32 && (ob(e2, ""), d.flags &= -33);
          var f2 = Vj(a);
          Xj(a, f2, e2);
          break;
        case 3:
        case 4:
          var g2 = d.stateNode.containerInfo, h2 = Vj(a);
          Wj(a, h2, g2);
          break;
        default:
          throw Error(p$2(161));
      }
    } catch (k2) {
      W$2(a, a.return, k2);
    }
    a.flags &= -3;
  }
  b2 & 4096 && (a.flags &= -4097);
}
function ik(a, b2, c) {
  V$1 = a;
  jk(a);
}
function jk(a, b2, c) {
  for (var d = 0 !== (a.mode & 1); null !== V$1; ) {
    var e2 = V$1, f2 = e2.child;
    if (22 === e2.tag && d) {
      var g2 = null !== e2.memoizedState || Kj;
      if (!g2) {
        var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U$1;
        h2 = Kj;
        var l2 = U$1;
        Kj = g2;
        if ((U$1 = k2) && !l2)
          for (V$1 = e2; null !== V$1; )
            g2 = V$1, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? kk(e2) : null !== k2 ? (k2.return = g2, V$1 = k2) : kk(e2);
        for (; null !== f2; )
          V$1 = f2, jk(f2), f2 = f2.sibling;
        V$1 = e2;
        Kj = h2;
        U$1 = l2;
      }
      lk(a);
    } else
      0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V$1 = f2) : lk(a);
  }
}
function lk(a) {
  for (; null !== V$1; ) {
    var b2 = V$1;
    if (0 !== (b2.flags & 8772)) {
      var c = b2.alternate;
      try {
        if (0 !== (b2.flags & 8772))
          switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              U$1 || Rj(5, b2);
              break;
            case 1:
              var d = b2.stateNode;
              if (b2.flags & 4 && !U$1)
                if (null === c)
                  d.componentDidMount();
                else {
                  var e2 = b2.elementType === b2.type ? c.memoizedProps : Lg(b2.type, c.memoizedProps);
                  d.componentDidUpdate(e2, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
                }
              var f2 = b2.updateQueue;
              null !== f2 && ih(b2, f2, d);
              break;
            case 3:
              var g2 = b2.updateQueue;
              if (null !== g2) {
                c = null;
                if (null !== b2.child)
                  switch (b2.child.tag) {
                    case 5:
                      c = b2.child.stateNode;
                      break;
                    case 1:
                      c = b2.child.stateNode;
                  }
                ih(b2, g2, c);
              }
              break;
            case 5:
              var h2 = b2.stateNode;
              if (null === c && b2.flags & 4) {
                c = h2;
                var k2 = b2.memoizedProps;
                switch (b2.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c.focus();
                    break;
                  case "img":
                    k2.src && (c.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b2.memoizedState) {
                var l2 = b2.alternate;
                if (null !== l2) {
                  var m2 = l2.memoizedState;
                  if (null !== m2) {
                    var q2 = m2.dehydrated;
                    null !== q2 && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p$2(163));
          }
        U$1 || b2.flags & 512 && Sj(b2);
      } catch (r2) {
        W$2(b2, b2.return, r2);
      }
    }
    if (b2 === a) {
      V$1 = null;
      break;
    }
    c = b2.sibling;
    if (null !== c) {
      c.return = b2.return;
      V$1 = c;
      break;
    }
    V$1 = b2.return;
  }
}
function hk(a) {
  for (; null !== V$1; ) {
    var b2 = V$1;
    if (b2 === a) {
      V$1 = null;
      break;
    }
    var c = b2.sibling;
    if (null !== c) {
      c.return = b2.return;
      V$1 = c;
      break;
    }
    V$1 = b2.return;
  }
}
function kk(a) {
  for (; null !== V$1; ) {
    var b2 = V$1;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c = b2.return;
          try {
            Rj(4, b2);
          } catch (k2) {
            W$2(b2, c, k2);
          }
          break;
        case 1:
          var d = b2.stateNode;
          if ("function" === typeof d.componentDidMount) {
            var e2 = b2.return;
            try {
              d.componentDidMount();
            } catch (k2) {
              W$2(b2, e2, k2);
            }
          }
          var f2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W$2(b2, f2, k2);
          }
          break;
        case 5:
          var g2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W$2(b2, g2, k2);
          }
      }
    } catch (k2) {
      W$2(b2, b2.return, k2);
    }
    if (b2 === a) {
      V$1 = null;
      break;
    }
    var h2 = b2.sibling;
    if (null !== h2) {
      h2.return = b2.return;
      V$1 = h2;
      break;
    }
    V$1 = b2.return;
  }
}
var mk = Math.ceil, nk = ua.ReactCurrentDispatcher, ok = ua.ReactCurrentOwner, pk = ua.ReactCurrentBatchConfig, K$2 = 0, R$1 = null, Y$1 = null, Z$1 = 0, gj = 0, fj = Uf(0), T$1 = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = Infinity, vk = null, Pi = false, Qi = null, Si = null, wk = false, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
function L$1() {
  return 0 !== (K$2 & 6) ? B$1() : -1 !== Bk ? Bk : Bk = B$1();
}
function lh(a) {
  if (0 === (a.mode & 1))
    return 1;
  if (0 !== (K$2 & 2) && 0 !== Z$1)
    return Z$1 & -Z$1;
  if (null !== Kg.transition)
    return 0 === Ck && (Ck = yc()), Ck;
  a = C$1;
  if (0 !== a)
    return a;
  a = window.event;
  a = void 0 === a ? 16 : jd(a.type);
  return a;
}
function mh(a, b2, c, d) {
  if (50 < zk)
    throw zk = 0, Ak = null, Error(p$2(185));
  Ac(a, c, d);
  if (0 === (K$2 & 2) || a !== R$1)
    a === R$1 && (0 === (K$2 & 2) && (rk |= c), 4 === T$1 && Dk(a, Z$1)), Ek(a, d), 1 === c && 0 === K$2 && 0 === (b2.mode & 1) && (Hj = B$1() + 500, fg && jg());
}
function Ek(a, b2) {
  var c = a.callbackNode;
  wc(a, b2);
  var d = uc(a, a === R$1 ? Z$1 : 0);
  if (0 === d)
    null !== c && bc(c), a.callbackNode = null, a.callbackPriority = 0;
  else if (b2 = d & -d, a.callbackPriority !== b2) {
    null != c && bc(c);
    if (1 === b2)
      0 === a.tag ? ig(Fk.bind(null, a)) : hg(Fk.bind(null, a)), Jf(function() {
        0 === (K$2 & 6) && jg();
      }), c = null;
    else {
      switch (Dc(d)) {
        case 1:
          c = fc;
          break;
        case 4:
          c = gc;
          break;
        case 16:
          c = hc;
          break;
        case 536870912:
          c = jc;
          break;
        default:
          c = hc;
      }
      c = Gk(c, Hk.bind(null, a));
    }
    a.callbackPriority = b2;
    a.callbackNode = c;
  }
}
function Hk(a, b2) {
  Bk = -1;
  Ck = 0;
  if (0 !== (K$2 & 6))
    throw Error(p$2(327));
  var c = a.callbackNode;
  if (Ik() && a.callbackNode !== c)
    return null;
  var d = uc(a, a === R$1 ? Z$1 : 0);
  if (0 === d)
    return null;
  if (0 !== (d & 30) || 0 !== (d & a.expiredLanes) || b2)
    b2 = Jk(a, d);
  else {
    b2 = d;
    var e2 = K$2;
    K$2 |= 2;
    var f2 = Kk();
    if (R$1 !== a || Z$1 !== b2)
      vk = null, Hj = B$1() + 500, Lk(a, b2);
    do
      try {
        Mk();
        break;
      } catch (h2) {
        Nk(a, h2);
      }
    while (1);
    Qg();
    nk.current = f2;
    K$2 = e2;
    null !== Y$1 ? b2 = 0 : (R$1 = null, Z$1 = 0, b2 = T$1);
  }
  if (0 !== b2) {
    2 === b2 && (e2 = xc(a), 0 !== e2 && (d = e2, b2 = Ok(a, e2)));
    if (1 === b2)
      throw c = qk, Lk(a, 0), Dk(a, d), Ek(a, B$1()), c;
    if (6 === b2)
      Dk(a, d);
    else {
      e2 = a.current.alternate;
      if (0 === (d & 30) && !Pk(e2) && (b2 = Jk(a, d), 2 === b2 && (f2 = xc(a), 0 !== f2 && (d = f2, b2 = Ok(a, f2))), 1 === b2))
        throw c = qk, Lk(a, 0), Dk(a, d), Ek(a, B$1()), c;
      a.finishedWork = e2;
      a.finishedLanes = d;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$2(345));
        case 2:
          Qk(a, uk, vk);
          break;
        case 3:
          Dk(a, d);
          if ((d & 130023424) === d && (b2 = gk + 500 - B$1(), 10 < b2)) {
            if (0 !== uc(a, 0))
              break;
            e2 = a.suspendedLanes;
            if ((e2 & d) !== d) {
              L$1();
              a.pingedLanes |= a.suspendedLanes & e2;
              break;
            }
            a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), b2);
            break;
          }
          Qk(a, uk, vk);
          break;
        case 4:
          Dk(a, d);
          if ((d & 4194240) === d)
            break;
          b2 = a.eventTimes;
          for (e2 = -1; 0 < d; ) {
            var g2 = 31 - oc(d);
            f2 = 1 << g2;
            g2 = b2[g2];
            g2 > e2 && (e2 = g2);
            d &= ~f2;
          }
          d = e2;
          d = B$1() - d;
          d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * mk(d / 1960)) - d;
          if (10 < d) {
            a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), d);
            break;
          }
          Qk(a, uk, vk);
          break;
        case 5:
          Qk(a, uk, vk);
          break;
        default:
          throw Error(p$2(329));
      }
    }
  }
  Ek(a, B$1());
  return a.callbackNode === c ? Hk.bind(null, a) : null;
}
function Ok(a, b2) {
  var c = tk;
  a.current.memoizedState.isDehydrated && (Lk(a, b2).flags |= 256);
  a = Jk(a, b2);
  2 !== a && (b2 = uk, uk = c, null !== b2 && Gj(b2));
  return a;
}
function Gj(a) {
  null === uk ? uk = a : uk.push.apply(uk, a);
}
function Pk(a) {
  for (var b2 = a; ; ) {
    if (b2.flags & 16384) {
      var c = b2.updateQueue;
      if (null !== c && (c = c.stores, null !== c))
        for (var d = 0; d < c.length; d++) {
          var e2 = c[d], f2 = e2.getSnapshot;
          e2 = e2.value;
          try {
            if (!He$1(f2(), e2))
              return false;
          } catch (g2) {
            return false;
          }
        }
    }
    c = b2.child;
    if (b2.subtreeFlags & 16384 && null !== c)
      c.return = b2, b2 = c;
    else {
      if (b2 === a)
        break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a)
          return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
function Dk(a, b2) {
  b2 &= ~sk;
  b2 &= ~rk;
  a.suspendedLanes |= b2;
  a.pingedLanes &= ~b2;
  for (a = a.expirationTimes; 0 < b2; ) {
    var c = 31 - oc(b2), d = 1 << c;
    a[c] = -1;
    b2 &= ~d;
  }
}
function Fk(a) {
  if (0 !== (K$2 & 6))
    throw Error(p$2(327));
  Ik();
  var b2 = uc(a, 0);
  if (0 === (b2 & 1))
    return Ek(a, B$1()), null;
  var c = Jk(a, b2);
  if (0 !== a.tag && 2 === c) {
    var d = xc(a);
    0 !== d && (b2 = d, c = Ok(a, d));
  }
  if (1 === c)
    throw c = qk, Lk(a, 0), Dk(a, b2), Ek(a, B$1()), c;
  if (6 === c)
    throw Error(p$2(345));
  a.finishedWork = a.current.alternate;
  a.finishedLanes = b2;
  Qk(a, uk, vk);
  Ek(a, B$1());
  return null;
}
function Rk(a, b2) {
  var c = K$2;
  K$2 |= 1;
  try {
    return a(b2);
  } finally {
    K$2 = c, 0 === K$2 && (Hj = B$1() + 500, fg && jg());
  }
}
function Sk(a) {
  null !== xk && 0 === xk.tag && 0 === (K$2 & 6) && Ik();
  var b2 = K$2;
  K$2 |= 1;
  var c = pk.transition, d = C$1;
  try {
    if (pk.transition = null, C$1 = 1, a)
      return a();
  } finally {
    C$1 = d, pk.transition = c, K$2 = b2, 0 === (K$2 & 6) && jg();
  }
}
function Ij() {
  gj = fj.current;
  E(fj);
}
function Lk(a, b2) {
  a.finishedWork = null;
  a.finishedLanes = 0;
  var c = a.timeoutHandle;
  -1 !== c && (a.timeoutHandle = -1, Gf(c));
  if (null !== Y$1)
    for (c = Y$1.return; null !== c; ) {
      var d = c;
      wg(d);
      switch (d.tag) {
        case 1:
          d = d.type.childContextTypes;
          null !== d && void 0 !== d && $f();
          break;
        case 3:
          Jh();
          E(Wf);
          E(H$2);
          Oh();
          break;
        case 5:
          Lh(d);
          break;
        case 4:
          Jh();
          break;
        case 13:
          E(M$1);
          break;
        case 19:
          E(M$1);
          break;
        case 10:
          Rg(d.type._context);
          break;
        case 22:
        case 23:
          Ij();
      }
      c = c.return;
    }
  R$1 = a;
  Y$1 = a = wh(a.current, null);
  Z$1 = gj = b2;
  T$1 = 0;
  qk = null;
  sk = rk = hh = 0;
  uk = tk = null;
  if (null !== Wg) {
    for (b2 = 0; b2 < Wg.length; b2++)
      if (c = Wg[b2], d = c.interleaved, null !== d) {
        c.interleaved = null;
        var e2 = d.next, f2 = c.pending;
        if (null !== f2) {
          var g2 = f2.next;
          f2.next = e2;
          d.next = g2;
        }
        c.pending = d;
      }
    Wg = null;
  }
  return a;
}
function Nk(a, b2) {
  do {
    var c = Y$1;
    try {
      Qg();
      Ph.current = ai;
      if (Sh) {
        for (var d = N.memoizedState; null !== d; ) {
          var e2 = d.queue;
          null !== e2 && (e2.pending = null);
          d = d.next;
        }
        Sh = false;
      }
      Rh = 0;
      P = O$1 = N = null;
      Th = false;
      Uh = 0;
      ok.current = null;
      if (null === c || null === c.return) {
        T$1 = 1;
        qk = b2;
        Y$1 = null;
        break;
      }
      a: {
        var f2 = a, g2 = c.return, h2 = c, k2 = b2;
        b2 = Z$1;
        h2.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2, m2 = h2, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Vi(g2);
          if (null !== y2) {
            y2.flags &= -257;
            Wi(y2, g2, h2, f2, b2);
            y2.mode & 1 && Ti(f2, l2, b2);
            b2 = y2;
            k2 = l2;
            var n2 = b2.updateQueue;
            if (null === n2) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k2);
              b2.updateQueue = t2;
            } else
              n2.add(k2);
            break a;
          } else {
            if (0 === (b2 & 1)) {
              Ti(f2, l2, b2);
              uj();
              break a;
            }
            k2 = Error(p$2(426));
          }
        } else if (I$1 && h2.mode & 1) {
          var J2 = Vi(g2);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Wi(J2, g2, h2, f2, b2);
            Jg(Ki(k2, h2));
            break a;
          }
        }
        f2 = k2 = Ki(k2, h2);
        4 !== T$1 && (T$1 = 2);
        null === tk ? tk = [f2] : tk.push(f2);
        f2 = g2;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b2 &= -b2;
              f2.lanes |= b2;
              var x2 = Oi(f2, k2, b2);
              fh(f2, x2);
              break a;
            case 1:
              h2 = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Si || !Si.has(u2)))) {
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var F2 = Ri(f2, h2, b2);
                fh(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Tk(c);
    } catch (na) {
      b2 = na;
      Y$1 === c && null !== c && (Y$1 = c = c.return);
      continue;
    }
    break;
  } while (1);
}
function Kk() {
  var a = nk.current;
  nk.current = ai;
  return null === a ? ai : a;
}
function uj() {
  if (0 === T$1 || 3 === T$1 || 2 === T$1)
    T$1 = 4;
  null === R$1 || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R$1, Z$1);
}
function Jk(a, b2) {
  var c = K$2;
  K$2 |= 2;
  var d = Kk();
  if (R$1 !== a || Z$1 !== b2)
    vk = null, Lk(a, b2);
  do
    try {
      Uk();
      break;
    } catch (e2) {
      Nk(a, e2);
    }
  while (1);
  Qg();
  K$2 = c;
  nk.current = d;
  if (null !== Y$1)
    throw Error(p$2(261));
  R$1 = null;
  Z$1 = 0;
  return T$1;
}
function Uk() {
  for (; null !== Y$1; )
    Vk(Y$1);
}
function Mk() {
  for (; null !== Y$1 && !cc(); )
    Vk(Y$1);
}
function Vk(a) {
  var b2 = Wk(a.alternate, a, gj);
  a.memoizedProps = a.pendingProps;
  null === b2 ? Tk(a) : Y$1 = b2;
  ok.current = null;
}
function Tk(a) {
  var b2 = a;
  do {
    var c = b2.alternate;
    a = b2.return;
    if (0 === (b2.flags & 32768)) {
      if (c = Fj(c, b2, gj), null !== c) {
        Y$1 = c;
        return;
      }
    } else {
      c = Jj(c, b2);
      if (null !== c) {
        c.flags &= 32767;
        Y$1 = c;
        return;
      }
      if (null !== a)
        a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
      else {
        T$1 = 6;
        Y$1 = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y$1 = b2;
      return;
    }
    Y$1 = b2 = a;
  } while (null !== b2);
  0 === T$1 && (T$1 = 5);
}
function Qk(a, b2, c) {
  var d = C$1, e2 = pk.transition;
  try {
    pk.transition = null, C$1 = 1, Xk(a, b2, c, d);
  } finally {
    pk.transition = e2, C$1 = d;
  }
  return null;
}
function Xk(a, b2, c, d) {
  do
    Ik();
  while (null !== xk);
  if (0 !== (K$2 & 6))
    throw Error(p$2(327));
  c = a.finishedWork;
  var e2 = a.finishedLanes;
  if (null === c)
    return null;
  a.finishedWork = null;
  a.finishedLanes = 0;
  if (c === a.current)
    throw Error(p$2(177));
  a.callbackNode = null;
  a.callbackPriority = 0;
  var f2 = c.lanes | c.childLanes;
  Bc(a, f2);
  a === R$1 && (Y$1 = R$1 = null, Z$1 = 0);
  0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || wk || (wk = true, Gk(hc, function() {
    Ik();
    return null;
  }));
  f2 = 0 !== (c.flags & 15990);
  if (0 !== (c.subtreeFlags & 15990) || f2) {
    f2 = pk.transition;
    pk.transition = null;
    var g2 = C$1;
    C$1 = 1;
    var h2 = K$2;
    K$2 |= 4;
    ok.current = null;
    Pj(a, c);
    ek(c, a);
    Oe$1(Df);
    dd = !!Cf;
    Df = Cf = null;
    a.current = c;
    ik(c);
    dc();
    K$2 = h2;
    C$1 = g2;
    pk.transition = f2;
  } else
    a.current = c;
  wk && (wk = false, xk = a, yk = e2);
  f2 = a.pendingLanes;
  0 === f2 && (Si = null);
  mc(c.stateNode);
  Ek(a, B$1());
  if (null !== b2)
    for (d = a.onRecoverableError, c = 0; c < b2.length; c++)
      e2 = b2[c], d(e2.value, { componentStack: e2.stack, digest: e2.digest });
  if (Pi)
    throw Pi = false, a = Qi, Qi = null, a;
  0 !== (yk & 1) && 0 !== a.tag && Ik();
  f2 = a.pendingLanes;
  0 !== (f2 & 1) ? a === Ak ? zk++ : (zk = 0, Ak = a) : zk = 0;
  jg();
  return null;
}
function Ik() {
  if (null !== xk) {
    var a = Dc(yk), b2 = pk.transition, c = C$1;
    try {
      pk.transition = null;
      C$1 = 16 > a ? 16 : a;
      if (null === xk)
        var d = false;
      else {
        a = xk;
        xk = null;
        yk = 0;
        if (0 !== (K$2 & 6))
          throw Error(p$2(331));
        var e2 = K$2;
        K$2 |= 4;
        for (V$1 = a.current; null !== V$1; ) {
          var f2 = V$1, g2 = f2.child;
          if (0 !== (V$1.flags & 16)) {
            var h2 = f2.deletions;
            if (null !== h2) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (V$1 = l2; null !== V$1; ) {
                  var m2 = V$1;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (null !== q2)
                    q2.return = m2, V$1 = q2;
                  else
                    for (; null !== V$1; ) {
                      m2 = V$1;
                      var r2 = m2.sibling, y2 = m2.return;
                      Tj(m2);
                      if (m2 === l2) {
                        V$1 = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y2;
                        V$1 = r2;
                        break;
                      }
                      V$1 = y2;
                    }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t2 = n2.child;
                if (null !== t2) {
                  n2.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null;
                    t2 = J2;
                  } while (null !== t2);
                }
              }
              V$1 = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g2)
            g2.return = f2, V$1 = g2;
          else
            b:
              for (; null !== V$1; ) {
                f2 = V$1;
                if (0 !== (f2.flags & 2048))
                  switch (f2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(9, f2, f2.return);
                  }
                var x2 = f2.sibling;
                if (null !== x2) {
                  x2.return = f2.return;
                  V$1 = x2;
                  break b;
                }
                V$1 = f2.return;
              }
        }
        var w2 = a.current;
        for (V$1 = w2; null !== V$1; ) {
          g2 = V$1;
          var u2 = g2.child;
          if (0 !== (g2.subtreeFlags & 2064) && null !== u2)
            u2.return = g2, V$1 = u2;
          else
            b:
              for (g2 = w2; null !== V$1; ) {
                h2 = V$1;
                if (0 !== (h2.flags & 2048))
                  try {
                    switch (h2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Rj(9, h2);
                    }
                  } catch (na) {
                    W$2(h2, h2.return, na);
                  }
                if (h2 === g2) {
                  V$1 = null;
                  break b;
                }
                var F2 = h2.sibling;
                if (null !== F2) {
                  F2.return = h2.return;
                  V$1 = F2;
                  break b;
                }
                V$1 = h2.return;
              }
        }
        K$2 = e2;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot)
          try {
            lc.onPostCommitFiberRoot(kc, a);
          } catch (na) {
          }
        d = true;
      }
      return d;
    } finally {
      C$1 = c, pk.transition = b2;
    }
  }
  return false;
}
function Yk(a, b2, c) {
  b2 = Ki(c, b2);
  b2 = Oi(a, b2, 1);
  a = dh(a, b2, 1);
  b2 = L$1();
  null !== a && (Ac(a, 1, b2), Ek(a, b2));
}
function W$2(a, b2, c) {
  if (3 === a.tag)
    Yk(a, a, c);
  else
    for (; null !== b2; ) {
      if (3 === b2.tag) {
        Yk(b2, a, c);
        break;
      } else if (1 === b2.tag) {
        var d = b2.stateNode;
        if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Si || !Si.has(d))) {
          a = Ki(c, a);
          a = Ri(b2, a, 1);
          b2 = dh(b2, a, 1);
          a = L$1();
          null !== b2 && (Ac(b2, 1, a), Ek(b2, a));
          break;
        }
      }
      b2 = b2.return;
    }
}
function Ui(a, b2, c) {
  var d = a.pingCache;
  null !== d && d.delete(b2);
  b2 = L$1();
  a.pingedLanes |= a.suspendedLanes & c;
  R$1 === a && (Z$1 & c) === c && (4 === T$1 || 3 === T$1 && (Z$1 & 130023424) === Z$1 && 500 > B$1() - gk ? Lk(a, 0) : sk |= c);
  Ek(a, b2);
}
function Zk(a, b2) {
  0 === b2 && (0 === (a.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c = L$1();
  a = Zg(a, b2);
  null !== a && (Ac(a, b2, c), Ek(a, c));
}
function vj(a) {
  var b2 = a.memoizedState, c = 0;
  null !== b2 && (c = b2.retryLane);
  Zk(a, c);
}
function ck(a, b2) {
  var c = 0;
  switch (a.tag) {
    case 13:
      var d = a.stateNode;
      var e2 = a.memoizedState;
      null !== e2 && (c = e2.retryLane);
      break;
    case 19:
      d = a.stateNode;
      break;
    default:
      throw Error(p$2(314));
  }
  null !== d && d.delete(b2);
  Zk(a, c);
}
var Wk;
Wk = function(a, b2, c) {
  if (null !== a)
    if (a.memoizedProps !== b2.pendingProps || Wf.current)
      Ug = true;
    else {
      if (0 === (a.lanes & c) && 0 === (b2.flags & 128))
        return Ug = false, zj(a, b2, c);
      Ug = 0 !== (a.flags & 131072) ? true : false;
    }
  else
    Ug = false, I$1 && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      var d = b2.type;
      jj(a, b2);
      a = b2.pendingProps;
      var e2 = Yf(b2, H$2.current);
      Tg(b2, c);
      e2 = Xh(null, b2, d, a, e2, c);
      var f2 = bi();
      b2.flags |= 1;
      "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, ah(b2), e2.updater = nh, b2.stateNode = e2, e2._reactInternals = b2, rh(b2, d, a, c), b2 = kj(null, b2, d, true, f2, c)) : (b2.tag = 0, I$1 && f2 && vg(b2), Yi(null, b2, e2, c), b2 = b2.child);
      return b2;
    case 16:
      d = b2.elementType;
      a: {
        jj(a, b2);
        a = b2.pendingProps;
        e2 = d._init;
        d = e2(d._payload);
        b2.type = d;
        e2 = b2.tag = $k(d);
        a = Lg(d, a);
        switch (e2) {
          case 0:
            b2 = dj(null, b2, d, a, c);
            break a;
          case 1:
            b2 = ij(null, b2, d, a, c);
            break a;
          case 11:
            b2 = Zi(null, b2, d, a, c);
            break a;
          case 14:
            b2 = aj(null, b2, d, Lg(d.type, a), c);
            break a;
        }
        throw Error(p$2(
          306,
          d,
          ""
        ));
      }
      return b2;
    case 0:
      return d = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d ? e2 : Lg(d, e2), dj(a, b2, d, e2, c);
    case 1:
      return d = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d ? e2 : Lg(d, e2), ij(a, b2, d, e2, c);
    case 3:
      a: {
        lj(b2);
        if (null === a)
          throw Error(p$2(387));
        d = b2.pendingProps;
        f2 = b2.memoizedState;
        e2 = f2.element;
        bh(a, b2);
        gh(b2, d, null, c);
        var g2 = b2.memoizedState;
        d = g2.element;
        if (f2.isDehydrated)
          if (f2 = { element: d, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
            e2 = Ki(Error(p$2(423)), b2);
            b2 = mj(a, b2, d, c, e2);
            break a;
          } else if (d !== e2) {
            e2 = Ki(Error(p$2(424)), b2);
            b2 = mj(a, b2, d, c, e2);
            break a;
          } else
            for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I$1 = true, zg = null, c = Ch(b2, null, d, c), b2.child = c; c; )
              c.flags = c.flags & -3 | 4096, c = c.sibling;
        else {
          Ig();
          if (d === e2) {
            b2 = $i(a, b2, c);
            break a;
          }
          Yi(a, b2, d, c);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Kh(b2), null === a && Eg(b2), d = b2.type, e2 = b2.pendingProps, f2 = null !== a ? a.memoizedProps : null, g2 = e2.children, Ef(d, e2) ? g2 = null : null !== f2 && Ef(d, f2) && (b2.flags |= 32), hj(a, b2), Yi(a, b2, g2, c), b2.child;
    case 6:
      return null === a && Eg(b2), null;
    case 13:
      return pj(a, b2, c);
    case 4:
      return Ih(b2, b2.stateNode.containerInfo), d = b2.pendingProps, null === a ? b2.child = Bh(b2, null, d, c) : Yi(a, b2, d, c), b2.child;
    case 11:
      return d = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d ? e2 : Lg(d, e2), Zi(a, b2, d, e2, c);
    case 7:
      return Yi(a, b2, b2.pendingProps, c), b2.child;
    case 8:
      return Yi(a, b2, b2.pendingProps.children, c), b2.child;
    case 12:
      return Yi(a, b2, b2.pendingProps.children, c), b2.child;
    case 10:
      a: {
        d = b2.type._context;
        e2 = b2.pendingProps;
        f2 = b2.memoizedProps;
        g2 = e2.value;
        G$1(Mg, d._currentValue);
        d._currentValue = g2;
        if (null !== f2)
          if (He$1(f2.value, g2)) {
            if (f2.children === e2.children && !Wf.current) {
              b2 = $i(a, b2, c);
              break a;
            }
          } else
            for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
              var h2 = f2.dependencies;
              if (null !== h2) {
                g2 = f2.child;
                for (var k2 = h2.firstContext; null !== k2; ) {
                  if (k2.context === d) {
                    if (1 === f2.tag) {
                      k2 = ch(-1, c & -c);
                      k2.tag = 2;
                      var l2 = f2.updateQueue;
                      if (null !== l2) {
                        l2 = l2.shared;
                        var m2 = l2.pending;
                        null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                        l2.pending = k2;
                      }
                    }
                    f2.lanes |= c;
                    k2 = f2.alternate;
                    null !== k2 && (k2.lanes |= c);
                    Sg(
                      f2.return,
                      c,
                      b2
                    );
                    h2.lanes |= c;
                    break;
                  }
                  k2 = k2.next;
                }
              } else if (10 === f2.tag)
                g2 = f2.type === b2.type ? null : f2.child;
              else if (18 === f2.tag) {
                g2 = f2.return;
                if (null === g2)
                  throw Error(p$2(341));
                g2.lanes |= c;
                h2 = g2.alternate;
                null !== h2 && (h2.lanes |= c);
                Sg(g2, c, b2);
                g2 = f2.sibling;
              } else
                g2 = f2.child;
              if (null !== g2)
                g2.return = f2;
              else
                for (g2 = f2; null !== g2; ) {
                  if (g2 === b2) {
                    g2 = null;
                    break;
                  }
                  f2 = g2.sibling;
                  if (null !== f2) {
                    f2.return = g2.return;
                    g2 = f2;
                    break;
                  }
                  g2 = g2.return;
                }
              f2 = g2;
            }
        Yi(a, b2, e2.children, c);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e2 = b2.type, d = b2.pendingProps.children, Tg(b2, c), e2 = Vg(e2), d = d(e2), b2.flags |= 1, Yi(a, b2, d, c), b2.child;
    case 14:
      return d = b2.type, e2 = Lg(d, b2.pendingProps), e2 = Lg(d.type, e2), aj(a, b2, d, e2, c);
    case 15:
      return cj(a, b2, b2.type, b2.pendingProps, c);
    case 17:
      return d = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d ? e2 : Lg(d, e2), jj(a, b2), b2.tag = 1, Zf(d) ? (a = true, cg(b2)) : a = false, Tg(b2, c), ph(b2, d, e2), rh(b2, d, e2, c), kj(null, b2, d, true, a, c);
    case 19:
      return yj(a, b2, c);
    case 22:
      return ej(a, b2, c);
  }
  throw Error(p$2(156, b2.tag));
};
function Gk(a, b2) {
  return ac(a, b2);
}
function al(a, b2, c, d) {
  this.tag = a;
  this.key = c;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a, b2, c, d) {
  return new al(a, b2, c, d);
}
function bj(a) {
  a = a.prototype;
  return !(!a || !a.isReactComponent);
}
function $k(a) {
  if ("function" === typeof a)
    return bj(a) ? 1 : 0;
  if (void 0 !== a && null !== a) {
    a = a.$$typeof;
    if (a === Da)
      return 11;
    if (a === Ga)
      return 14;
  }
  return 2;
}
function wh(a, b2) {
  var c = a.alternate;
  null === c ? (c = Bg(a.tag, b2, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b2, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
  c.flags = a.flags & 14680064;
  c.childLanes = a.childLanes;
  c.lanes = a.lanes;
  c.child = a.child;
  c.memoizedProps = a.memoizedProps;
  c.memoizedState = a.memoizedState;
  c.updateQueue = a.updateQueue;
  b2 = a.dependencies;
  c.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c.sibling = a.sibling;
  c.index = a.index;
  c.ref = a.ref;
  return c;
}
function yh(a, b2, c, d, e2, f2) {
  var g2 = 2;
  d = a;
  if ("function" === typeof a)
    bj(a) && (g2 = 1);
  else if ("string" === typeof a)
    g2 = 5;
  else
    a:
      switch (a) {
        case ya:
          return Ah(c.children, e2, f2, b2);
        case za:
          g2 = 8;
          e2 |= 8;
          break;
        case Aa:
          return a = Bg(12, c, b2, e2 | 2), a.elementType = Aa, a.lanes = f2, a;
        case Ea:
          return a = Bg(13, c, b2, e2), a.elementType = Ea, a.lanes = f2, a;
        case Fa:
          return a = Bg(19, c, b2, e2), a.elementType = Fa, a.lanes = f2, a;
        case Ia:
          return qj(c, e2, f2, b2);
        default:
          if ("object" === typeof a && null !== a)
            switch (a.$$typeof) {
              case Ba:
                g2 = 10;
                break a;
              case Ca:
                g2 = 9;
                break a;
              case Da:
                g2 = 11;
                break a;
              case Ga:
                g2 = 14;
                break a;
              case Ha:
                g2 = 16;
                d = null;
                break a;
            }
          throw Error(p$2(130, null == a ? a : typeof a, ""));
      }
  b2 = Bg(g2, c, b2, e2);
  b2.elementType = a;
  b2.type = d;
  b2.lanes = f2;
  return b2;
}
function Ah(a, b2, c, d) {
  a = Bg(7, a, d, b2);
  a.lanes = c;
  return a;
}
function qj(a, b2, c, d) {
  a = Bg(22, a, d, b2);
  a.elementType = Ia;
  a.lanes = c;
  a.stateNode = { isHidden: false };
  return a;
}
function xh(a, b2, c) {
  a = Bg(6, a, null, b2);
  a.lanes = c;
  return a;
}
function zh(a, b2, c) {
  b2 = Bg(4, null !== a.children ? a.children : [], a.key, b2);
  b2.lanes = c;
  b2.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
  return b2;
}
function bl(a, b2, c, d, e2) {
  this.tag = b2;
  this.containerInfo = a;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d;
  this.onRecoverableError = e2;
  this.mutableSourceEagerHydrationData = null;
}
function cl(a, b2, c, d, e2, f2, g2, h2, k2) {
  a = new bl(a, b2, c, h2, k2);
  1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
  f2 = Bg(3, null, null, b2);
  a.current = f2;
  f2.stateNode = a;
  f2.memoizedState = { element: d, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  ah(f2);
  return a;
}
function dl(a, b2, c) {
  var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d ? null : "" + d, children: a, containerInfo: b2, implementation: c };
}
function el(a) {
  if (!a)
    return Vf;
  a = a._reactInternals;
  a: {
    if (Vb(a) !== a || 1 !== a.tag)
      throw Error(p$2(170));
    var b2 = a;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (null !== b2);
    throw Error(p$2(171));
  }
  if (1 === a.tag) {
    var c = a.type;
    if (Zf(c))
      return bg(a, c, b2);
  }
  return b2;
}
function fl(a, b2, c, d, e2, f2, g2, h2, k2) {
  a = cl(c, d, true, a, e2, f2, g2, h2, k2);
  a.context = el(null);
  c = a.current;
  d = L$1();
  e2 = lh(c);
  f2 = ch(d, e2);
  f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
  dh(c, f2, e2);
  a.current.lanes = e2;
  Ac(a, e2, d);
  Ek(a, d);
  return a;
}
function gl(a, b2, c, d) {
  var e2 = b2.current, f2 = L$1(), g2 = lh(e2);
  c = el(c);
  null === b2.context ? b2.context = c : b2.pendingContext = c;
  b2 = ch(f2, g2);
  b2.payload = { element: a };
  d = void 0 === d ? null : d;
  null !== d && (b2.callback = d);
  a = dh(e2, b2, g2);
  null !== a && (mh(a, e2, g2, f2), eh(a, e2, g2));
  return g2;
}
function hl(a) {
  a = a.current;
  if (!a.child)
    return null;
  switch (a.child.tag) {
    case 5:
      return a.child.stateNode;
    default:
      return a.child.stateNode;
  }
}
function il(a, b2) {
  a = a.memoizedState;
  if (null !== a && null !== a.dehydrated) {
    var c = a.retryLane;
    a.retryLane = 0 !== c && c < b2 ? c : b2;
  }
}
function jl(a, b2) {
  il(a, b2);
  (a = a.alternate) && il(a, b2);
}
function kl() {
  return null;
}
var ll = "function" === typeof reportError ? reportError : function(a) {
  console.error(a);
};
function ml(a) {
  this._internalRoot = a;
}
nl.prototype.render = ml.prototype.render = function(a) {
  var b2 = this._internalRoot;
  if (null === b2)
    throw Error(p$2(409));
  gl(a, b2, null, null);
};
nl.prototype.unmount = ml.prototype.unmount = function() {
  var a = this._internalRoot;
  if (null !== a) {
    this._internalRoot = null;
    var b2 = a.containerInfo;
    Sk(function() {
      gl(null, a, null, null);
    });
    b2[uf] = null;
  }
};
function nl(a) {
  this._internalRoot = a;
}
nl.prototype.unstable_scheduleHydration = function(a) {
  if (a) {
    var b2 = Hc();
    a = { blockedOn: null, target: a, priority: b2 };
    for (var c = 0; c < Qc.length && 0 !== b2 && b2 < Qc[c].priority; c++)
      ;
    Qc.splice(c, 0, a);
    0 === c && Vc(a);
  }
};
function ol(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
}
function pl(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
}
function ql() {
}
function rl(a, b2, c, d, e2) {
  if (e2) {
    if ("function" === typeof d) {
      var f2 = d;
      d = function() {
        var a2 = hl(g2);
        f2.call(a2);
      };
    }
    var g2 = fl(b2, d, a, 0, null, false, false, "", ql);
    a._reactRootContainer = g2;
    a[uf] = g2.current;
    sf(8 === a.nodeType ? a.parentNode : a);
    Sk();
    return g2;
  }
  for (; e2 = a.lastChild; )
    a.removeChild(e2);
  if ("function" === typeof d) {
    var h2 = d;
    d = function() {
      var a2 = hl(k2);
      h2.call(a2);
    };
  }
  var k2 = cl(a, 0, false, null, null, false, false, "", ql);
  a._reactRootContainer = k2;
  a[uf] = k2.current;
  sf(8 === a.nodeType ? a.parentNode : a);
  Sk(function() {
    gl(b2, k2, c, d);
  });
  return k2;
}
function sl(a, b2, c, d, e2) {
  var f2 = c._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if ("function" === typeof e2) {
      var h2 = e2;
      e2 = function() {
        var a2 = hl(g2);
        h2.call(a2);
      };
    }
    gl(b2, g2, a, e2);
  } else
    g2 = rl(c, b2, a, e2, d);
  return hl(g2);
}
Ec = function(a) {
  switch (a.tag) {
    case 3:
      var b2 = a.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c = tc(b2.pendingLanes);
        0 !== c && (Cc(b2, c | 1), Ek(b2, B$1()), 0 === (K$2 & 6) && (Hj = B$1() + 500, jg()));
      }
      break;
    case 13:
      Sk(function() {
        var b3 = Zg(a, 1);
        if (null !== b3) {
          var c2 = L$1();
          mh(b3, a, 1, c2);
        }
      }), jl(a, 1);
  }
};
Fc = function(a) {
  if (13 === a.tag) {
    var b2 = Zg(a, 134217728);
    if (null !== b2) {
      var c = L$1();
      mh(b2, a, 134217728, c);
    }
    jl(a, 134217728);
  }
};
Gc = function(a) {
  if (13 === a.tag) {
    var b2 = lh(a), c = Zg(a, b2);
    if (null !== c) {
      var d = L$1();
      mh(c, a, b2, d);
    }
    jl(a, b2);
  }
};
Hc = function() {
  return C$1;
};
Ic = function(a, b2) {
  var c = C$1;
  try {
    return C$1 = a, b2();
  } finally {
    C$1 = c;
  }
};
yb = function(a, b2, c) {
  switch (b2) {
    case "input":
      bb(a, c);
      b2 = c.name;
      if ("radio" === c.type && null != b2) {
        for (c = a; c.parentNode; )
          c = c.parentNode;
        c = c.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c.length; b2++) {
          var d = c[b2];
          if (d !== a && d.form === a.form) {
            var e2 = Db(d);
            if (!e2)
              throw Error(p$2(90));
            Wa(d);
            bb(d, e2);
          }
        }
      }
      break;
    case "textarea":
      ib(a, c);
      break;
    case "select":
      b2 = c.value, null != b2 && fb(a, !!c.multiple, b2, false);
  }
};
Gb = Rk;
Hb = Sk;
var tl = { usingClientEntryPoint: false, Events: [Cb, ue$1, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
  a = Zb(a);
  return null === a ? null : a.stateNode;
}, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!wl.isDisabled && wl.supportsFiber)
    try {
      kc = wl.inject(vl), lc = wl;
    } catch (a) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
reactDom_production_min.createPortal = function(a, b2) {
  var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!ol(b2))
    throw Error(p$2(200));
  return dl(a, b2, null, c);
};
reactDom_production_min.createRoot = function(a, b2) {
  if (!ol(a))
    throw Error(p$2(299));
  var c = false, d = "", e2 = ll;
  null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c = true), void 0 !== b2.identifierPrefix && (d = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
  b2 = cl(a, 1, false, null, null, c, false, d, e2);
  a[uf] = b2.current;
  sf(8 === a.nodeType ? a.parentNode : a);
  return new ml(b2);
};
reactDom_production_min.findDOMNode = function(a) {
  if (null == a)
    return null;
  if (1 === a.nodeType)
    return a;
  var b2 = a._reactInternals;
  if (void 0 === b2) {
    if ("function" === typeof a.render)
      throw Error(p$2(188));
    a = Object.keys(a).join(",");
    throw Error(p$2(268, a));
  }
  a = Zb(b2);
  a = null === a ? null : a.stateNode;
  return a;
};
reactDom_production_min.flushSync = function(a) {
  return Sk(a);
};
reactDom_production_min.hydrate = function(a, b2, c) {
  if (!pl(b2))
    throw Error(p$2(200));
  return sl(null, a, b2, true, c);
};
reactDom_production_min.hydrateRoot = function(a, b2, c) {
  if (!ol(a))
    throw Error(p$2(405));
  var d = null != c && c.hydratedSources || null, e2 = false, f2 = "", g2 = ll;
  null !== c && void 0 !== c && (true === c.unstable_strictMode && (e2 = true), void 0 !== c.identifierPrefix && (f2 = c.identifierPrefix), void 0 !== c.onRecoverableError && (g2 = c.onRecoverableError));
  b2 = fl(b2, null, a, 1, null != c ? c : null, e2, false, f2, g2);
  a[uf] = b2.current;
  sf(a);
  if (d)
    for (a = 0; a < d.length; a++)
      c = d[a], e2 = c._getVersion, e2 = e2(c._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c, e2] : b2.mutableSourceEagerHydrationData.push(
        c,
        e2
      );
  return new nl(b2);
};
reactDom_production_min.render = function(a, b2, c) {
  if (!pl(b2))
    throw Error(p$2(200));
  return sl(null, a, b2, false, c);
};
reactDom_production_min.unmountComponentAtNode = function(a) {
  if (!pl(a))
    throw Error(p$2(40));
  return a._reactRootContainer ? (Sk(function() {
    sl(null, null, a, false, function() {
      a._reactRootContainer = null;
      a[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Rk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b2, c, d) {
  if (!pl(c))
    throw Error(p$2(200));
  if (null == a || void 0 === a._reactInternals)
    throw Error(p$2(38));
  return sl(a, b2, c, false, d);
};
reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
var m$2 = reactDomExports;
{
  client$1.createRoot = m$2.createRoot;
  client$1.hydrateRoot = m$2.hydrateRoot;
}
const useIsomorphicLayoutEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function useInterval(callback, delay2) {
  const savedCallback = reactExports.useRef(callback);
  useIsomorphicLayoutEffect(() => {
    savedCallback.current = callback;
  }, [callback]);
  reactExports.useEffect(() => {
    if (delay2 === null) {
      return;
    }
    const id2 = setInterval(() => savedCallback.current(), delay2);
    return () => clearInterval(id2);
  }, [delay2]);
}
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
function toPrimitive(t2, r2) {
  if ("object" != _typeof(t2) || !t2)
    return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t2, r2 || "default");
    if ("object" != _typeof(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function toPropertyKey(t2) {
  var i = toPrimitive(t2, "string");
  return "symbol" == _typeof(i) ? i : String(i);
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function toArray$2(input) {
  return Array.isArray(input) ? input.slice(0) : [input];
}
function isMaybeReadonlyArray(x2) {
  return Array.isArray(x2);
}
function arrayFilterNotEmpty(value) {
  if (value === null || value === void 0) {
    return false;
  }
  return true;
}
function countUntilNotMatching(ar, matchingFn) {
  var count2 = 0;
  var idx = -1;
  for (var _item of ar) {
    idx = idx + 1;
    var matching = matchingFn(_item, idx);
    if (matching) {
      count2 = count2 + 1;
    } else {
      break;
    }
  }
  return count2;
}
function appendToArray(ar, add) {
  var amount = add.length;
  for (var i = 0; i < amount; ++i) {
    var element = add[i];
    ar.push(element);
  }
}
function uniqueArray(arrArg) {
  return arrArg.filter(function(elem, pos, arr) {
    return arr.indexOf(elem) === pos;
  });
}
function parseRevision(revision) {
  var split = revision.split("-");
  if (split.length !== 2) {
    throw new Error("malformatted revision: " + revision);
  }
  return {
    height: parseInt(split[0], 10),
    hash: split[1]
  };
}
function getHeightOfRevision(revision) {
  var ret = parseInt(revision.split("-")[0], 10);
  return ret;
}
function createRevision(databaseInstanceToken, previousDocData) {
  var previousRevision = previousDocData ? previousDocData._rev : null;
  var previousRevisionHeight = previousRevision ? parseRevision(previousRevision).height : 0;
  var newRevisionHeight = previousRevisionHeight + 1;
  return newRevisionHeight + "-" + databaseInstanceToken;
}
var RX_META_LWT_MINIMUM = 1;
function getDefaultRxDocumentMeta() {
  return {
    /**
     * Set this to 1 to not waste performance
     * while calling new Date()..
     * The storage wrappers will anyway update
     * the lastWrite time while calling transformDocumentDataFromRxDBToRxStorage()
     */
    lwt: RX_META_LWT_MINIMUM
  };
}
function getDefaultRevision() {
  return "";
}
function stripMetaDataFromDocument(docData) {
  return Object.assign({}, docData, {
    _meta: void 0,
    _deleted: void 0,
    _rev: void 0
  });
}
function areRxDocumentArraysEqual(primaryPath, ar1, ar2) {
  if (ar1.length !== ar2.length) {
    return false;
  }
  var i = 0;
  var len = ar1.length;
  while (i < len) {
    var row1 = ar1[i];
    var row2 = ar2[i];
    i++;
    if (row1._rev !== row2._rev || row1[primaryPath] !== row2[primaryPath]) {
      return false;
    }
  }
  return true;
}
class WordArray {
  constructor(words, sigBytes) {
    words = this.words = words || [];
    this.sigBytes = sigBytes === void 0 ? words.length * 4 : sigBytes;
  }
  toString(encoder) {
    return (encoder || Hex).stringify(this);
  }
  concat(wordArray) {
    this.clamp();
    if (this.sigBytes % 4) {
      for (let i = 0; i < wordArray.sigBytes; i++) {
        const thatByte = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
        this.words[this.sigBytes + i >>> 2] |= thatByte << 24 - (this.sigBytes + i) % 4 * 8;
      }
    } else {
      for (let j2 = 0; j2 < wordArray.sigBytes; j2 += 4) {
        this.words[this.sigBytes + j2 >>> 2] = wordArray.words[j2 >>> 2];
      }
    }
    this.sigBytes += wordArray.sigBytes;
    return this;
  }
  clamp() {
    this.words[this.sigBytes >>> 2] &= 4294967295 << 32 - this.sigBytes % 4 * 8;
    this.words.length = Math.ceil(this.sigBytes / 4);
  }
  clone() {
    return new WordArray([...this.words]);
  }
}
const Hex = {
  stringify(wordArray) {
    const hexChars = [];
    for (let i = 0; i < wordArray.sigBytes; i++) {
      const bite = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
      hexChars.push((bite >>> 4).toString(16), (bite & 15).toString(16));
    }
    return hexChars.join("");
  }
};
const Latin1 = {
  parse(latin1Str) {
    const latin1StrLength = latin1Str.length;
    const words = [];
    for (let i = 0; i < latin1StrLength; i++) {
      words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
    }
    return new WordArray(words, latin1StrLength);
  }
};
const Utf8 = {
  parse(utf8Str) {
    return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
  }
};
class BufferedBlockAlgorithm {
  constructor() {
    this._data = new WordArray();
    this._nDataBytes = 0;
    this._minBufferSize = 0;
    this.blockSize = 512 / 32;
  }
  reset() {
    this._data = new WordArray();
    this._nDataBytes = 0;
  }
  _append(data) {
    if (typeof data === "string") {
      data = Utf8.parse(data);
    }
    this._data.concat(data);
    this._nDataBytes += data.sigBytes;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _doProcessBlock(_dataWords, _offset) {
  }
  _process(doFlush) {
    let processedWords;
    let nBlocksReady = this._data.sigBytes / (this.blockSize * 4);
    if (doFlush) {
      nBlocksReady = Math.ceil(nBlocksReady);
    } else {
      nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
    }
    const nWordsReady = nBlocksReady * this.blockSize;
    const nBytesReady = Math.min(nWordsReady * 4, this._data.sigBytes);
    if (nWordsReady) {
      for (let offset = 0; offset < nWordsReady; offset += this.blockSize) {
        this._doProcessBlock(this._data.words, offset);
      }
      processedWords = this._data.words.splice(0, nWordsReady);
      this._data.sigBytes -= nBytesReady;
    }
    return new WordArray(processedWords, nBytesReady);
  }
}
class Hasher extends BufferedBlockAlgorithm {
  update(messageUpdate) {
    this._append(messageUpdate);
    this._process();
    return this;
  }
  finalize(messageUpdate) {
    if (messageUpdate) {
      this._append(messageUpdate);
    }
  }
}
const H$1 = [
  1779033703,
  -1150833019,
  1013904242,
  -1521486534,
  1359893119,
  -1694144372,
  528734635,
  1541459225
];
const K$1 = [
  1116352408,
  1899447441,
  -1245643825,
  -373957723,
  961987163,
  1508970993,
  -1841331548,
  -1424204075,
  -670586216,
  310598401,
  607225278,
  1426881987,
  1925078388,
  -2132889090,
  -1680079193,
  -1046744716,
  -459576895,
  -272742522,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  -1740746414,
  -1473132947,
  -1341970488,
  -1084653625,
  -958395405,
  -710438585,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  -2117940946,
  -1838011259,
  -1564481375,
  -1474664885,
  -1035236496,
  -949202525,
  -778901479,
  -694614492,
  -200395387,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  -2067236844,
  -1933114872,
  -1866530822,
  -1538233109,
  -1090935817,
  -965641998
];
const W$1 = [];
class SHA256 extends Hasher {
  constructor() {
    super(...arguments);
    this._hash = new WordArray([...H$1]);
  }
  reset() {
    super.reset();
    this._hash = new WordArray([...H$1]);
  }
  _doProcessBlock(M2, offset) {
    const H2 = this._hash.words;
    let a = H2[0];
    let b2 = H2[1];
    let c = H2[2];
    let d = H2[3];
    let e2 = H2[4];
    let f2 = H2[5];
    let g2 = H2[6];
    let h2 = H2[7];
    for (let i = 0; i < 64; i++) {
      if (i < 16) {
        W$1[i] = M2[offset + i] | 0;
      } else {
        const gamma0x = W$1[i - 15];
        const gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
        const gamma1x = W$1[i - 2];
        const gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
        W$1[i] = gamma0 + W$1[i - 7] + gamma1 + W$1[i - 16];
      }
      const ch2 = e2 & f2 ^ ~e2 & g2;
      const maj = a & b2 ^ a & c ^ b2 & c;
      const sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
      const sigma1 = (e2 << 26 | e2 >>> 6) ^ (e2 << 21 | e2 >>> 11) ^ (e2 << 7 | e2 >>> 25);
      const t1 = h2 + sigma1 + ch2 + K$1[i] + W$1[i];
      const t2 = sigma0 + maj;
      h2 = g2;
      g2 = f2;
      f2 = e2;
      e2 = d + t1 | 0;
      d = c;
      c = b2;
      b2 = a;
      a = t1 + t2 | 0;
    }
    H2[0] = H2[0] + a | 0;
    H2[1] = H2[1] + b2 | 0;
    H2[2] = H2[2] + c | 0;
    H2[3] = H2[3] + d | 0;
    H2[4] = H2[4] + e2 | 0;
    H2[5] = H2[5] + f2 | 0;
    H2[6] = H2[6] + g2 | 0;
    H2[7] = H2[7] + h2 | 0;
  }
  finalize(messageUpdate) {
    super.finalize(messageUpdate);
    const nBitsTotal = this._nDataBytes * 8;
    const nBitsLeft = this._data.sigBytes * 8;
    this._data.words[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
    this._data.words[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(
      nBitsTotal / 4294967296
    );
    this._data.words[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
    this._data.sigBytes = this._data.words.length * 4;
    this._process();
    return this._hash;
  }
}
function sha256(message) {
  return new SHA256().finalize(message).toString();
}
function jsSha256(input) {
  return Promise.resolve(sha256(input));
}
async function nativeSha256(input) {
  var data = new TextEncoder().encode(input);
  var hashBuffer = await crypto.subtle.digest("SHA-256", data);
  var hash2 = Array.prototype.map.call(new Uint8Array(hashBuffer), (x2) => ("00" + x2.toString(16)).slice(-2)).join("");
  return hash2;
}
var canUseCryptoSubtle = typeof crypto !== "undefined" && typeof crypto.subtle !== "undefined" && typeof crypto.subtle.digest === "function";
var defaultHashSha256 = canUseCryptoSubtle ? nativeSha256 : jsSha256;
function nextTick() {
  return new Promise((res) => setTimeout(res, 0));
}
function promiseWait(ms = 0) {
  return new Promise((res) => setTimeout(res, ms));
}
Promise.resolve(true);
var PROMISE_RESOLVE_FALSE = Promise.resolve(false);
var PROMISE_RESOLVE_NULL = Promise.resolve(null);
var PROMISE_RESOLVE_VOID = Promise.resolve();
function requestIdlePromiseNoQueue(timeout2 = 1e4) {
  if (typeof requestIdleCallback === "function") {
    return new Promise((res) => {
      requestIdleCallback(() => res(), {
        timeout: timeout2
      });
    });
  } else {
    return promiseWait(0);
  }
}
var idlePromiseQueue = PROMISE_RESOLVE_VOID;
function requestIdlePromise(timeout2 = void 0) {
  idlePromiseQueue = idlePromiseQueue.then(() => {
    return requestIdlePromiseNoQueue(timeout2);
  });
  return idlePromiseQueue;
}
function promiseSeries(tasks, initial) {
  return tasks.reduce((current, next2) => current.then(next2), Promise.resolve(initial));
}
var REGEX_ALL_DOTS = /\./g;
var COUCH_NAME_CHARS = "abcdefghijklmnopqrstuvwxyz";
function randomCouchString(length2 = 10) {
  var text = "";
  for (var i = 0; i < length2; i++) {
    text += COUCH_NAME_CHARS.charAt(Math.floor(Math.random() * COUCH_NAME_CHARS.length));
  }
  return text;
}
function ucfirst(str) {
  str += "";
  var f2 = str.charAt(0).toUpperCase();
  return f2 + str.substr(1);
}
function trimDots(str) {
  while (str.charAt(0) === ".") {
    str = str.substr(1);
  }
  while (str.slice(-1) === ".") {
    str = str.slice(0, -1);
  }
  return str;
}
function isFolderPath(name) {
  if (name.includes("/") || // unix
  name.includes("\\")) {
    return true;
  } else {
    return false;
  }
}
function deepEqual(a, b2) {
  if (a === b2)
    return true;
  if (a && b2 && typeof a == "object" && typeof b2 == "object") {
    if (a.constructor !== b2.constructor)
      return false;
    var length2;
    var i;
    if (Array.isArray(a)) {
      length2 = a.length;
      if (length2 !== b2.length)
        return false;
      for (i = length2; i-- !== 0; )
        if (!deepEqual(a[i], b2[i]))
          return false;
      return true;
    }
    if (a.constructor === RegExp)
      return a.source === b2.source && a.flags === b2.flags;
    if (a.valueOf !== Object.prototype.valueOf)
      return a.valueOf() === b2.valueOf();
    if (a.toString !== Object.prototype.toString)
      return a.toString() === b2.toString();
    var keys = Object.keys(a);
    length2 = keys.length;
    if (length2 !== Object.keys(b2).length)
      return false;
    for (i = length2; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b2, keys[i]))
        return false;
    for (i = length2; i-- !== 0; ) {
      var key = keys[i];
      if (!deepEqual(a[key], b2[key]))
        return false;
    }
    return true;
  }
  return a !== a && b2 !== b2;
}
var isObject$3 = (value) => {
  var type2 = typeof value;
  return value !== null && (type2 === "object" || type2 === "function");
};
var disallowedKeys = /* @__PURE__ */ new Set(["__proto__", "prototype", "constructor"]);
var digits = new Set("0123456789");
function getPathSegments(path) {
  var parts = [];
  var currentSegment = "";
  var currentPart = "start";
  var isIgnoring = false;
  for (var character2 of path) {
    switch (character2) {
      case "\\": {
        if (currentPart === "index") {
          throw new Error("Invalid character in an index");
        }
        if (currentPart === "indexEnd") {
          throw new Error("Invalid character after an index");
        }
        if (isIgnoring) {
          currentSegment += character2;
        }
        currentPart = "property";
        isIgnoring = !isIgnoring;
        break;
      }
      case ".": {
        if (currentPart === "index") {
          throw new Error("Invalid character in an index");
        }
        if (currentPart === "indexEnd") {
          currentPart = "property";
          break;
        }
        if (isIgnoring) {
          isIgnoring = false;
          currentSegment += character2;
          break;
        }
        if (disallowedKeys.has(currentSegment)) {
          return [];
        }
        parts.push(currentSegment);
        currentSegment = "";
        currentPart = "property";
        break;
      }
      case "[": {
        if (currentPart === "index") {
          throw new Error("Invalid character in an index");
        }
        if (currentPart === "indexEnd") {
          currentPart = "index";
          break;
        }
        if (isIgnoring) {
          isIgnoring = false;
          currentSegment += character2;
          break;
        }
        if (currentPart === "property") {
          if (disallowedKeys.has(currentSegment)) {
            return [];
          }
          parts.push(currentSegment);
          currentSegment = "";
        }
        currentPart = "index";
        break;
      }
      case "]": {
        if (currentPart === "index") {
          parts.push(Number.parseInt(currentSegment, 10));
          currentSegment = "";
          currentPart = "indexEnd";
          break;
        }
        if (currentPart === "indexEnd") {
          throw new Error("Invalid character after an index");
        }
      }
      default: {
        if (currentPart === "index" && !digits.has(character2)) {
          throw new Error("Invalid character in an index");
        }
        if (currentPart === "indexEnd") {
          throw new Error("Invalid character after an index");
        }
        if (currentPart === "start") {
          currentPart = "property";
        }
        if (isIgnoring) {
          isIgnoring = false;
          currentSegment += "\\";
        }
        currentSegment += character2;
      }
    }
  }
  if (isIgnoring) {
    currentSegment += "\\";
  }
  switch (currentPart) {
    case "property": {
      if (disallowedKeys.has(currentSegment)) {
        return [];
      }
      parts.push(currentSegment);
      break;
    }
    case "index": {
      throw new Error("Index was not closed");
    }
    case "start": {
      parts.push("");
      break;
    }
  }
  return parts;
}
function isStringIndex$1(object, key) {
  if (typeof key !== "number" && Array.isArray(object)) {
    var index = Number.parseInt(key, 10);
    return Number.isInteger(index) && object[index] === object[key];
  }
  return false;
}
function assertNotStringIndex(object, key) {
  if (isStringIndex$1(object, key)) {
    throw new Error("Cannot use string index");
  }
}
function getProperty$1(object, path, value) {
  if (Array.isArray(path)) {
    path = path.join(".");
  }
  if (!path.includes(".") && !path.includes("[")) {
    return object[path];
  }
  if (!isObject$3(object) || typeof path !== "string") {
    return value === void 0 ? object : value;
  }
  var pathArray = getPathSegments(path);
  if (pathArray.length === 0) {
    return value;
  }
  for (var index = 0; index < pathArray.length; index++) {
    var key = pathArray[index];
    if (isStringIndex$1(object, key)) {
      object = index === pathArray.length - 1 ? void 0 : null;
    } else {
      object = object[key];
    }
    if (object === void 0 || object === null) {
      if (index !== pathArray.length - 1) {
        return value;
      }
      break;
    }
  }
  return object === void 0 ? value : object;
}
function setProperty(object, path, value) {
  if (Array.isArray(path)) {
    path = path.join(".");
  }
  if (!isObject$3(object) || typeof path !== "string") {
    return object;
  }
  var root = object;
  var pathArray = getPathSegments(path);
  for (var index = 0; index < pathArray.length; index++) {
    var key = pathArray[index];
    assertNotStringIndex(object, key);
    if (index === pathArray.length - 1) {
      object[key] = value;
    } else if (!isObject$3(object[key])) {
      object[key] = typeof pathArray[index + 1] === "number" ? [] : {};
    }
    object = object[key];
  }
  return root;
}
function deepFreeze(o) {
  Object.freeze(o);
  Object.getOwnPropertyNames(o).forEach(function(prop) {
    if (Object.prototype.hasOwnProperty.call(o, prop) && o[prop] !== null && (typeof o[prop] === "object" || typeof o[prop] === "function") && !Object.isFrozen(o[prop])) {
      deepFreeze(o[prop]);
    }
  });
  return o;
}
function objectPathMonad(objectPath) {
  var split = objectPath.split(".");
  var splitLength = split.length;
  if (splitLength === 1) {
    return (obj) => obj[objectPath];
  }
  return (obj) => {
    var currentVal = obj;
    for (var i = 0; i < splitLength; ++i) {
      var subPath = split[i];
      currentVal = currentVal[subPath];
      if (typeof currentVal === "undefined") {
        return currentVal;
      }
    }
    return currentVal;
  };
}
function flattenObject(ob2) {
  var toReturn = {};
  for (var i in ob2) {
    if (!Object.prototype.hasOwnProperty.call(ob2, i))
      continue;
    if (typeof ob2[i] === "object") {
      var flatObject = flattenObject(ob2[i]);
      for (var x2 in flatObject) {
        if (!Object.prototype.hasOwnProperty.call(flatObject, x2))
          continue;
        toReturn[i + "." + x2] = flatObject[x2];
      }
    } else {
      toReturn[i] = ob2[i];
    }
  }
  return toReturn;
}
function flatClone(obj) {
  return Object.assign({}, obj);
}
function firstPropertyNameOfObject(obj) {
  return Object.keys(obj)[0];
}
function sortObject(obj, noArraySort = false) {
  if (!obj)
    return obj;
  if (!noArraySort && Array.isArray(obj)) {
    return obj.sort((a, b2) => {
      if (typeof a === "string" && typeof b2 === "string")
        return a.localeCompare(b2);
      if (typeof a === "object")
        return 1;
      else
        return -1;
    }).map((i) => sortObject(i, noArraySort));
  }
  if (typeof obj === "object" && !Array.isArray(obj)) {
    var out = {};
    Object.keys(obj).sort((a, b2) => a.localeCompare(b2)).forEach((key) => {
      out[key] = sortObject(obj[key], noArraySort);
    });
    return out;
  }
  return obj;
}
function deepClone(src) {
  if (!src) {
    return src;
  }
  if (src === null || typeof src !== "object") {
    return src;
  }
  if (Array.isArray(src)) {
    var ret = new Array(src.length);
    var i = ret.length;
    while (i--) {
      ret[i] = deepClone(src[i]);
    }
    return ret;
  }
  var dest = {};
  for (var key in src) {
    dest[key] = deepClone(src[key]);
  }
  return dest;
}
var clone = deepClone;
function overwriteGetterForCaching(obj, getterName, value) {
  Object.defineProperty(obj, getterName, {
    get: function() {
      return value;
    }
  });
  return value;
}
function getFromMapOrThrow(map2, key) {
  var val = map2.get(key);
  if (typeof val === "undefined") {
    throw new Error("missing value from map " + key);
  }
  return val;
}
function getFromMapOrCreate(map2, index, creator, ifWasThere) {
  var value = map2.get(index);
  if (typeof value === "undefined") {
    value = creator();
    map2.set(index, value);
  } else if (ifWasThere) {
    ifWasThere(value);
  }
  return value;
}
function pluginMissing(pluginKey) {
  var keyParts = pluginKey.split("-");
  var pluginName = "RxDB";
  keyParts.forEach((part) => {
    pluginName += ucfirst(part);
  });
  pluginName += "Plugin";
  return new Error("You are using a function which must be overwritten by a plugin.\n        You should either prevent the usage of this function or add the plugin via:\n            import { " + pluginName + " } from 'rxdb/plugins/" + pluginKey + "';\n            addRxPlugin(" + pluginName + ");\n        ");
}
var _lastNow = 0;
function now$1() {
  var ret = Date.now();
  ret = ret + 0.01;
  if (ret <= _lastNow) {
    ret = _lastNow + 0.01;
  }
  var twoDecimals = parseFloat(ret.toFixed(2));
  _lastNow = twoDecimals;
  return twoDecimals;
}
function ensureNotFalsy(obj, message) {
  if (!obj) {
    if (!message) {
      message = "";
    }
    throw new Error("ensureNotFalsy() is falsy: " + message);
  }
  return obj;
}
var RXJS_SHARE_REPLAY_DEFAULTS = {
  bufferSize: 1,
  refCount: true
};
var RXDB_VERSION = "15.4.0";
function _setPrototypeOf(o, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf(o, p2);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _isNativeFunction(fn) {
  try {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  } catch (e2) {
    return typeof fn === "function";
  }
}
function _isNativeReflectConstruct() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
    return !!t2;
  })();
}
function _construct(t2, e2, r2) {
  if (_isNativeReflectConstruct())
    return Reflect.construct.apply(null, arguments);
  var o = [null];
  o.push.apply(o, e2);
  var p2 = new (t2.bind.apply(t2, o))();
  return r2 && _setPrototypeOf(p2, r2.prototype), p2;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
var overwritable = {
  /**
   * if this method is overwritten with one
   * that returns true, we do additional checks
   * which help the developer but have bad performance
   */
  isDevMode() {
    return false;
  },
  /**
   * Deep freezes and object when in dev-mode.
   * Deep-Freezing has the same performance as deep-cloning, so we only do that in dev-mode.
   * Also, we can ensure the readonly state via typescript
   * @link https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze
   */
  deepFreezeWhenDevMode(obj) {
    return obj;
  },
  /**
   * overwritten to map error-codes to text-messages
   */
  tunnelErrorMessage(message) {
    return "RxDB Error-Code " + message + ".\n        Error messages are not included in RxDB core to reduce build size.\n        - To find out what this error means, either use the dev-mode-plugin https://rxdb.info/dev-mode.html\n        - or search for the error code here: https://github.com/pubkey/rxdb/search?q=" + message + "\n        ";
  }
};
function parametersToString(parameters) {
  var ret = "";
  if (Object.keys(parameters).length === 0)
    return ret;
  ret += "Given parameters: {\n";
  ret += Object.keys(parameters).map((k2) => {
    var paramStr = "[object Object]";
    try {
      if (k2 === "errors") {
        paramStr = parameters[k2].map((err) => JSON.stringify(err, Object.getOwnPropertyNames(err)));
      } else {
        paramStr = JSON.stringify(parameters[k2], function(_k, v2) {
          return v2 === void 0 ? null : v2;
        }, 2);
      }
    } catch (e2) {
    }
    return k2 + ":" + paramStr;
  }).join("\n");
  ret += "}";
  return ret;
}
function messageForError(message, code, parameters) {
  return "RxError (" + code + "):\n" + message + "\n" + parametersToString(parameters);
}
var RxError = /* @__PURE__ */ function(_Error) {
  _inheritsLoose(RxError2, _Error);
  function RxError2(code, message, parameters = {}) {
    var _this;
    var mes = messageForError(message, code, parameters);
    _this = _Error.call(this, mes) || this;
    _this.code = code;
    _this.message = mes;
    _this.parameters = parameters;
    _this.rxdb = true;
    return _this;
  }
  var _proto = RxError2.prototype;
  _proto.toString = function toString2() {
    return this.message;
  };
  _createClass(RxError2, [{
    key: "name",
    get: function() {
      return "RxError (" + this.code + ")";
    }
  }, {
    key: "typeError",
    get: function() {
      return false;
    }
  }]);
  return RxError2;
}(/* @__PURE__ */ _wrapNativeSuper(Error));
var RxTypeError = /* @__PURE__ */ function(_TypeError) {
  _inheritsLoose(RxTypeError2, _TypeError);
  function RxTypeError2(code, message, parameters = {}) {
    var _this2;
    var mes = messageForError(message, code, parameters);
    _this2 = _TypeError.call(this, mes) || this;
    _this2.code = code;
    _this2.message = mes;
    _this2.parameters = parameters;
    _this2.rxdb = true;
    return _this2;
  }
  var _proto2 = RxTypeError2.prototype;
  _proto2.toString = function toString2() {
    return this.message;
  };
  _createClass(RxTypeError2, [{
    key: "name",
    get: function() {
      return "RxTypeError (" + this.code + ")";
    }
  }, {
    key: "typeError",
    get: function() {
      return true;
    }
  }]);
  return RxTypeError2;
}(/* @__PURE__ */ _wrapNativeSuper(TypeError));
function newRxError(code, parameters) {
  return new RxError(code, overwritable.tunnelErrorMessage(code), parameters);
}
function newRxTypeError(code, parameters) {
  return new RxTypeError(code, overwritable.tunnelErrorMessage(code), parameters);
}
function isBulkWriteConflictError(err) {
  if (err && err.status === 409) {
    return err;
  } else {
    return false;
  }
}
var STORAGE_WRITE_ERROR_CODE_TO_MESSAGE = {
  409: "document write conflict",
  422: "schema validation error",
  510: "attachment data missing"
};
function rxStorageWriteErrorToRxError(err) {
  return newRxError("COL20", {
    name: STORAGE_WRITE_ERROR_CODE_TO_MESSAGE[err.status],
    document: err.documentId,
    writeError: err
  });
}
var HOOKS = {
  /**
   * Runs before a plugin is added.
   * Use this to block the usage of non-compatible plugins.
   */
  preAddRxPlugin: [],
  /**
   * functions that run before the database is created
   */
  preCreateRxDatabase: [],
  /**
   * runs after the database is created and prepared
   * but before the instance is returned to the user
   * @async
   */
  createRxDatabase: [],
  preCreateRxCollection: [],
  createRxCollection: [],
  /**
  * runs at the end of the destroy-process of a collection
  * @async
  */
  postDestroyRxCollection: [],
  /**
   * Runs after a collection is removed.
   * @async
   */
  postRemoveRxCollection: [],
  /**
    * functions that get the json-schema as input
    * to do additionally checks/manipulation
    */
  preCreateRxSchema: [],
  /**
   * functions that run after the RxSchema is created
   * gets RxSchema as attribute
   */
  createRxSchema: [],
  preCreateRxQuery: [],
  /**
   * Runs before a query is send to the
   * prepareQuery function of the storage engine.
   */
  prePrepareQuery: [],
  createRxDocument: [],
  /**
   * runs after a RxDocument is created,
   * cannot be async
   */
  postCreateRxDocument: [],
  /**
   * Runs before a RxStorageInstance is created
   * gets the params of createStorageInstance()
   * as attribute so you can manipulate them.
   * Notice that you have to clone stuff before mutating the inputs.
   */
  preCreateRxStorageInstance: [],
  /**
   * runs on the document-data before the document is migrated
   * {
   *   doc: Object, // original doc-data
   *   migrated: // migrated doc-data after run through migration-strategies
   * }
   */
  preMigrateDocument: [],
  /**
   * runs after the migration of a document has been done
   */
  postMigrateDocument: [],
  /**
   * runs at the beginning of the destroy-process of a database
   */
  preDestroyRxDatabase: [],
  /**
   * runs after a database has been removed
   * @async
   */
  postRemoveRxDatabase: [],
  /**
   * runs before the replication writes the rows to master
   * but before the rows have been modified
   * @async
   */
  preReplicationMasterWrite: [],
  /**
   * runs after the replication has been sent to the server
   * but before the new documents have been handled
   * @async
   */
  preReplicationMasterWriteDocumentsHandle: []
};
function runPluginHooks(hookKey, obj) {
  if (HOOKS[hookKey]) {
    HOOKS[hookKey].forEach((fun) => fun(obj));
  }
}
function runAsyncPluginHooks(hookKey, obj) {
  return Promise.all(HOOKS[hookKey].map((fun) => fun(obj)));
}
function getSchemaByObjectPath(rxJsonSchema, path) {
  var usePath = path;
  usePath = usePath.replace(REGEX_ALL_DOTS, ".properties.");
  usePath = "properties." + usePath;
  usePath = trimDots(usePath);
  var ret = getProperty$1(rxJsonSchema, usePath);
  return ret;
}
function fillPrimaryKey(primaryPath, jsonSchema, documentData) {
  if (typeof jsonSchema.primaryKey === "string") {
    return documentData;
  }
  var newPrimary = getComposedPrimaryKeyOfDocumentData(jsonSchema, documentData);
  var existingPrimary = documentData[primaryPath];
  if (existingPrimary && existingPrimary !== newPrimary) {
    throw newRxError("DOC19", {
      args: {
        documentData,
        existingPrimary,
        newPrimary
      },
      schema: jsonSchema
    });
  }
  documentData[primaryPath] = newPrimary;
  return documentData;
}
function getPrimaryFieldOfPrimaryKey(primaryKey) {
  if (typeof primaryKey === "string") {
    return primaryKey;
  } else {
    return primaryKey.key;
  }
}
function getComposedPrimaryKeyOfDocumentData(jsonSchema, documentData) {
  if (typeof jsonSchema.primaryKey === "string") {
    return documentData[jsonSchema.primaryKey];
  }
  var compositePrimary = jsonSchema.primaryKey;
  return compositePrimary.fields.map((field) => {
    var value = getProperty$1(documentData, field);
    if (typeof value === "undefined") {
      throw newRxError("DOC18", {
        args: {
          field,
          documentData
        }
      });
    }
    return value;
  }).join(compositePrimary.separator);
}
function normalizeRxJsonSchema(jsonSchema) {
  var normalizedSchema = sortObject(jsonSchema, true);
  return normalizedSchema;
}
function getDefaultIndex(primaryPath) {
  return ["_deleted", primaryPath];
}
function fillWithDefaultSettings(schemaObj) {
  schemaObj = flatClone(schemaObj);
  var primaryPath = getPrimaryFieldOfPrimaryKey(schemaObj.primaryKey);
  schemaObj.properties = flatClone(schemaObj.properties);
  schemaObj.additionalProperties = false;
  if (!Object.prototype.hasOwnProperty.call(schemaObj, "keyCompression")) {
    schemaObj.keyCompression = false;
  }
  schemaObj.indexes = schemaObj.indexes ? schemaObj.indexes.slice(0) : [];
  schemaObj.required = schemaObj.required ? schemaObj.required.slice(0) : [];
  schemaObj.encrypted = schemaObj.encrypted ? schemaObj.encrypted.slice(0) : [];
  schemaObj.properties._rev = {
    type: "string",
    minLength: 1
  };
  schemaObj.properties._attachments = {
    type: "object"
  };
  schemaObj.properties._deleted = {
    type: "boolean"
  };
  schemaObj.properties._meta = RX_META_SCHEMA;
  schemaObj.required = schemaObj.required ? schemaObj.required.slice(0) : [];
  schemaObj.required.push("_deleted");
  schemaObj.required.push("_rev");
  schemaObj.required.push("_meta");
  schemaObj.required.push("_attachments");
  var finalFields = getFinalFields(schemaObj);
  appendToArray(schemaObj.required, finalFields);
  schemaObj.required = schemaObj.required.filter((field) => !field.includes(".")).filter((elem, pos, arr) => arr.indexOf(elem) === pos);
  schemaObj.version = schemaObj.version || 0;
  var useIndexes = schemaObj.indexes.map((index) => {
    var arIndex = isMaybeReadonlyArray(index) ? index.slice(0) : [index];
    if (!arIndex.includes(primaryPath)) {
      arIndex.push(primaryPath);
    }
    if (arIndex[0] !== "_deleted") {
      arIndex.unshift("_deleted");
    }
    return arIndex;
  });
  if (useIndexes.length === 0) {
    useIndexes.push(getDefaultIndex(primaryPath));
  }
  useIndexes.push(["_meta.lwt", primaryPath]);
  if (schemaObj.internalIndexes) {
    schemaObj.internalIndexes.map((idx) => {
      useIndexes.push(idx);
    });
  }
  var hasIndex = /* @__PURE__ */ new Set();
  useIndexes.filter((index) => {
    var indexStr = index.join(",");
    if (hasIndex.has(indexStr)) {
      return false;
    } else {
      hasIndex.add(indexStr);
      return true;
    }
  });
  schemaObj.indexes = useIndexes;
  return schemaObj;
}
var RX_META_SCHEMA = {
  type: "object",
  properties: {
    /**
     * The last-write time.
     * Unix time in milliseconds.
     */
    lwt: {
      type: "number",
      /**
       * We use 1 as minimum so that the value is never falsy.
       */
      minimum: RX_META_LWT_MINIMUM,
      maximum: 1e15,
      multipleOf: 0.01
    }
  },
  /**
   * Additional properties are allowed
   * and can be used by plugins to set various flags.
   */
  additionalProperties: true,
  required: ["lwt"]
};
function getFinalFields(jsonSchema) {
  var ret = Object.keys(jsonSchema.properties).filter((key) => jsonSchema.properties[key].final);
  var primaryPath = getPrimaryFieldOfPrimaryKey(jsonSchema.primaryKey);
  ret.push(primaryPath);
  if (typeof jsonSchema.primaryKey !== "string") {
    jsonSchema.primaryKey.fields.forEach((field) => ret.push(field));
  }
  return ret;
}
function fillObjectWithDefaults(rxSchema, obj) {
  var defaultKeys = Object.keys(rxSchema.defaultValues);
  for (var i = 0; i < defaultKeys.length; ++i) {
    var key = defaultKeys[i];
    if (!Object.prototype.hasOwnProperty.call(obj, key) || typeof obj[key] === "undefined") {
      obj[key] = rxSchema.defaultValues[key];
    }
  }
  return obj;
}
var RxSchema = /* @__PURE__ */ function() {
  function RxSchema2(jsonSchema, hashFunction) {
    this.jsonSchema = jsonSchema;
    this.hashFunction = hashFunction;
    this.indexes = getIndexes(this.jsonSchema);
    this.primaryPath = getPrimaryFieldOfPrimaryKey(this.jsonSchema.primaryKey);
    this.finalFields = getFinalFields(this.jsonSchema);
  }
  var _proto = RxSchema2.prototype;
  _proto.validateChange = function validateChange(dataBefore, dataAfter) {
    this.finalFields.forEach((fieldName) => {
      if (!deepEqual(dataBefore[fieldName], dataAfter[fieldName])) {
        throw newRxError("DOC9", {
          dataBefore,
          dataAfter,
          fieldName,
          schema: this.jsonSchema
        });
      }
    });
  };
  _proto.getDocumentPrototype = function getDocumentPrototype2() {
    var proto = {};
    var pathProperties = getSchemaByObjectPath(this.jsonSchema, "");
    Object.keys(pathProperties).forEach((key) => {
      var fullPath = key;
      proto.__defineGetter__(key, function() {
        if (!this.get || typeof this.get !== "function") {
          return void 0;
        }
        var ret = this.get(fullPath);
        return ret;
      });
      Object.defineProperty(proto, key + "$", {
        get: function() {
          return this.get$(fullPath);
        },
        enumerable: false,
        configurable: false
      });
      Object.defineProperty(proto, key + "_", {
        get: function() {
          return this.populate(fullPath);
        },
        enumerable: false,
        configurable: false
      });
    });
    overwriteGetterForCaching(this, "getDocumentPrototype", () => proto);
    return proto;
  };
  _proto.getPrimaryOfDocumentData = function getPrimaryOfDocumentData(documentData) {
    return getComposedPrimaryKeyOfDocumentData(this.jsonSchema, documentData);
  };
  _createClass(RxSchema2, [{
    key: "version",
    get: function() {
      return this.jsonSchema.version;
    }
  }, {
    key: "defaultValues",
    get: function() {
      var values = {};
      Object.entries(this.jsonSchema.properties).filter(([, v2]) => Object.prototype.hasOwnProperty.call(v2, "default")).forEach(([k2, v2]) => values[k2] = v2.default);
      return overwriteGetterForCaching(this, "defaultValues", values);
    }
    /**
     * @overrides itself on the first call
     *
     * TODO this should be a pure function that
     * caches the hash in a WeakMap.
     */
  }, {
    key: "hash",
    get: function() {
      return overwriteGetterForCaching(this, "hash", this.hashFunction(JSON.stringify(this.jsonSchema)));
    }
  }]);
  return RxSchema2;
}();
function getIndexes(jsonSchema) {
  return (jsonSchema.indexes || []).map((index) => isMaybeReadonlyArray(index) ? index : [index]);
}
function getPreviousVersions(schema) {
  var version = schema.version ? schema.version : 0;
  var c = 0;
  return new Array(version).fill(0).map(() => c++);
}
function createRxSchema(jsonSchema, hashFunction, runPreCreateHooks = true) {
  if (runPreCreateHooks) {
    runPluginHooks("preCreateRxSchema", jsonSchema);
  }
  var useJsonSchema = fillWithDefaultSettings(jsonSchema);
  useJsonSchema = normalizeRxJsonSchema(useJsonSchema);
  overwritable.deepFreezeWhenDevMode(useJsonSchema);
  var schema = new RxSchema(useJsonSchema, hashFunction);
  runPluginHooks("createRxSchema", schema);
  return schema;
}
function isFunction$3(value) {
  return typeof value === "function";
}
function hasLift$1(source) {
  return isFunction$3(source === null || source === void 0 ? void 0 : source.lift);
}
function operate$1(init) {
  return function(source) {
    if (hasLift$1(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
var extendStatics = function(d, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
    d2.__proto__ = b3;
  } || function(d2, b3) {
    for (var p2 in b3)
      if (Object.prototype.hasOwnProperty.call(b3, p2))
        d2[p2] = b3[p2];
  };
  return extendStatics(d, b2);
};
function __extends$g(d, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d, b2);
  function __() {
    this.constructor = d;
  }
  d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
function __awaiter$5(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator$7(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values$9(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o[s], i = 0;
  if (m2)
    return m2.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read$i(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
}
function __spreadArray$j(to, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l2 = from2.length, ar; i < l2; i++) {
      if (ar || !(i in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i);
        ar[i] = from2[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await$1(v2) {
  return this instanceof __await$1 ? (this.v = v2, this) : new __await$1(v2);
}
function __asyncGenerator$1(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i, q2 = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n2) {
    if (g2[n2])
      i[n2] = function(v2) {
        return new Promise(function(a, b2) {
          q2.push([n2, v2, a, b2]) > 1 || resume(n2, v2);
        });
      };
  }
  function resume(n2, v2) {
    try {
      step(g2[n2](v2));
    } catch (e2) {
      settle(q2[0][3], e2);
    }
  }
  function step(r2) {
    r2.value instanceof __await$1 ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f2, v2) {
    if (f2(v2), q2.shift(), q2.length)
      resume(q2[0][0], q2[0][1]);
  }
}
function __asyncValues$1(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o[Symbol.asyncIterator], i;
  return m2 ? m2.call(o) : (o = typeof __values$9 === "function" ? __values$9(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n2) {
    i[n2] = o[n2] && function(v2) {
      return new Promise(function(resolve2, reject) {
        v2 = o[n2](v2), settle(resolve2, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve2, reject, d, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve2({ value: v3, done: d });
    }, reject);
  }
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
};
var isArrayLike$1 = function(x2) {
  return x2 && typeof x2.length === "number" && typeof x2 !== "function";
};
function isPromise$3(value) {
  return isFunction$3(value === null || value === void 0 ? void 0 : value.then);
}
function createErrorClass$2(createImpl2) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl2(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}
var UnsubscriptionError$1 = createErrorClass$2(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
      return i + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});
function arrRemove$2(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}
var Subscription$2 = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values$9(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                _a.call(_parentage_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction$3(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e2) {
          errors = e2 instanceof UnsubscriptionError$1 ? e2.errors : [e2];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values$9(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer$1(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError$1) {
                errors = __spreadArray$j(__spreadArray$j([], __read$i(errors)), __read$i(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
              _b.call(_finalizers_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError$1(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer$1(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove$2(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove$2(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty2 = new Subscription2();
    empty2.closed = true;
    return empty2;
  }();
  return Subscription2;
}();
var EMPTY_SUBSCRIPTION = Subscription$2.EMPTY;
function isSubscription$1(value) {
  return value instanceof Subscription$2 || value && "closed" in value && isFunction$3(value.remove) && isFunction$3(value.add) && isFunction$3(value.unsubscribe);
}
function execFinalizer$1(finalizer) {
  if (isFunction$3(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}
var config$1 = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};
var timeoutProvider$1 = {
  setTimeout: function(handler, timeout2) {
    var args2 = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args2[_i - 2] = arguments[_i];
    }
    return setTimeout.apply(void 0, __spreadArray$j([handler, timeout2], __read$i(args2)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider$1.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};
function reportUnhandledError$2(err) {
  timeoutProvider$1.setTimeout(function() {
    {
      throw err;
    }
  });
}
function noop$2() {
}
function errorContext$2(cb2) {
  {
    cb2();
  }
}
var Subscriber$1 = function(_super) {
  __extends$g(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription$1(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next2, error, complete) {
    return new SafeSubscriber(next2, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped)
      ;
    else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped)
      ;
    else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped)
      ;
    else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription$2);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends$g(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction$3(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_12;
      if (_this && config$1.useDeprecatedNextContext) {
        context_12 = Object.create(observerOrNext);
        context_12.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_12),
          error: observerOrNext.error && bind(observerOrNext.error, context_12),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_12)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber$1);
function handleUnhandledError(error) {
  {
    reportUnhandledError$2(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop$2,
  error: defaultErrorHandler,
  complete: noop$2
};
var observable$1 = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
function identity$3(x2) {
  return x2;
}
function pipeFromArray$1(fns) {
  if (fns.length === 0) {
    return identity$3;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev2, fn) {
      return fn(prev2);
    }, input);
  };
}
var Observable$2 = function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber$1(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext$2(function() {
      var _a = _this, operator = _a.operator, source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next2, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor$1(promiseCtor);
    return new promiseCtor(function(resolve2, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next2(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve2
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable2.prototype[observable$1] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray$1(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor$1(promiseCtor);
    return new promiseCtor(function(resolve2, reject) {
      var value;
      _this.subscribe(function(x2) {
        return value = x2;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve2(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
function getPromiseCtor$1(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config$1.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver$1(value) {
  return value && isFunction$3(value.next) && isFunction$3(value.error) && isFunction$3(value.complete);
}
function isSubscriber$1(value) {
  return value && value instanceof Subscriber$1 || isObserver$1(value) && isSubscription$1(value);
}
function isInteropObservable$2(input) {
  return isFunction$3(input[observable$1]);
}
function isAsyncIterable$2(obj) {
  return Symbol.asyncIterator && isFunction$3(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}
function createInvalidObservableTypeError$1(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
function getSymbolIterator$1() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator$1 = getSymbolIterator$1();
function isIterable$2(input) {
  return isFunction$3(input === null || input === void 0 ? void 0 : input[iterator$1]);
}
function readableStreamLikeToAsyncGenerator$1(readableStream) {
  return __asyncGenerator$1(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a, value, done;
    return __generator$7(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          return [4, __await$1(reader.read())];
        case 3:
          _a = _b.sent(), value = _a.value, done = _a.done;
          if (!done)
            return [3, 5];
          return [4, __await$1(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await$1(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike$2(obj) {
  return isFunction$3(obj === null || obj === void 0 ? void 0 : obj.getReader);
}
function innerFrom$2(input) {
  if (input instanceof Observable$2) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable$2(input)) {
      return fromInteropObservable$1(input);
    }
    if (isArrayLike$1(input)) {
      return fromArrayLike$1(input);
    }
    if (isPromise$3(input)) {
      return fromPromise$1(input);
    }
    if (isAsyncIterable$2(input)) {
      return fromAsyncIterable$1(input);
    }
    if (isIterable$2(input)) {
      return fromIterable$1(input);
    }
    if (isReadableStreamLike$2(input)) {
      return fromReadableStreamLike$1(input);
    }
  }
  throw createInvalidObservableTypeError$1(input);
}
function fromInteropObservable$1(obj) {
  return new Observable$2(function(subscriber) {
    var obs = obj[observable$1]();
    if (isFunction$3(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike$1(array) {
  return new Observable$2(function(subscriber) {
    for (var i = 0; i < array.length && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }
    subscriber.complete();
  });
}
function fromPromise$1(promise) {
  return new Observable$2(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError$2);
  });
}
function fromIterable$1(iterable) {
  return new Observable$2(function(subscriber) {
    var e_1, _a;
    try {
      for (var iterable_1 = __values$9(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
          _a.call(iterable_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable$1(asyncIterable) {
  return new Observable$2(function(subscriber) {
    process$2(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike$1(readableStream) {
  return fromAsyncIterable$1(readableStreamLikeToAsyncGenerator$1(readableStream));
}
function process$2(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a;
  return __awaiter$5(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator$7(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues$1(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
            return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
            return [3, 8];
          return [4, _a.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2)
            throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}
function createOperatorSubscriber$1(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber$2(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber$2 = function(_super) {
  __extends$g(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber$1);
var dateTimestampProvider$1 = {
  now: function() {
    return (dateTimestampProvider$1.delegate || Date).now();
  },
  delegate: void 0
};
function isScheduler$2(value) {
  return value && isFunction$3(value.schedule);
}
function last$3(arr) {
  return arr[arr.length - 1];
}
function popScheduler$1(args2) {
  return isScheduler$2(last$3(args2)) ? args2.pop() : void 0;
}
function popNumber$1(args2, defaultValue) {
  return typeof last$3(args2) === "number" ? args2.pop() : defaultValue;
}
function executeSchedule$2(parentSubscription, scheduler2, work, delay2, repeat2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  if (repeat2 === void 0) {
    repeat2 = false;
  }
  var scheduleSubscription = scheduler2.schedule(function() {
    work();
    if (repeat2) {
      parentSubscription.add(this.schedule(null, delay2));
    } else {
      this.unsubscribe();
    }
  }, delay2);
  parentSubscription.add(scheduleSubscription);
  if (!repeat2) {
    return scheduleSubscription;
  }
}
function observeOn$2(scheduler2, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate$1(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber$1(subscriber, function(value) {
      return executeSchedule$2(subscriber, scheduler2, function() {
        return subscriber.next(value);
      }, delay2);
    }, function() {
      return executeSchedule$2(subscriber, scheduler2, function() {
        return subscriber.complete();
      }, delay2);
    }, function(err) {
      return executeSchedule$2(subscriber, scheduler2, function() {
        return subscriber.error(err);
      }, delay2);
    }));
  });
}
function subscribeOn$2(scheduler2, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate$1(function(source, subscriber) {
    subscriber.add(scheduler2.schedule(function() {
      return source.subscribe(subscriber);
    }, delay2));
  });
}
function scheduleObservable$2(input, scheduler2) {
  return innerFrom$2(input).pipe(subscribeOn$2(scheduler2), observeOn$2(scheduler2));
}
function schedulePromise$2(input, scheduler2) {
  return innerFrom$2(input).pipe(subscribeOn$2(scheduler2), observeOn$2(scheduler2));
}
function scheduleArray$2(input, scheduler2) {
  return new Observable$2(function(subscriber) {
    var i = 0;
    return scheduler2.schedule(function() {
      if (i === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}
function scheduleIterable$2(input, scheduler2) {
  return new Observable$2(function(subscriber) {
    var iterator2;
    executeSchedule$2(subscriber, scheduler2, function() {
      iterator2 = input[iterator$1]();
      executeSchedule$2(subscriber, scheduler2, function() {
        var _a;
        var value;
        var done;
        try {
          _a = iterator2.next(), value = _a.value, done = _a.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction$3(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
    };
  });
}
function scheduleAsyncIterable$2(input, scheduler2) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable$2(function(subscriber) {
    executeSchedule$2(subscriber, scheduler2, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule$2(subscriber, scheduler2, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}
function scheduleReadableStreamLike$2(input, scheduler2) {
  return scheduleAsyncIterable$2(readableStreamLikeToAsyncGenerator$1(input), scheduler2);
}
function scheduled$2(input, scheduler2) {
  if (input != null) {
    if (isInteropObservable$2(input)) {
      return scheduleObservable$2(input, scheduler2);
    }
    if (isArrayLike$1(input)) {
      return scheduleArray$2(input, scheduler2);
    }
    if (isPromise$3(input)) {
      return schedulePromise$2(input, scheduler2);
    }
    if (isAsyncIterable$2(input)) {
      return scheduleAsyncIterable$2(input, scheduler2);
    }
    if (isIterable$2(input)) {
      return scheduleIterable$2(input, scheduler2);
    }
    if (isReadableStreamLike$2(input)) {
      return scheduleReadableStreamLike$2(input, scheduler2);
    }
  }
  throw createInvalidObservableTypeError$1(input);
}
function from$3(input, scheduler2) {
  return scheduler2 ? scheduled$2(input, scheduler2) : innerFrom$2(input);
}
function map$2(project, thisArg) {
  return operate$1(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber$1(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index++));
    }));
  });
}
function mergeInternals$2(source, subscriber, project, concurrent, onBeforeNext, expand2, innerSubScheduler, additionalFinalizer) {
  var buffer2 = [];
  var active = 0;
  var index = 0;
  var isComplete = false;
  var checkComplete = function() {
    if (isComplete && !buffer2.length && !active) {
      subscriber.complete();
    }
  };
  var outerNext = function(value) {
    return active < concurrent ? doInnerSub(value) : buffer2.push(value);
  };
  var doInnerSub = function(value) {
    expand2 && subscriber.next(value);
    active++;
    var innerComplete = false;
    innerFrom$2(project(value, index++)).subscribe(createOperatorSubscriber$1(subscriber, function(innerValue) {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand2) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, function() {
      innerComplete = true;
    }, void 0, function() {
      if (innerComplete) {
        try {
          active--;
          var _loop_1 = function() {
            var bufferedValue = buffer2.shift();
            if (innerSubScheduler) {
              executeSchedule$2(subscriber, innerSubScheduler, function() {
                return doInnerSub(bufferedValue);
              });
            } else {
              doInnerSub(bufferedValue);
            }
          };
          while (buffer2.length && active < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source.subscribe(createOperatorSubscriber$1(subscriber, outerNext, function() {
    isComplete = true;
    checkComplete();
  }));
  return function() {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}
function mergeMap$2(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction$3(resultSelector)) {
    return mergeMap$2(function(a, i) {
      return map$2(function(b2, ii2) {
        return resultSelector(a, b2, i, ii2);
      })(innerFrom$2(project(a, i)));
    }, concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate$1(function(source, subscriber) {
    return mergeInternals$2(source, subscriber, project, concurrent);
  });
}
var isArray$4 = Array.isArray;
function argsOrArgArray$2(args2) {
  return args2.length === 1 && isArray$4(args2[0]) ? args2[0] : args2;
}
function mergeAll$2(concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return mergeMap$2(identity$3, concurrent);
}
function concatAll$2() {
  return mergeAll$2(1);
}
var ObjectUnsubscribedError$1 = createErrorClass$2(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});
var Subject$2 = function(_super) {
  __extends$g(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject$1(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError$1();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext$2(function() {
      var e_1, _a;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values$9(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext$2(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext$2(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a;
      return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription$2(function() {
      _this.currentObservers = null;
      arrRemove$2(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable$2();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject$1(destination, source);
  };
  return Subject2;
}(Observable$2);
var AnonymousSubject$1 = function(_super) {
  __extends$g(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject$2);
function concat$4() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  return concatAll$2()(from$3(args2, popScheduler$1(args2)));
}
function distinctUntilChanged$2(comparator, keySelector) {
  if (keySelector === void 0) {
    keySelector = identity$3;
  }
  comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare$1;
  return operate$1(function(source, subscriber) {
    var previousKey;
    var first2 = true;
    source.subscribe(createOperatorSubscriber$1(subscriber, function(value) {
      var currentKey = keySelector(value);
      if (first2 || !comparator(previousKey, currentKey)) {
        first2 = false;
        previousKey = currentKey;
        subscriber.next(value);
      }
    }));
  });
}
function defaultCompare$1(a, b2) {
  return a === b2;
}
function filter$3(predicate, thisArg) {
  return operate$1(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber$1(subscriber, function(value) {
      return predicate.call(thisArg, value, index++) && subscriber.next(value);
    }));
  });
}
function merge$6() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  var scheduler2 = popScheduler$1(args2);
  var concurrent = popNumber$1(args2, Infinity);
  args2 = argsOrArgArray$2(args2);
  return operate$1(function(source, subscriber) {
    mergeAll$2(concurrent)(from$3(__spreadArray$j([source], __read$i(args2)), scheduler2)).subscribe(subscriber);
  });
}
function mergeWith$2() {
  var otherSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherSources[_i] = arguments[_i];
  }
  return merge$6.apply(void 0, __spreadArray$j([], __read$i(otherSources)));
}
var ReplaySubject$2 = function(_super) {
  __extends$g(ReplaySubject2, _super);
  function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
    if (_bufferSize === void 0) {
      _bufferSize = Infinity;
    }
    if (_windowTime === void 0) {
      _windowTime = Infinity;
    }
    if (_timestampProvider === void 0) {
      _timestampProvider = dateTimestampProvider$1;
    }
    var _this = _super.call(this) || this;
    _this._bufferSize = _bufferSize;
    _this._windowTime = _windowTime;
    _this._timestampProvider = _timestampProvider;
    _this._buffer = [];
    _this._infiniteTimeWindow = true;
    _this._infiniteTimeWindow = _windowTime === Infinity;
    _this._bufferSize = Math.max(1, _bufferSize);
    _this._windowTime = Math.max(1, _windowTime);
    return _this;
  }
  ReplaySubject2.prototype.next = function(value) {
    var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
    if (!isStopped) {
      _buffer.push(value);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._trimBuffer();
    var subscription = this._innerSubscribe(subscriber);
    var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
    var copy2 = _buffer.slice();
    for (var i = 0; i < copy2.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy2[i]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  };
  ReplaySubject2.prototype._trimBuffer = function() {
    var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      var now2 = _timestampProvider.now();
      var last2 = 0;
      for (var i = 1; i < _buffer.length && _buffer[i] <= now2; i += 2) {
        last2 = i;
      }
      last2 && _buffer.splice(0, last2 + 1);
    }
  };
  return ReplaySubject2;
}(Subject$2);
function share$2(options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.connector, connector = _a === void 0 ? function() {
    return new Subject$2();
  } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
  return function(wrapperSource) {
    var connection;
    var resetConnection;
    var subject;
    var refCount2 = 0;
    var hasCompleted = false;
    var hasErrored = false;
    var cancelReset = function() {
      resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
      resetConnection = void 0;
    };
    var reset = function() {
      cancelReset();
      connection = subject = void 0;
      hasCompleted = hasErrored = false;
    };
    var resetAndUnsubscribe = function() {
      var conn = connection;
      reset();
      conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
    };
    return operate$1(function(source, subscriber) {
      refCount2++;
      if (!hasErrored && !hasCompleted) {
        cancelReset();
      }
      var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
      subscriber.add(function() {
        refCount2--;
        if (refCount2 === 0 && !hasErrored && !hasCompleted) {
          resetConnection = handleReset$1(resetAndUnsubscribe, resetOnRefCountZero);
        }
      });
      dest.subscribe(subscriber);
      if (!connection && refCount2 > 0) {
        connection = new SafeSubscriber({
          next: function(value) {
            return dest.next(value);
          },
          error: function(err) {
            hasErrored = true;
            cancelReset();
            resetConnection = handleReset$1(reset, resetOnError, err);
            dest.error(err);
          },
          complete: function() {
            hasCompleted = true;
            cancelReset();
            resetConnection = handleReset$1(reset, resetOnComplete);
            dest.complete();
          }
        });
        innerFrom$2(source).subscribe(connection);
      }
    })(wrapperSource);
  };
}
function handleReset$1(reset, on) {
  var args2 = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args2[_i - 2] = arguments[_i];
  }
  if (on === true) {
    reset();
    return;
  }
  if (on === false) {
    return;
  }
  var onSubscriber = new SafeSubscriber({
    next: function() {
      onSubscriber.unsubscribe();
      reset();
    }
  });
  return innerFrom$2(on.apply(void 0, __spreadArray$j([], __read$i(args2)))).subscribe(onSubscriber);
}
function shareReplay$2(configOrBufferSize, windowTime2, scheduler2) {
  var _a, _b, _c;
  var bufferSize;
  var refCount2 = false;
  if (configOrBufferSize && typeof configOrBufferSize === "object") {
    _a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime2 = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount2 = _c === void 0 ? false : _c, scheduler2 = configOrBufferSize.scheduler;
  } else {
    bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
  }
  return share$2({
    connector: function() {
      return new ReplaySubject$2(bufferSize, windowTime2, scheduler2);
    },
    resetOnError: true,
    resetOnComplete: false,
    resetOnRefCountZero: refCount2
  });
}
function startWith$2() {
  var values = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }
  var scheduler2 = popScheduler$1(values);
  return operate$1(function(source, subscriber) {
    (scheduler2 ? concat$4(values, source, scheduler2) : concat$4(values, source)).subscribe(subscriber);
  });
}
function getDocumentDataOfRxChangeEvent(rxChangeEvent) {
  if (rxChangeEvent.documentData) {
    return rxChangeEvent.documentData;
  } else {
    return rxChangeEvent.previousDocumentData;
  }
}
function rxChangeEventToEventReduceChangeEvent(rxChangeEvent) {
  switch (rxChangeEvent.operation) {
    case "INSERT":
      return {
        operation: rxChangeEvent.operation,
        id: rxChangeEvent.documentId,
        doc: rxChangeEvent.documentData,
        previous: null
      };
    case "UPDATE":
      return {
        operation: rxChangeEvent.operation,
        id: rxChangeEvent.documentId,
        doc: overwritable.deepFreezeWhenDevMode(rxChangeEvent.documentData),
        previous: rxChangeEvent.previousDocumentData ? rxChangeEvent.previousDocumentData : "UNKNOWN"
      };
    case "DELETE":
      return {
        operation: rxChangeEvent.operation,
        id: rxChangeEvent.documentId,
        doc: null,
        previous: rxChangeEvent.previousDocumentData
      };
  }
}
var cjs = {};
var Observable$1 = {};
var Subscriber = {};
var isFunction$2 = {};
Object.defineProperty(isFunction$2, "__esModule", { value: true });
isFunction$2.isFunction = void 0;
function isFunction$1(value) {
  return typeof value === "function";
}
isFunction$2.isFunction = isFunction$1;
var Subscription$1 = {};
var UnsubscriptionError = {};
var createErrorClass$1 = {};
Object.defineProperty(createErrorClass$1, "__esModule", { value: true });
createErrorClass$1.createErrorClass = void 0;
function createErrorClass(createImpl2) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl2(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}
createErrorClass$1.createErrorClass = createErrorClass;
Object.defineProperty(UnsubscriptionError, "__esModule", { value: true });
UnsubscriptionError.UnsubscriptionError = void 0;
var createErrorClass_1$5 = createErrorClass$1;
UnsubscriptionError.UnsubscriptionError = createErrorClass_1$5.createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
      return i + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});
var arrRemove$1 = {};
Object.defineProperty(arrRemove$1, "__esModule", { value: true });
arrRemove$1.arrRemove = void 0;
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}
arrRemove$1.arrRemove = arrRemove;
var __values$8 = commonjsGlobal && commonjsGlobal.__values || function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o[s], i = 0;
  if (m2)
    return m2.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read$h = commonjsGlobal && commonjsGlobal.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray$i = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i = 0, il2 = from2.length, j2 = to.length; i < il2; i++, j2++)
    to[j2] = from2[i];
  return to;
};
Object.defineProperty(Subscription$1, "__esModule", { value: true });
Subscription$1.isSubscription = Subscription$1.EMPTY_SUBSCRIPTION = Subscription$1.Subscription = void 0;
var isFunction_1$q = isFunction$2;
var UnsubscriptionError_1 = UnsubscriptionError;
var arrRemove_1$7 = arrRemove$1;
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values$8(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return))
                _a.call(_parentage_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction_1$q.isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e2) {
          errors = e2 instanceof UnsubscriptionError_1.UnsubscriptionError ? e2.errors : [e2];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values$8(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                errors = __spreadArray$i(__spreadArray$i([], __read$h(errors)), __read$h(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return))
              _b.call(_finalizers_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError_1.UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove_1$7.arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove_1$7.arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty2 = new Subscription2();
    empty2.closed = true;
    return empty2;
  }();
  return Subscription2;
}();
Subscription$1.Subscription = Subscription;
Subscription$1.EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction_1$q.isFunction(value.remove) && isFunction_1$q.isFunction(value.add) && isFunction_1$q.isFunction(value.unsubscribe);
}
Subscription$1.isSubscription = isSubscription;
function execFinalizer(finalizer) {
  if (isFunction_1$q.isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}
var config = {};
Object.defineProperty(config, "__esModule", { value: true });
config.config = void 0;
config.config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};
var reportUnhandledError$1 = {};
var timeoutProvider = {};
(function(exports) {
  var __read2 = commonjsGlobal && commonjsGlobal.__read || function(o, n2) {
    var m2 = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m2)
      return o;
    var i = m2.call(o), r2, ar = [], e2;
    try {
      while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
        ar.push(r2.value);
    } catch (error) {
      e2 = { error };
    } finally {
      try {
        if (r2 && !r2.done && (m2 = i["return"]))
          m2.call(i);
      } finally {
        if (e2)
          throw e2.error;
      }
    }
    return ar;
  };
  var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
    for (var i = 0, il2 = from2.length, j2 = to.length; i < il2; i++, j2++)
      to[j2] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.timeoutProvider = void 0;
  exports.timeoutProvider = {
    setTimeout: function(handler, timeout2) {
      var args2 = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args2[_i - 2] = arguments[_i];
      }
      var delegate = exports.timeoutProvider.delegate;
      if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
        return delegate.setTimeout.apply(delegate, __spreadArray2([handler, timeout2], __read2(args2)));
      }
      return setTimeout.apply(void 0, __spreadArray2([handler, timeout2], __read2(args2)));
    },
    clearTimeout: function(handle) {
      var delegate = exports.timeoutProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
    },
    delegate: void 0
  };
})(timeoutProvider);
Object.defineProperty(reportUnhandledError$1, "__esModule", { value: true });
reportUnhandledError$1.reportUnhandledError = void 0;
var config_1$2 = config;
var timeoutProvider_1 = timeoutProvider;
function reportUnhandledError(err) {
  timeoutProvider_1.timeoutProvider.setTimeout(function() {
    var onUnhandledError = config_1$2.config.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}
reportUnhandledError$1.reportUnhandledError = reportUnhandledError;
var noop$1 = {};
Object.defineProperty(noop$1, "__esModule", { value: true });
noop$1.noop = void 0;
function noop() {
}
noop$1.noop = noop;
var NotificationFactories = {};
Object.defineProperty(NotificationFactories, "__esModule", { value: true });
NotificationFactories.createNotification = NotificationFactories.nextNotification = NotificationFactories.errorNotification = NotificationFactories.COMPLETE_NOTIFICATION = void 0;
NotificationFactories.COMPLETE_NOTIFICATION = function() {
  return createNotification("C", void 0, void 0);
}();
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
NotificationFactories.errorNotification = errorNotification;
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
NotificationFactories.nextNotification = nextNotification;
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}
NotificationFactories.createNotification = createNotification;
var errorContext$1 = {};
Object.defineProperty(errorContext$1, "__esModule", { value: true });
errorContext$1.captureError = errorContext$1.errorContext = void 0;
var config_1$1 = config;
var context$1 = null;
function errorContext(cb2) {
  if (config_1$1.config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context$1;
    if (isRoot) {
      context$1 = { errorThrown: false, error: null };
    }
    cb2();
    if (isRoot) {
      var _a = context$1, errorThrown = _a.errorThrown, error = _a.error;
      context$1 = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb2();
  }
}
errorContext$1.errorContext = errorContext;
function captureError(err) {
  if (config_1$1.config.useDeprecatedSynchronousErrorHandling && context$1) {
    context$1.errorThrown = true;
    context$1.error = err;
  }
}
errorContext$1.captureError = captureError;
(function(exports) {
  var __extends2 = commonjsGlobal && commonjsGlobal.__extends || /* @__PURE__ */ function() {
    var extendStatics2 = function(d, b2) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p2 in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p2))
            d2[p2] = b3[p2];
      };
      return extendStatics2(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics2(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EMPTY_OBSERVER = exports.SafeSubscriber = exports.Subscriber = void 0;
  var isFunction_12 = isFunction$2;
  var Subscription_12 = Subscription$1;
  var config_12 = config;
  var reportUnhandledError_12 = reportUnhandledError$1;
  var noop_12 = noop$1;
  var NotificationFactories_1 = NotificationFactories;
  var timeoutProvider_12 = timeoutProvider;
  var errorContext_12 = errorContext$1;
  var Subscriber2 = function(_super) {
    __extends2(Subscriber3, _super);
    function Subscriber3(destination) {
      var _this = _super.call(this) || this;
      _this.isStopped = false;
      if (destination) {
        _this.destination = destination;
        if (Subscription_12.isSubscription(destination)) {
          destination.add(_this);
        }
      } else {
        _this.destination = exports.EMPTY_OBSERVER;
      }
      return _this;
    }
    Subscriber3.create = function(next2, error, complete) {
      return new SafeSubscriber2(next2, error, complete);
    };
    Subscriber3.prototype.next = function(value) {
      if (this.isStopped) {
        handleStoppedNotification(NotificationFactories_1.nextNotification(value), this);
      } else {
        this._next(value);
      }
    };
    Subscriber3.prototype.error = function(err) {
      if (this.isStopped) {
        handleStoppedNotification(NotificationFactories_1.errorNotification(err), this);
      } else {
        this.isStopped = true;
        this._error(err);
      }
    };
    Subscriber3.prototype.complete = function() {
      if (this.isStopped) {
        handleStoppedNotification(NotificationFactories_1.COMPLETE_NOTIFICATION, this);
      } else {
        this.isStopped = true;
        this._complete();
      }
    };
    Subscriber3.prototype.unsubscribe = function() {
      if (!this.closed) {
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
        this.destination = null;
      }
    };
    Subscriber3.prototype._next = function(value) {
      this.destination.next(value);
    };
    Subscriber3.prototype._error = function(err) {
      try {
        this.destination.error(err);
      } finally {
        this.unsubscribe();
      }
    };
    Subscriber3.prototype._complete = function() {
      try {
        this.destination.complete();
      } finally {
        this.unsubscribe();
      }
    };
    return Subscriber3;
  }(Subscription_12.Subscription);
  exports.Subscriber = Subscriber2;
  var _bind2 = Function.prototype.bind;
  function bind2(fn, thisArg) {
    return _bind2.call(fn, thisArg);
  }
  var ConsumerObserver2 = function() {
    function ConsumerObserver3(partialObserver) {
      this.partialObserver = partialObserver;
    }
    ConsumerObserver3.prototype.next = function(value) {
      var partialObserver = this.partialObserver;
      if (partialObserver.next) {
        try {
          partialObserver.next(value);
        } catch (error) {
          handleUnhandledError2(error);
        }
      }
    };
    ConsumerObserver3.prototype.error = function(err) {
      var partialObserver = this.partialObserver;
      if (partialObserver.error) {
        try {
          partialObserver.error(err);
        } catch (error) {
          handleUnhandledError2(error);
        }
      } else {
        handleUnhandledError2(err);
      }
    };
    ConsumerObserver3.prototype.complete = function() {
      var partialObserver = this.partialObserver;
      if (partialObserver.complete) {
        try {
          partialObserver.complete();
        } catch (error) {
          handleUnhandledError2(error);
        }
      }
    };
    return ConsumerObserver3;
  }();
  var SafeSubscriber2 = function(_super) {
    __extends2(SafeSubscriber3, _super);
    function SafeSubscriber3(observerOrNext, error, complete) {
      var _this = _super.call(this) || this;
      var partialObserver;
      if (isFunction_12.isFunction(observerOrNext) || !observerOrNext) {
        partialObserver = {
          next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
          error: error !== null && error !== void 0 ? error : void 0,
          complete: complete !== null && complete !== void 0 ? complete : void 0
        };
      } else {
        var context_12;
        if (_this && config_12.config.useDeprecatedNextContext) {
          context_12 = Object.create(observerOrNext);
          context_12.unsubscribe = function() {
            return _this.unsubscribe();
          };
          partialObserver = {
            next: observerOrNext.next && bind2(observerOrNext.next, context_12),
            error: observerOrNext.error && bind2(observerOrNext.error, context_12),
            complete: observerOrNext.complete && bind2(observerOrNext.complete, context_12)
          };
        } else {
          partialObserver = observerOrNext;
        }
      }
      _this.destination = new ConsumerObserver2(partialObserver);
      return _this;
    }
    return SafeSubscriber3;
  }(Subscriber2);
  exports.SafeSubscriber = SafeSubscriber2;
  function handleUnhandledError2(error) {
    if (config_12.config.useDeprecatedSynchronousErrorHandling) {
      errorContext_12.captureError(error);
    } else {
      reportUnhandledError_12.reportUnhandledError(error);
    }
  }
  function defaultErrorHandler2(err) {
    throw err;
  }
  function handleStoppedNotification(notification, subscriber) {
    var onStoppedNotification = config_12.config.onStoppedNotification;
    onStoppedNotification && timeoutProvider_12.timeoutProvider.setTimeout(function() {
      return onStoppedNotification(notification, subscriber);
    });
  }
  exports.EMPTY_OBSERVER = {
    closed: true,
    next: noop_12.noop,
    error: defaultErrorHandler2,
    complete: noop_12.noop
  };
})(Subscriber);
var observable = {};
Object.defineProperty(observable, "__esModule", { value: true });
observable.observable = void 0;
observable.observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
var pipe$2 = {};
var identity$2 = {};
Object.defineProperty(identity$2, "__esModule", { value: true });
identity$2.identity = void 0;
function identity$1(x2) {
  return x2;
}
identity$2.identity = identity$1;
Object.defineProperty(pipe$2, "__esModule", { value: true });
pipe$2.pipeFromArray = pipe$2.pipe = void 0;
var identity_1$f = identity$2;
function pipe$1() {
  var fns = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    fns[_i] = arguments[_i];
  }
  return pipeFromArray(fns);
}
pipe$2.pipe = pipe$1;
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity_1$f.identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev2, fn) {
      return fn(prev2);
    }, input);
  };
}
pipe$2.pipeFromArray = pipeFromArray;
Object.defineProperty(Observable$1, "__esModule", { value: true });
Observable$1.Observable = void 0;
var Subscriber_1$3 = Subscriber;
var Subscription_1$8 = Subscription$1;
var observable_1$2 = observable;
var pipe_1$2 = pipe$2;
var config_1 = config;
var isFunction_1$p = isFunction$2;
var errorContext_1$1 = errorContext$1;
var Observable = function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new Subscriber_1$3.SafeSubscriber(observerOrNext, error, complete);
    errorContext_1$1.errorContext(function() {
      var _a = _this, operator = _a.operator, source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next2, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve2, reject) {
      var subscriber = new Subscriber_1$3.SafeSubscriber({
        next: function(value) {
          try {
            next2(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve2
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable2.prototype[observable_1$2.observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipe_1$2.pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve2, reject) {
      var value;
      _this.subscribe(function(x2) {
        return value = x2;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve2(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
Observable$1.Observable = Observable;
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config_1.config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction_1$p.isFunction(value.next) && isFunction_1$p.isFunction(value.error) && isFunction_1$p.isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber_1$3.Subscriber || isObserver(value) && Subscription_1$8.isSubscription(value);
}
var ConnectableObservable$1 = {};
var refCount$1 = {};
var lift$1 = {};
Object.defineProperty(lift$1, "__esModule", { value: true });
lift$1.operate = lift$1.hasLift = void 0;
var isFunction_1$o = isFunction$2;
function hasLift(source) {
  return isFunction_1$o.isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
lift$1.hasLift = hasLift;
function operate(init) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
lift$1.operate = operate;
var OperatorSubscriber$1 = {};
var __extends$f = commonjsGlobal && commonjsGlobal.__extends || /* @__PURE__ */ function() {
  var extendStatics2 = function(d, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d2[p2] = b3[p2];
    };
    return extendStatics2(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
Object.defineProperty(OperatorSubscriber$1, "__esModule", { value: true });
OperatorSubscriber$1.OperatorSubscriber = OperatorSubscriber$1.createOperatorSubscriber = void 0;
var Subscriber_1$2 = Subscriber;
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
OperatorSubscriber$1.createOperatorSubscriber = createOperatorSubscriber;
var OperatorSubscriber = function(_super) {
  __extends$f(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber_1$2.Subscriber);
OperatorSubscriber$1.OperatorSubscriber = OperatorSubscriber;
Object.defineProperty(refCount$1, "__esModule", { value: true });
refCount$1.refCount = void 0;
var lift_1$14 = lift$1;
var OperatorSubscriber_1$V = OperatorSubscriber$1;
function refCount() {
  return lift_1$14.operate(function(source, subscriber) {
    var connection = null;
    source._refCount++;
    var refCounter = OperatorSubscriber_1$V.createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
      if (!source || source._refCount <= 0 || 0 < --source._refCount) {
        connection = null;
        return;
      }
      var sharedConnection = source._connection;
      var conn = connection;
      connection = null;
      if (sharedConnection && (!conn || sharedConnection === conn)) {
        sharedConnection.unsubscribe();
      }
      subscriber.unsubscribe();
    });
    source.subscribe(refCounter);
    if (!refCounter.closed) {
      connection = source.connect();
    }
  });
}
refCount$1.refCount = refCount;
var __extends$e = commonjsGlobal && commonjsGlobal.__extends || /* @__PURE__ */ function() {
  var extendStatics2 = function(d, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d2[p2] = b3[p2];
    };
    return extendStatics2(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
Object.defineProperty(ConnectableObservable$1, "__esModule", { value: true });
ConnectableObservable$1.ConnectableObservable = void 0;
var Observable_1$n = Observable$1;
var Subscription_1$7 = Subscription$1;
var refCount_1 = refCount$1;
var OperatorSubscriber_1$U = OperatorSubscriber$1;
var lift_1$13 = lift$1;
var ConnectableObservable = function(_super) {
  __extends$e(ConnectableObservable2, _super);
  function ConnectableObservable2(source, subjectFactory) {
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.subjectFactory = subjectFactory;
    _this._subject = null;
    _this._refCount = 0;
    _this._connection = null;
    if (lift_1$13.hasLift(source)) {
      _this.lift = source.lift;
    }
    return _this;
  }
  ConnectableObservable2.prototype._subscribe = function(subscriber) {
    return this.getSubject().subscribe(subscriber);
  };
  ConnectableObservable2.prototype.getSubject = function() {
    var subject = this._subject;
    if (!subject || subject.isStopped) {
      this._subject = this.subjectFactory();
    }
    return this._subject;
  };
  ConnectableObservable2.prototype._teardown = function() {
    this._refCount = 0;
    var _connection = this._connection;
    this._subject = this._connection = null;
    _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
  };
  ConnectableObservable2.prototype.connect = function() {
    var _this = this;
    var connection = this._connection;
    if (!connection) {
      connection = this._connection = new Subscription_1$7.Subscription();
      var subject_1 = this.getSubject();
      connection.add(this.source.subscribe(OperatorSubscriber_1$U.createOperatorSubscriber(subject_1, void 0, function() {
        _this._teardown();
        subject_1.complete();
      }, function(err) {
        _this._teardown();
        subject_1.error(err);
      }, function() {
        return _this._teardown();
      })));
      if (connection.closed) {
        this._connection = null;
        connection = Subscription_1$7.Subscription.EMPTY;
      }
    }
    return connection;
  };
  ConnectableObservable2.prototype.refCount = function() {
    return refCount_1.refCount()(this);
  };
  return ConnectableObservable2;
}(Observable_1$n.Observable);
ConnectableObservable$1.ConnectableObservable = ConnectableObservable;
var animationFrames$1 = {};
var performanceTimestampProvider = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.performanceTimestampProvider = void 0;
  exports.performanceTimestampProvider = {
    now: function() {
      return (exports.performanceTimestampProvider.delegate || performance).now();
    },
    delegate: void 0
  };
})(performanceTimestampProvider);
var animationFrameProvider = {};
(function(exports) {
  var __read2 = commonjsGlobal && commonjsGlobal.__read || function(o, n2) {
    var m2 = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m2)
      return o;
    var i = m2.call(o), r2, ar = [], e2;
    try {
      while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
        ar.push(r2.value);
    } catch (error) {
      e2 = { error };
    } finally {
      try {
        if (r2 && !r2.done && (m2 = i["return"]))
          m2.call(i);
      } finally {
        if (e2)
          throw e2.error;
      }
    }
    return ar;
  };
  var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
    for (var i = 0, il2 = from2.length, j2 = to.length; i < il2; i++, j2++)
      to[j2] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.animationFrameProvider = void 0;
  var Subscription_12 = Subscription$1;
  exports.animationFrameProvider = {
    schedule: function(callback) {
      var request = requestAnimationFrame;
      var cancel = cancelAnimationFrame;
      var delegate = exports.animationFrameProvider.delegate;
      if (delegate) {
        request = delegate.requestAnimationFrame;
        cancel = delegate.cancelAnimationFrame;
      }
      var handle = request(function(timestamp2) {
        cancel = void 0;
        callback(timestamp2);
      });
      return new Subscription_12.Subscription(function() {
        return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
      });
    },
    requestAnimationFrame: function() {
      var args2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i];
      }
      var delegate = exports.animationFrameProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray2([], __read2(args2)));
    },
    cancelAnimationFrame: function() {
      var args2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i];
      }
      var delegate = exports.animationFrameProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray2([], __read2(args2)));
    },
    delegate: void 0
  };
})(animationFrameProvider);
Object.defineProperty(animationFrames$1, "__esModule", { value: true });
animationFrames$1.animationFrames = void 0;
var Observable_1$m = Observable$1;
var performanceTimestampProvider_1 = performanceTimestampProvider;
var animationFrameProvider_1$1 = animationFrameProvider;
function animationFrames(timestampProvider) {
  return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;
}
animationFrames$1.animationFrames = animationFrames;
function animationFramesFactory(timestampProvider) {
  return new Observable_1$m.Observable(function(subscriber) {
    var provider = timestampProvider || performanceTimestampProvider_1.performanceTimestampProvider;
    var start = provider.now();
    var id2 = 0;
    var run = function() {
      if (!subscriber.closed) {
        id2 = animationFrameProvider_1$1.animationFrameProvider.requestAnimationFrame(function(timestamp2) {
          id2 = 0;
          var now2 = provider.now();
          subscriber.next({
            timestamp: timestampProvider ? now2 : timestamp2,
            elapsed: now2 - start
          });
          run();
        });
      }
    };
    run();
    return function() {
      if (id2) {
        animationFrameProvider_1$1.animationFrameProvider.cancelAnimationFrame(id2);
      }
    };
  });
}
var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();
var Subject$1 = {};
var ObjectUnsubscribedError = {};
Object.defineProperty(ObjectUnsubscribedError, "__esModule", { value: true });
ObjectUnsubscribedError.ObjectUnsubscribedError = void 0;
var createErrorClass_1$4 = createErrorClass$1;
ObjectUnsubscribedError.ObjectUnsubscribedError = createErrorClass_1$4.createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});
var __extends$d = commonjsGlobal && commonjsGlobal.__extends || /* @__PURE__ */ function() {
  var extendStatics2 = function(d, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d2[p2] = b3[p2];
    };
    return extendStatics2(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __values$7 = commonjsGlobal && commonjsGlobal.__values || function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o[s], i = 0;
  if (m2)
    return m2.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(Subject$1, "__esModule", { value: true });
Subject$1.AnonymousSubject = Subject$1.Subject = void 0;
var Observable_1$l = Observable$1;
var Subscription_1$6 = Subscription$1;
var ObjectUnsubscribedError_1 = ObjectUnsubscribedError;
var arrRemove_1$6 = arrRemove$1;
var errorContext_1 = errorContext$1;
var Subject = function(_super) {
  __extends$d(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext_1.errorContext(function() {
      var e_1, _a;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values$7(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext_1.errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext_1.errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a;
      return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
    if (hasError || isStopped) {
      return Subscription_1$6.EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription_1$6.Subscription(function() {
      _this.currentObservers = null;
      arrRemove_1$6.arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable_1$l.Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable_1$l.Observable);
Subject$1.Subject = Subject;
var AnonymousSubject = function(_super) {
  __extends$d(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : Subscription_1$6.EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);
Subject$1.AnonymousSubject = AnonymousSubject;
var BehaviorSubject$1 = {};
var __extends$c = commonjsGlobal && commonjsGlobal.__extends || /* @__PURE__ */ function() {
  var extendStatics2 = function(d, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d2[p2] = b3[p2];
    };
    return extendStatics2(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
Object.defineProperty(BehaviorSubject$1, "__esModule", { value: true });
BehaviorSubject$1.BehaviorSubject = void 0;
var Subject_1$e = Subject$1;
var BehaviorSubject = function(_super) {
  __extends$c(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
}(Subject_1$e.Subject);
BehaviorSubject$1.BehaviorSubject = BehaviorSubject;
var ReplaySubject$1 = {};
var dateTimestampProvider = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.dateTimestampProvider = void 0;
  exports.dateTimestampProvider = {
    now: function() {
      return (exports.dateTimestampProvider.delegate || Date).now();
    },
    delegate: void 0
  };
})(dateTimestampProvider);
var __extends$b = commonjsGlobal && commonjsGlobal.__extends || /* @__PURE__ */ function() {
  var extendStatics2 = function(d, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d2[p2] = b3[p2];
    };
    return extendStatics2(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
Object.defineProperty(ReplaySubject$1, "__esModule", { value: true });
ReplaySubject$1.ReplaySubject = void 0;
var Subject_1$d = Subject$1;
var dateTimestampProvider_1$2 = dateTimestampProvider;
var ReplaySubject = function(_super) {
  __extends$b(ReplaySubject2, _super);
  function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
    if (_bufferSize === void 0) {
      _bufferSize = Infinity;
    }
    if (_windowTime === void 0) {
      _windowTime = Infinity;
    }
    if (_timestampProvider === void 0) {
      _timestampProvider = dateTimestampProvider_1$2.dateTimestampProvider;
    }
    var _this = _super.call(this) || this;
    _this._bufferSize = _bufferSize;
    _this._windowTime = _windowTime;
    _this._timestampProvider = _timestampProvider;
    _this._buffer = [];
    _this._infiniteTimeWindow = true;
    _this._infiniteTimeWindow = _windowTime === Infinity;
    _this._bufferSize = Math.max(1, _bufferSize);
    _this._windowTime = Math.max(1, _windowTime);
    return _this;
  }
  ReplaySubject2.prototype.next = function(value) {
    var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
    if (!isStopped) {
      _buffer.push(value);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._trimBuffer();
    var subscription = this._innerSubscribe(subscriber);
    var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
    var copy2 = _buffer.slice();
    for (var i = 0; i < copy2.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy2[i]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  };
  ReplaySubject2.prototype._trimBuffer = function() {
    var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      var now2 = _timestampProvider.now();
      var last2 = 0;
      for (var i = 1; i < _buffer.length && _buffer[i] <= now2; i += 2) {
        last2 = i;
      }
      last2 && _buffer.splice(0, last2 + 1);
    }
  };
  return ReplaySubject2;
}(Subject_1$d.Subject);
ReplaySubject$1.ReplaySubject = ReplaySubject;
var AsyncSubject$1 = {};
var __extends$a = commonjsGlobal && commonjsGlobal.__extends || /* @__PURE__ */ function() {
  var extendStatics2 = function(d, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d2[p2] = b3[p2];
    };
    return extendStatics2(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
Object.defineProperty(AsyncSubject$1, "__esModule", { value: true });
AsyncSubject$1.AsyncSubject = void 0;
var Subject_1$c = Subject$1;
var AsyncSubject = function(_super) {
  __extends$a(AsyncSubject2, _super);
  function AsyncSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._value = null;
    _this._hasValue = false;
    _this._isComplete = false;
    return _this;
  }
  AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped || _isComplete) {
      _hasValue && subscriber.next(_value);
      subscriber.complete();
    }
  };
  AsyncSubject2.prototype.next = function(value) {
    if (!this.isStopped) {
      this._value = value;
      this._hasValue = true;
    }
  };
  AsyncSubject2.prototype.complete = function() {
    var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
    if (!_isComplete) {
      this._isComplete = true;
      _hasValue && _super.prototype.next.call(this, _value);
      _super.prototype.complete.call(this);
    }
  };
  return AsyncSubject2;
}(Subject_1$c.Subject);
AsyncSubject$1.AsyncSubject = AsyncSubject;
var asap = {};
var AsapAction$1 = {};
var AsyncAction$1 = {};
var Action$2 = {};
var __extends$9 = commonjsGlobal && commonjsGlobal.__extends || /* @__PURE__ */ function() {
  var extendStatics2 = function(d, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d2[p2] = b3[p2];
    };
    return extendStatics2(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
Object.defineProperty(Action$2, "__esModule", { value: true });
Action$2.Action = void 0;
var Subscription_1$5 = Subscription$1;
var Action$1 = function(_super) {
  __extends$9(Action2, _super);
  function Action2(scheduler2, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state, delay2) {
    return this;
  };
  return Action2;
}(Subscription_1$5.Subscription);
Action$2.Action = Action$1;
var intervalProvider = {};
(function(exports) {
  var __read2 = commonjsGlobal && commonjsGlobal.__read || function(o, n2) {
    var m2 = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m2)
      return o;
    var i = m2.call(o), r2, ar = [], e2;
    try {
      while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
        ar.push(r2.value);
    } catch (error) {
      e2 = { error };
    } finally {
      try {
        if (r2 && !r2.done && (m2 = i["return"]))
          m2.call(i);
      } finally {
        if (e2)
          throw e2.error;
      }
    }
    return ar;
  };
  var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
    for (var i = 0, il2 = from2.length, j2 = to.length; i < il2; i++, j2++)
      to[j2] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.intervalProvider = void 0;
  exports.intervalProvider = {
    setInterval: function(handler, timeout2) {
      var args2 = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args2[_i - 2] = arguments[_i];
      }
      var delegate = exports.intervalProvider.delegate;
      if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
        return delegate.setInterval.apply(delegate, __spreadArray2([handler, timeout2], __read2(args2)));
      }
      return setInterval.apply(void 0, __spreadArray2([handler, timeout2], __read2(args2)));
    },
    clearInterval: function(handle) {
      var delegate = exports.intervalProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
    },
    delegate: void 0
  };
})(intervalProvider);
var __extends$8 = commonjsGlobal && commonjsGlobal.__extends || /* @__PURE__ */ function() {
  var extendStatics2 = function(d, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d2[p2] = b3[p2];
    };
    return extendStatics2(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
Object.defineProperty(AsyncAction$1, "__esModule", { value: true });
AsyncAction$1.AsyncAction = void 0;
var Action_1 = Action$2;
var intervalProvider_1 = intervalProvider;
var arrRemove_1$5 = arrRemove$1;
var AsyncAction = function(_super) {
  __extends$8(AsyncAction2, _super);
  function AsyncAction2(scheduler2, work) {
    var _this = _super.call(this, scheduler2, work) || this;
    _this.scheduler = scheduler2;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state;
    var id2 = this.id;
    var scheduler2 = this.scheduler;
    if (id2 != null) {
      this.id = this.recycleAsyncId(scheduler2, id2, delay2);
    }
    this.pending = true;
    this.delay = delay2;
    this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler2, this.id, delay2);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler2, _id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return intervalProvider_1.intervalProvider.setInterval(scheduler2.flush.bind(scheduler2, this), delay2);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && this.delay === delay2 && this.pending === false) {
      return id2;
    }
    if (id2 != null) {
      intervalProvider_1.intervalProvider.clearInterval(id2);
    }
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state, delay2) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state, delay2);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state, _delay) {
    var errored = false;
    var errorValue;
    try {
      this.work(state);
    } catch (e2) {
      errored = true;
      errorValue = e2 ? e2 : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a = this, id2 = _a.id, scheduler2 = _a.scheduler;
      var actions = scheduler2.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove_1$5.arrRemove(actions, this);
      if (id2 != null) {
        this.id = this.recycleAsyncId(scheduler2, id2, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
}(Action_1.Action);
AsyncAction$1.AsyncAction = AsyncAction;
var immediateProvider = {};
var Immediate = {};
Object.defineProperty(Immediate, "__esModule", { value: true });
Immediate.TestTools = Immediate.Immediate = void 0;
var nextHandle = 1;
var resolved;
var activeHandles = {};
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
Immediate.Immediate = {
  setImmediate: function(cb2) {
    var handle = nextHandle++;
    activeHandles[handle] = true;
    if (!resolved) {
      resolved = Promise.resolve();
    }
    resolved.then(function() {
      return findAndClearHandle(handle) && cb2();
    });
    return handle;
  },
  clearImmediate: function(handle) {
    findAndClearHandle(handle);
  }
};
Immediate.TestTools = {
  pending: function() {
    return Object.keys(activeHandles).length;
  }
};
(function(exports) {
  var __read2 = commonjsGlobal && commonjsGlobal.__read || function(o, n2) {
    var m2 = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m2)
      return o;
    var i = m2.call(o), r2, ar = [], e2;
    try {
      while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
        ar.push(r2.value);
    } catch (error) {
      e2 = { error };
    } finally {
      try {
        if (r2 && !r2.done && (m2 = i["return"]))
          m2.call(i);
      } finally {
        if (e2)
          throw e2.error;
      }
    }
    return ar;
  };
  var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
    for (var i = 0, il2 = from2.length, j2 = to.length; i < il2; i++, j2++)
      to[j2] = from2[i];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.immediateProvider = void 0;
  var Immediate_1 = Immediate;
  var setImmediate2 = Immediate_1.Immediate.setImmediate, clearImmediate = Immediate_1.Immediate.clearImmediate;
  exports.immediateProvider = {
    setImmediate: function() {
      var args2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i];
      }
      var delegate = exports.immediateProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate2).apply(void 0, __spreadArray2([], __read2(args2)));
    },
    clearImmediate: function(handle) {
      var delegate = exports.immediateProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
    },
    delegate: void 0
  };
})(immediateProvider);
var __extends$7 = commonjsGlobal && commonjsGlobal.__extends || /* @__PURE__ */ function() {
  var extendStatics2 = function(d, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d2[p2] = b3[p2];
    };
    return extendStatics2(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
Object.defineProperty(AsapAction$1, "__esModule", { value: true });
AsapAction$1.AsapAction = void 0;
var AsyncAction_1$3 = AsyncAction$1;
var immediateProvider_1 = immediateProvider;
var AsapAction = function(_super) {
  __extends$7(AsapAction2, _super);
  function AsapAction2(scheduler2, work) {
    var _this = _super.call(this, scheduler2, work) || this;
    _this.scheduler = scheduler2;
    _this.work = work;
    return _this;
  }
  AsapAction2.prototype.requestAsyncId = function(scheduler2, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler2, id2, delay2);
    }
    scheduler2.actions.push(this);
    return scheduler2._scheduled || (scheduler2._scheduled = immediateProvider_1.immediateProvider.setImmediate(scheduler2.flush.bind(scheduler2, void 0)));
  };
  AsapAction2.prototype.recycleAsyncId = function(scheduler2, id2, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null ? delay2 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler2, id2, delay2);
    }
    var actions = scheduler2.actions;
    if (id2 != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id2) {
      immediateProvider_1.immediateProvider.clearImmediate(id2);
      if (scheduler2._scheduled === id2) {
        scheduler2._scheduled = void 0;
      }
    }
    return void 0;
  };
  return AsapAction2;
}(AsyncAction_1$3.AsyncAction);
AsapAction$1.AsapAction = AsapAction;
var AsapScheduler$1 = {};
var AsyncScheduler$1 = {};
var Scheduler$1 = {};
Object.defineProperty(Scheduler$1, "__esModule", { value: true });
Scheduler$1.Scheduler = void 0;
var dateTimestampProvider_1$1 = dateTimestampProvider;
var Scheduler = function() {
  function Scheduler2(schedulerActionCtor, now2) {
    if (now2 === void 0) {
      now2 = Scheduler2.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now2;
  }
  Scheduler2.prototype.schedule = function(work, delay2, state) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state, delay2);
  };
  Scheduler2.now = dateTimestampProvider_1$1.dateTimestampProvider.now;
  return Scheduler2;
}();
Scheduler$1.Scheduler = Scheduler;
var __extends$6 = commonjsGlobal && commonjsGlobal.__extends || /* @__PURE__ */ function() {
  var extendStatics2 = function(d, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d2[p2] = b3[p2];
    };
    return extendStatics2(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
Object.defineProperty(AsyncScheduler$1, "__esModule", { value: true });
AsyncScheduler$1.AsyncScheduler = void 0;
var Scheduler_1 = Scheduler$1;
var AsyncScheduler = function(_super) {
  __extends$6(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now2) {
    if (now2 === void 0) {
      now2 = Scheduler_1.Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, now2) || this;
    _this.actions = [];
    _this._active = false;
    return _this;
  }
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this._active) {
      actions.push(action);
      return;
    }
    var error;
    this._active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
}(Scheduler_1.Scheduler);
AsyncScheduler$1.AsyncScheduler = AsyncScheduler;
var __extends$5 = commonjsGlobal && commonjsGlobal.__extends || /* @__PURE__ */ function() {
  var extendStatics2 = function(d, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d2[p2] = b3[p2];
    };
    return extendStatics2(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
Object.defineProperty(AsapScheduler$1, "__esModule", { value: true });
AsapScheduler$1.AsapScheduler = void 0;
var AsyncScheduler_1$3 = AsyncScheduler$1;
var AsapScheduler = function(_super) {
  __extends$5(AsapScheduler2, _super);
  function AsapScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AsapScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsapScheduler2;
}(AsyncScheduler_1$3.AsyncScheduler);
AsapScheduler$1.AsapScheduler = AsapScheduler;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.asap = exports.asapScheduler = void 0;
  var AsapAction_1 = AsapAction$1;
  var AsapScheduler_1 = AsapScheduler$1;
  exports.asapScheduler = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);
  exports.asap = exports.asapScheduler;
})(asap);
var async = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.async = exports.asyncScheduler = void 0;
  var AsyncAction_12 = AsyncAction$1;
  var AsyncScheduler_12 = AsyncScheduler$1;
  exports.asyncScheduler = new AsyncScheduler_12.AsyncScheduler(AsyncAction_12.AsyncAction);
  exports.async = exports.asyncScheduler;
})(async);
var queue = {};
var QueueAction$1 = {};
var __extends$4 = commonjsGlobal && commonjsGlobal.__extends || /* @__PURE__ */ function() {
  var extendStatics2 = function(d, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d2[p2] = b3[p2];
    };
    return extendStatics2(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
Object.defineProperty(QueueAction$1, "__esModule", { value: true });
QueueAction$1.QueueAction = void 0;
var AsyncAction_1$2 = AsyncAction$1;
var QueueAction = function(_super) {
  __extends$4(QueueAction2, _super);
  function QueueAction2(scheduler2, work) {
    var _this = _super.call(this, scheduler2, work) || this;
    _this.scheduler = scheduler2;
    _this.work = work;
    return _this;
  }
  QueueAction2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 > 0) {
      return _super.prototype.schedule.call(this, state, delay2);
    }
    this.delay = delay2;
    this.state = state;
    this.scheduler.flush(this);
    return this;
  };
  QueueAction2.prototype.execute = function(state, delay2) {
    return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state, delay2) : this._execute(state, delay2);
  };
  QueueAction2.prototype.requestAsyncId = function(scheduler2, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && delay2 > 0 || delay2 == null && this.delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler2, id2, delay2);
    }
    scheduler2.flush(this);
    return 0;
  };
  return QueueAction2;
}(AsyncAction_1$2.AsyncAction);
QueueAction$1.QueueAction = QueueAction;
var QueueScheduler$1 = {};
var __extends$3 = commonjsGlobal && commonjsGlobal.__extends || /* @__PURE__ */ function() {
  var extendStatics2 = function(d, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d2[p2] = b3[p2];
    };
    return extendStatics2(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
Object.defineProperty(QueueScheduler$1, "__esModule", { value: true });
QueueScheduler$1.QueueScheduler = void 0;
var AsyncScheduler_1$2 = AsyncScheduler$1;
var QueueScheduler = function(_super) {
  __extends$3(QueueScheduler2, _super);
  function QueueScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return QueueScheduler2;
}(AsyncScheduler_1$2.AsyncScheduler);
QueueScheduler$1.QueueScheduler = QueueScheduler;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.queue = exports.queueScheduler = void 0;
  var QueueAction_1 = QueueAction$1;
  var QueueScheduler_1 = QueueScheduler$1;
  exports.queueScheduler = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);
  exports.queue = exports.queueScheduler;
})(queue);
var animationFrame = {};
var AnimationFrameAction$1 = {};
var __extends$2 = commonjsGlobal && commonjsGlobal.__extends || /* @__PURE__ */ function() {
  var extendStatics2 = function(d, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d2[p2] = b3[p2];
    };
    return extendStatics2(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
Object.defineProperty(AnimationFrameAction$1, "__esModule", { value: true });
AnimationFrameAction$1.AnimationFrameAction = void 0;
var AsyncAction_1$1 = AsyncAction$1;
var animationFrameProvider_1 = animationFrameProvider;
var AnimationFrameAction = function(_super) {
  __extends$2(AnimationFrameAction2, _super);
  function AnimationFrameAction2(scheduler2, work) {
    var _this = _super.call(this, scheduler2, work) || this;
    _this.scheduler = scheduler2;
    _this.work = work;
    return _this;
  }
  AnimationFrameAction2.prototype.requestAsyncId = function(scheduler2, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler2, id2, delay2);
    }
    scheduler2.actions.push(this);
    return scheduler2._scheduled || (scheduler2._scheduled = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function() {
      return scheduler2.flush(void 0);
    }));
  };
  AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler2, id2, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null ? delay2 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler2, id2, delay2);
    }
    var actions = scheduler2.actions;
    if (id2 != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id2) {
      animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id2);
      scheduler2._scheduled = void 0;
    }
    return void 0;
  };
  return AnimationFrameAction2;
}(AsyncAction_1$1.AsyncAction);
AnimationFrameAction$1.AnimationFrameAction = AnimationFrameAction;
var AnimationFrameScheduler$1 = {};
var __extends$1 = commonjsGlobal && commonjsGlobal.__extends || /* @__PURE__ */ function() {
  var extendStatics2 = function(d, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d2[p2] = b3[p2];
    };
    return extendStatics2(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
Object.defineProperty(AnimationFrameScheduler$1, "__esModule", { value: true });
AnimationFrameScheduler$1.AnimationFrameScheduler = void 0;
var AsyncScheduler_1$1 = AsyncScheduler$1;
var AnimationFrameScheduler = function(_super) {
  __extends$1(AnimationFrameScheduler2, _super);
  function AnimationFrameScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AnimationFrameScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AnimationFrameScheduler2;
}(AsyncScheduler_1$1.AsyncScheduler);
AnimationFrameScheduler$1.AnimationFrameScheduler = AnimationFrameScheduler;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.animationFrame = exports.animationFrameScheduler = void 0;
  var AnimationFrameAction_1 = AnimationFrameAction$1;
  var AnimationFrameScheduler_1 = AnimationFrameScheduler$1;
  exports.animationFrameScheduler = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);
  exports.animationFrame = exports.animationFrameScheduler;
})(animationFrame);
var VirtualTimeScheduler$1 = {};
var __extends = commonjsGlobal && commonjsGlobal.__extends || /* @__PURE__ */ function() {
  var extendStatics2 = function(d, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
      d2.__proto__ = b3;
    } || function(d2, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d2[p2] = b3[p2];
    };
    return extendStatics2(d, b2);
  };
  return function(d, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d, b2);
    function __() {
      this.constructor = d;
    }
    d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
Object.defineProperty(VirtualTimeScheduler$1, "__esModule", { value: true });
VirtualTimeScheduler$1.VirtualAction = VirtualTimeScheduler$1.VirtualTimeScheduler = void 0;
var AsyncAction_1 = AsyncAction$1;
var Subscription_1$4 = Subscription$1;
var AsyncScheduler_1 = AsyncScheduler$1;
var VirtualTimeScheduler = function(_super) {
  __extends(VirtualTimeScheduler2, _super);
  function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
    if (schedulerActionCtor === void 0) {
      schedulerActionCtor = VirtualAction;
    }
    if (maxFrames === void 0) {
      maxFrames = Infinity;
    }
    var _this = _super.call(this, schedulerActionCtor, function() {
      return _this.frame;
    }) || this;
    _this.maxFrames = maxFrames;
    _this.frame = 0;
    _this.index = -1;
    return _this;
  }
  VirtualTimeScheduler2.prototype.flush = function() {
    var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
    var error;
    var action;
    while ((action = actions[0]) && action.delay <= maxFrames) {
      actions.shift();
      this.frame = action.delay;
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    }
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  VirtualTimeScheduler2.frameTimeFactor = 10;
  return VirtualTimeScheduler2;
}(AsyncScheduler_1.AsyncScheduler);
VirtualTimeScheduler$1.VirtualTimeScheduler = VirtualTimeScheduler;
var VirtualAction = function(_super) {
  __extends(VirtualAction2, _super);
  function VirtualAction2(scheduler2, work, index) {
    if (index === void 0) {
      index = scheduler2.index += 1;
    }
    var _this = _super.call(this, scheduler2, work) || this;
    _this.scheduler = scheduler2;
    _this.work = work;
    _this.index = index;
    _this.active = true;
    _this.index = scheduler2.index = index;
    return _this;
  }
  VirtualAction2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (Number.isFinite(delay2)) {
      if (!this.id) {
        return _super.prototype.schedule.call(this, state, delay2);
      }
      this.active = false;
      var action = new VirtualAction2(this.scheduler, this.work);
      this.add(action);
      return action.schedule(state, delay2);
    } else {
      return Subscription_1$4.Subscription.EMPTY;
    }
  };
  VirtualAction2.prototype.requestAsyncId = function(scheduler2, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    this.delay = scheduler2.frame + delay2;
    var actions = scheduler2.actions;
    actions.push(this);
    actions.sort(VirtualAction2.sortActions);
    return 1;
  };
  VirtualAction2.prototype.recycleAsyncId = function(scheduler2, id2, delay2) {
    return void 0;
  };
  VirtualAction2.prototype._execute = function(state, delay2) {
    if (this.active === true) {
      return _super.prototype._execute.call(this, state, delay2);
    }
  };
  VirtualAction2.sortActions = function(a, b2) {
    if (a.delay === b2.delay) {
      if (a.index === b2.index) {
        return 0;
      } else if (a.index > b2.index) {
        return 1;
      } else {
        return -1;
      }
    } else if (a.delay > b2.delay) {
      return 1;
    } else {
      return -1;
    }
  };
  return VirtualAction2;
}(AsyncAction_1.AsyncAction);
VirtualTimeScheduler$1.VirtualAction = VirtualAction;
var Notification = {};
var empty = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.empty = exports.EMPTY = void 0;
  var Observable_12 = Observable$1;
  exports.EMPTY = new Observable_12.Observable(function(subscriber) {
    return subscriber.complete();
  });
  function empty2(scheduler2) {
    return scheduler2 ? emptyScheduled(scheduler2) : exports.EMPTY;
  }
  exports.empty = empty2;
  function emptyScheduled(scheduler2) {
    return new Observable_12.Observable(function(subscriber) {
      return scheduler2.schedule(function() {
        return subscriber.complete();
      });
    });
  }
})(empty);
var of$1 = {};
var args = {};
var isScheduler$1 = {};
Object.defineProperty(isScheduler$1, "__esModule", { value: true });
isScheduler$1.isScheduler = void 0;
var isFunction_1$n = isFunction$2;
function isScheduler(value) {
  return value && isFunction_1$n.isFunction(value.schedule);
}
isScheduler$1.isScheduler = isScheduler;
Object.defineProperty(args, "__esModule", { value: true });
args.popNumber = args.popScheduler = args.popResultSelector = void 0;
var isFunction_1$m = isFunction$2;
var isScheduler_1$3 = isScheduler$1;
function last$2(arr) {
  return arr[arr.length - 1];
}
function popResultSelector(args2) {
  return isFunction_1$m.isFunction(last$2(args2)) ? args2.pop() : void 0;
}
args.popResultSelector = popResultSelector;
function popScheduler(args2) {
  return isScheduler_1$3.isScheduler(last$2(args2)) ? args2.pop() : void 0;
}
args.popScheduler = popScheduler;
function popNumber(args2, defaultValue) {
  return typeof last$2(args2) === "number" ? args2.pop() : defaultValue;
}
args.popNumber = popNumber;
var from$2 = {};
var scheduled$1 = {};
var scheduleObservable$1 = {};
var innerFrom$1 = {};
var isArrayLike = {};
Object.defineProperty(isArrayLike, "__esModule", { value: true });
isArrayLike.isArrayLike = void 0;
isArrayLike.isArrayLike = function(x2) {
  return x2 && typeof x2.length === "number" && typeof x2 !== "function";
};
var isPromise$2 = {};
Object.defineProperty(isPromise$2, "__esModule", { value: true });
isPromise$2.isPromise = void 0;
var isFunction_1$l = isFunction$2;
function isPromise$1(value) {
  return isFunction_1$l.isFunction(value === null || value === void 0 ? void 0 : value.then);
}
isPromise$2.isPromise = isPromise$1;
var isInteropObservable$1 = {};
Object.defineProperty(isInteropObservable$1, "__esModule", { value: true });
isInteropObservable$1.isInteropObservable = void 0;
var observable_1$1 = observable;
var isFunction_1$k = isFunction$2;
function isInteropObservable(input) {
  return isFunction_1$k.isFunction(input[observable_1$1.observable]);
}
isInteropObservable$1.isInteropObservable = isInteropObservable;
var isAsyncIterable$1 = {};
Object.defineProperty(isAsyncIterable$1, "__esModule", { value: true });
isAsyncIterable$1.isAsyncIterable = void 0;
var isFunction_1$j = isFunction$2;
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction_1$j.isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}
isAsyncIterable$1.isAsyncIterable = isAsyncIterable;
var throwUnobservableError = {};
Object.defineProperty(throwUnobservableError, "__esModule", { value: true });
throwUnobservableError.createInvalidObservableTypeError = void 0;
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}
throwUnobservableError.createInvalidObservableTypeError = createInvalidObservableTypeError;
var isIterable$1 = {};
var iterator = {};
Object.defineProperty(iterator, "__esModule", { value: true });
iterator.iterator = iterator.getSymbolIterator = void 0;
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
iterator.getSymbolIterator = getSymbolIterator;
iterator.iterator = getSymbolIterator();
Object.defineProperty(isIterable$1, "__esModule", { value: true });
isIterable$1.isIterable = void 0;
var iterator_1$1 = iterator;
var isFunction_1$i = isFunction$2;
function isIterable(input) {
  return isFunction_1$i.isFunction(input === null || input === void 0 ? void 0 : input[iterator_1$1.iterator]);
}
isIterable$1.isIterable = isIterable;
var isReadableStreamLike$1 = {};
var __generator$6 = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __await = commonjsGlobal && commonjsGlobal.__await || function(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
};
var __asyncGenerator = commonjsGlobal && commonjsGlobal.__asyncGenerator || function(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i, q2 = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n2) {
    if (g2[n2])
      i[n2] = function(v2) {
        return new Promise(function(a, b2) {
          q2.push([n2, v2, a, b2]) > 1 || resume(n2, v2);
        });
      };
  }
  function resume(n2, v2) {
    try {
      step(g2[n2](v2));
    } catch (e2) {
      settle(q2[0][3], e2);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f2, v2) {
    if (f2(v2), q2.shift(), q2.length)
      resume(q2[0][0], q2[0][1]);
  }
};
Object.defineProperty(isReadableStreamLike$1, "__esModule", { value: true });
isReadableStreamLike$1.isReadableStreamLike = isReadableStreamLike$1.readableStreamLikeToAsyncGenerator = void 0;
var isFunction_1$h = isFunction$2;
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a, value, done;
    return __generator$6(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          return [4, __await(reader.read())];
        case 3:
          _a = _b.sent(), value = _a.value, done = _a.done;
          if (!done)
            return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
isReadableStreamLike$1.readableStreamLikeToAsyncGenerator = readableStreamLikeToAsyncGenerator;
function isReadableStreamLike(obj) {
  return isFunction_1$h.isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}
isReadableStreamLike$1.isReadableStreamLike = isReadableStreamLike;
var __awaiter$4 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$5 = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __asyncValues = commonjsGlobal && commonjsGlobal.__asyncValues || function(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o[Symbol.asyncIterator], i;
  return m2 ? m2.call(o) : (o = typeof __values$6 === "function" ? __values$6(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n2) {
    i[n2] = o[n2] && function(v2) {
      return new Promise(function(resolve2, reject) {
        v2 = o[n2](v2), settle(resolve2, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve2, reject, d, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve2({ value: v3, done: d });
    }, reject);
  }
};
var __values$6 = commonjsGlobal && commonjsGlobal.__values || function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o[s], i = 0;
  if (m2)
    return m2.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(innerFrom$1, "__esModule", { value: true });
innerFrom$1.fromReadableStreamLike = innerFrom$1.fromAsyncIterable = innerFrom$1.fromIterable = innerFrom$1.fromPromise = innerFrom$1.fromArrayLike = innerFrom$1.fromInteropObservable = innerFrom$1.innerFrom = void 0;
var isArrayLike_1$3 = isArrayLike;
var isPromise_1$1 = isPromise$2;
var Observable_1$k = Observable$1;
var isInteropObservable_1$1 = isInteropObservable$1;
var isAsyncIterable_1$1 = isAsyncIterable$1;
var throwUnobservableError_1$1 = throwUnobservableError;
var isIterable_1$1 = isIterable$1;
var isReadableStreamLike_1$2 = isReadableStreamLike$1;
var isFunction_1$g = isFunction$2;
var reportUnhandledError_1 = reportUnhandledError$1;
var observable_1 = observable;
function innerFrom(input) {
  if (input instanceof Observable_1$k.Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable_1$1.isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike_1$3.isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise_1$1.isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable_1$1.isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable_1$1.isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike_1$2.isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw throwUnobservableError_1$1.createInvalidObservableTypeError(input);
}
innerFrom$1.innerFrom = innerFrom;
function fromInteropObservable(obj) {
  return new Observable_1$k.Observable(function(subscriber) {
    var obs = obj[observable_1.observable]();
    if (isFunction_1$g.isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
innerFrom$1.fromInteropObservable = fromInteropObservable;
function fromArrayLike(array) {
  return new Observable_1$k.Observable(function(subscriber) {
    for (var i = 0; i < array.length && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }
    subscriber.complete();
  });
}
innerFrom$1.fromArrayLike = fromArrayLike;
function fromPromise(promise) {
  return new Observable_1$k.Observable(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError_1.reportUnhandledError);
  });
}
innerFrom$1.fromPromise = fromPromise;
function fromIterable(iterable) {
  return new Observable_1$k.Observable(function(subscriber) {
    var e_1, _a;
    try {
      for (var iterable_1 = __values$6(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
          _a.call(iterable_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
innerFrom$1.fromIterable = fromIterable;
function fromAsyncIterable(asyncIterable) {
  return new Observable_1$k.Observable(function(subscriber) {
    process$1(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
innerFrom$1.fromAsyncIterable = fromAsyncIterable;
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(isReadableStreamLike_1$2.readableStreamLikeToAsyncGenerator(readableStream));
}
innerFrom$1.fromReadableStreamLike = fromReadableStreamLike;
function process$1(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a;
  return __awaiter$4(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator$5(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done))
            return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)))
            return [3, 8];
          return [4, _a.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2)
            throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}
var observeOn$1 = {};
var executeSchedule$1 = {};
Object.defineProperty(executeSchedule$1, "__esModule", { value: true });
executeSchedule$1.executeSchedule = void 0;
function executeSchedule(parentSubscription, scheduler2, work, delay2, repeat2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  if (repeat2 === void 0) {
    repeat2 = false;
  }
  var scheduleSubscription = scheduler2.schedule(function() {
    work();
    if (repeat2) {
      parentSubscription.add(this.schedule(null, delay2));
    } else {
      this.unsubscribe();
    }
  }, delay2);
  parentSubscription.add(scheduleSubscription);
  if (!repeat2) {
    return scheduleSubscription;
  }
}
executeSchedule$1.executeSchedule = executeSchedule;
Object.defineProperty(observeOn$1, "__esModule", { value: true });
observeOn$1.observeOn = void 0;
var executeSchedule_1$6 = executeSchedule$1;
var lift_1$12 = lift$1;
var OperatorSubscriber_1$T = OperatorSubscriber$1;
function observeOn(scheduler2, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return lift_1$12.operate(function(source, subscriber) {
    source.subscribe(OperatorSubscriber_1$T.createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule_1$6.executeSchedule(subscriber, scheduler2, function() {
        return subscriber.next(value);
      }, delay2);
    }, function() {
      return executeSchedule_1$6.executeSchedule(subscriber, scheduler2, function() {
        return subscriber.complete();
      }, delay2);
    }, function(err) {
      return executeSchedule_1$6.executeSchedule(subscriber, scheduler2, function() {
        return subscriber.error(err);
      }, delay2);
    }));
  });
}
observeOn$1.observeOn = observeOn;
var subscribeOn$1 = {};
Object.defineProperty(subscribeOn$1, "__esModule", { value: true });
subscribeOn$1.subscribeOn = void 0;
var lift_1$11 = lift$1;
function subscribeOn(scheduler2, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return lift_1$11.operate(function(source, subscriber) {
    subscriber.add(scheduler2.schedule(function() {
      return source.subscribe(subscriber);
    }, delay2));
  });
}
subscribeOn$1.subscribeOn = subscribeOn;
Object.defineProperty(scheduleObservable$1, "__esModule", { value: true });
scheduleObservable$1.scheduleObservable = void 0;
var innerFrom_1$D = innerFrom$1;
var observeOn_1$2 = observeOn$1;
var subscribeOn_1$2 = subscribeOn$1;
function scheduleObservable(input, scheduler2) {
  return innerFrom_1$D.innerFrom(input).pipe(subscribeOn_1$2.subscribeOn(scheduler2), observeOn_1$2.observeOn(scheduler2));
}
scheduleObservable$1.scheduleObservable = scheduleObservable;
var schedulePromise$1 = {};
Object.defineProperty(schedulePromise$1, "__esModule", { value: true });
schedulePromise$1.schedulePromise = void 0;
var innerFrom_1$C = innerFrom$1;
var observeOn_1$1 = observeOn$1;
var subscribeOn_1$1 = subscribeOn$1;
function schedulePromise(input, scheduler2) {
  return innerFrom_1$C.innerFrom(input).pipe(subscribeOn_1$1.subscribeOn(scheduler2), observeOn_1$1.observeOn(scheduler2));
}
schedulePromise$1.schedulePromise = schedulePromise;
var scheduleArray$1 = {};
Object.defineProperty(scheduleArray$1, "__esModule", { value: true });
scheduleArray$1.scheduleArray = void 0;
var Observable_1$j = Observable$1;
function scheduleArray(input, scheduler2) {
  return new Observable_1$j.Observable(function(subscriber) {
    var i = 0;
    return scheduler2.schedule(function() {
      if (i === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}
scheduleArray$1.scheduleArray = scheduleArray;
var scheduleIterable$1 = {};
Object.defineProperty(scheduleIterable$1, "__esModule", { value: true });
scheduleIterable$1.scheduleIterable = void 0;
var Observable_1$i = Observable$1;
var iterator_1 = iterator;
var isFunction_1$f = isFunction$2;
var executeSchedule_1$5 = executeSchedule$1;
function scheduleIterable(input, scheduler2) {
  return new Observable_1$i.Observable(function(subscriber) {
    var iterator2;
    executeSchedule_1$5.executeSchedule(subscriber, scheduler2, function() {
      iterator2 = input[iterator_1.iterator]();
      executeSchedule_1$5.executeSchedule(subscriber, scheduler2, function() {
        var _a;
        var value;
        var done;
        try {
          _a = iterator2.next(), value = _a.value, done = _a.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction_1$f.isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
    };
  });
}
scheduleIterable$1.scheduleIterable = scheduleIterable;
var scheduleAsyncIterable$1 = {};
Object.defineProperty(scheduleAsyncIterable$1, "__esModule", { value: true });
scheduleAsyncIterable$1.scheduleAsyncIterable = void 0;
var Observable_1$h = Observable$1;
var executeSchedule_1$4 = executeSchedule$1;
function scheduleAsyncIterable(input, scheduler2) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable_1$h.Observable(function(subscriber) {
    executeSchedule_1$4.executeSchedule(subscriber, scheduler2, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule_1$4.executeSchedule(subscriber, scheduler2, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}
scheduleAsyncIterable$1.scheduleAsyncIterable = scheduleAsyncIterable;
var scheduleReadableStreamLike$1 = {};
Object.defineProperty(scheduleReadableStreamLike$1, "__esModule", { value: true });
scheduleReadableStreamLike$1.scheduleReadableStreamLike = void 0;
var scheduleAsyncIterable_1$1 = scheduleAsyncIterable$1;
var isReadableStreamLike_1$1 = isReadableStreamLike$1;
function scheduleReadableStreamLike(input, scheduler2) {
  return scheduleAsyncIterable_1$1.scheduleAsyncIterable(isReadableStreamLike_1$1.readableStreamLikeToAsyncGenerator(input), scheduler2);
}
scheduleReadableStreamLike$1.scheduleReadableStreamLike = scheduleReadableStreamLike;
Object.defineProperty(scheduled$1, "__esModule", { value: true });
scheduled$1.scheduled = void 0;
var scheduleObservable_1 = scheduleObservable$1;
var schedulePromise_1 = schedulePromise$1;
var scheduleArray_1 = scheduleArray$1;
var scheduleIterable_1$1 = scheduleIterable$1;
var scheduleAsyncIterable_1 = scheduleAsyncIterable$1;
var isInteropObservable_1 = isInteropObservable$1;
var isPromise_1 = isPromise$2;
var isArrayLike_1$2 = isArrayLike;
var isIterable_1 = isIterable$1;
var isAsyncIterable_1 = isAsyncIterable$1;
var throwUnobservableError_1 = throwUnobservableError;
var isReadableStreamLike_1 = isReadableStreamLike$1;
var scheduleReadableStreamLike_1 = scheduleReadableStreamLike$1;
function scheduled(input, scheduler2) {
  if (input != null) {
    if (isInteropObservable_1.isInteropObservable(input)) {
      return scheduleObservable_1.scheduleObservable(input, scheduler2);
    }
    if (isArrayLike_1$2.isArrayLike(input)) {
      return scheduleArray_1.scheduleArray(input, scheduler2);
    }
    if (isPromise_1.isPromise(input)) {
      return schedulePromise_1.schedulePromise(input, scheduler2);
    }
    if (isAsyncIterable_1.isAsyncIterable(input)) {
      return scheduleAsyncIterable_1.scheduleAsyncIterable(input, scheduler2);
    }
    if (isIterable_1.isIterable(input)) {
      return scheduleIterable_1$1.scheduleIterable(input, scheduler2);
    }
    if (isReadableStreamLike_1.isReadableStreamLike(input)) {
      return scheduleReadableStreamLike_1.scheduleReadableStreamLike(input, scheduler2);
    }
  }
  throw throwUnobservableError_1.createInvalidObservableTypeError(input);
}
scheduled$1.scheduled = scheduled;
Object.defineProperty(from$2, "__esModule", { value: true });
from$2.from = void 0;
var scheduled_1 = scheduled$1;
var innerFrom_1$B = innerFrom$1;
function from$1(input, scheduler2) {
  return scheduler2 ? scheduled_1.scheduled(input, scheduler2) : innerFrom_1$B.innerFrom(input);
}
from$2.from = from$1;
Object.defineProperty(of$1, "__esModule", { value: true });
of$1.of = void 0;
var args_1$c = args;
var from_1$6 = from$2;
function of() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  var scheduler2 = args_1$c.popScheduler(args2);
  return from_1$6.from(args2, scheduler2);
}
of$1.of = of;
var throwError$1 = {};
Object.defineProperty(throwError$1, "__esModule", { value: true });
throwError$1.throwError = void 0;
var Observable_1$g = Observable$1;
var isFunction_1$e = isFunction$2;
function throwError(errorOrErrorFactory, scheduler2) {
  var errorFactory = isFunction_1$e.isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
    return errorOrErrorFactory;
  };
  var init = function(subscriber) {
    return subscriber.error(errorFactory());
  };
  return new Observable_1$g.Observable(scheduler2 ? function(subscriber) {
    return scheduler2.schedule(init, 0, subscriber);
  } : init);
}
throwError$1.throwError = throwError;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.observeNotification = exports.Notification = exports.NotificationKind = void 0;
  var empty_12 = empty;
  var of_12 = of$1;
  var throwError_1 = throwError$1;
  var isFunction_12 = isFunction$2;
  (function(NotificationKind) {
    NotificationKind["NEXT"] = "N";
    NotificationKind["ERROR"] = "E";
    NotificationKind["COMPLETE"] = "C";
  })(exports.NotificationKind || (exports.NotificationKind = {}));
  var Notification2 = function() {
    function Notification3(kind, value, error) {
      this.kind = kind;
      this.value = value;
      this.error = error;
      this.hasValue = kind === "N";
    }
    Notification3.prototype.observe = function(observer) {
      return observeNotification(this, observer);
    };
    Notification3.prototype.do = function(nextHandler, errorHandler, completeHandler) {
      var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
      return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
    };
    Notification3.prototype.accept = function(nextOrObserver, error, complete) {
      var _a;
      return isFunction_12.isFunction((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
    };
    Notification3.prototype.toObservable = function() {
      var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
      var result = kind === "N" ? of_12.of(value) : kind === "E" ? throwError_1.throwError(function() {
        return error;
      }) : kind === "C" ? empty_12.EMPTY : 0;
      if (!result) {
        throw new TypeError("Unexpected notification kind " + kind);
      }
      return result;
    };
    Notification3.createNext = function(value) {
      return new Notification3("N", value);
    };
    Notification3.createError = function(err) {
      return new Notification3("E", void 0, err);
    };
    Notification3.createComplete = function() {
      return Notification3.completeNotification;
    };
    Notification3.completeNotification = new Notification3("C");
    return Notification3;
  }();
  exports.Notification = Notification2;
  function observeNotification(notification, observer) {
    var _a, _b, _c;
    var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
    if (typeof kind !== "string") {
      throw new TypeError('Invalid notification, missing "kind"');
    }
    kind === "N" ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
  }
  exports.observeNotification = observeNotification;
})(Notification);
var isObservable$1 = {};
Object.defineProperty(isObservable$1, "__esModule", { value: true });
isObservable$1.isObservable = void 0;
var Observable_1$f = Observable$1;
var isFunction_1$d = isFunction$2;
function isObservable(obj) {
  return !!obj && (obj instanceof Observable_1$f.Observable || isFunction_1$d.isFunction(obj.lift) && isFunction_1$d.isFunction(obj.subscribe));
}
isObservable$1.isObservable = isObservable;
var lastValueFrom$1 = {};
var EmptyError = {};
Object.defineProperty(EmptyError, "__esModule", { value: true });
EmptyError.EmptyError = void 0;
var createErrorClass_1$3 = createErrorClass$1;
EmptyError.EmptyError = createErrorClass_1$3.createErrorClass(function(_super) {
  return function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  };
});
Object.defineProperty(lastValueFrom$1, "__esModule", { value: true });
lastValueFrom$1.lastValueFrom = void 0;
var EmptyError_1$5 = EmptyError;
function lastValueFrom(source, config2) {
  var hasConfig = typeof config2 === "object";
  return new Promise(function(resolve2, reject) {
    var _hasValue = false;
    var _value;
    source.subscribe({
      next: function(value) {
        _value = value;
        _hasValue = true;
      },
      error: reject,
      complete: function() {
        if (_hasValue) {
          resolve2(_value);
        } else if (hasConfig) {
          resolve2(config2.defaultValue);
        } else {
          reject(new EmptyError_1$5.EmptyError());
        }
      }
    });
  });
}
lastValueFrom$1.lastValueFrom = lastValueFrom;
var firstValueFrom$1 = {};
Object.defineProperty(firstValueFrom$1, "__esModule", { value: true });
firstValueFrom$1.firstValueFrom = void 0;
var EmptyError_1$4 = EmptyError;
var Subscriber_1$1 = Subscriber;
function firstValueFrom(source, config2) {
  var hasConfig = typeof config2 === "object";
  return new Promise(function(resolve2, reject) {
    var subscriber = new Subscriber_1$1.SafeSubscriber({
      next: function(value) {
        resolve2(value);
        subscriber.unsubscribe();
      },
      error: reject,
      complete: function() {
        if (hasConfig) {
          resolve2(config2.defaultValue);
        } else {
          reject(new EmptyError_1$4.EmptyError());
        }
      }
    });
    source.subscribe(subscriber);
  });
}
firstValueFrom$1.firstValueFrom = firstValueFrom;
var ArgumentOutOfRangeError = {};
Object.defineProperty(ArgumentOutOfRangeError, "__esModule", { value: true });
ArgumentOutOfRangeError.ArgumentOutOfRangeError = void 0;
var createErrorClass_1$2 = createErrorClass$1;
ArgumentOutOfRangeError.ArgumentOutOfRangeError = createErrorClass_1$2.createErrorClass(function(_super) {
  return function ArgumentOutOfRangeErrorImpl() {
    _super(this);
    this.name = "ArgumentOutOfRangeError";
    this.message = "argument out of range";
  };
});
var NotFoundError = {};
Object.defineProperty(NotFoundError, "__esModule", { value: true });
NotFoundError.NotFoundError = void 0;
var createErrorClass_1$1 = createErrorClass$1;
NotFoundError.NotFoundError = createErrorClass_1$1.createErrorClass(function(_super) {
  return function NotFoundErrorImpl(message) {
    _super(this);
    this.name = "NotFoundError";
    this.message = message;
  };
});
var SequenceError = {};
Object.defineProperty(SequenceError, "__esModule", { value: true });
SequenceError.SequenceError = void 0;
var createErrorClass_1 = createErrorClass$1;
SequenceError.SequenceError = createErrorClass_1.createErrorClass(function(_super) {
  return function SequenceErrorImpl(message) {
    _super(this);
    this.name = "SequenceError";
    this.message = message;
  };
});
var timeout = {};
var isDate$1 = {};
Object.defineProperty(isDate$1, "__esModule", { value: true });
isDate$1.isValidDate = void 0;
function isValidDate(value) {
  return value instanceof Date && !isNaN(value);
}
isDate$1.isValidDate = isValidDate;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.timeout = exports.TimeoutError = void 0;
  var async_12 = async;
  var isDate_12 = isDate$1;
  var lift_12 = lift$1;
  var innerFrom_12 = innerFrom$1;
  var createErrorClass_12 = createErrorClass$1;
  var OperatorSubscriber_12 = OperatorSubscriber$1;
  var executeSchedule_12 = executeSchedule$1;
  exports.TimeoutError = createErrorClass_12.createErrorClass(function(_super) {
    return function TimeoutErrorImpl(info) {
      if (info === void 0) {
        info = null;
      }
      _super(this);
      this.message = "Timeout has occurred";
      this.name = "TimeoutError";
      this.info = info;
    };
  });
  function timeout2(config2, schedulerArg) {
    var _a = isDate_12.isValidDate(config2) ? { first: config2 } : typeof config2 === "number" ? { each: config2 } : config2, first2 = _a.first, each = _a.each, _b = _a.with, _with = _b === void 0 ? timeoutErrorFactory : _b, _c = _a.scheduler, scheduler2 = _c === void 0 ? schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : async_12.asyncScheduler : _c, _d = _a.meta, meta = _d === void 0 ? null : _d;
    if (first2 == null && each == null) {
      throw new TypeError("No timeout provided.");
    }
    return lift_12.operate(function(source, subscriber) {
      var originalSourceSubscription;
      var timerSubscription;
      var lastValue = null;
      var seen = 0;
      var startTimer = function(delay2) {
        timerSubscription = executeSchedule_12.executeSchedule(subscriber, scheduler2, function() {
          try {
            originalSourceSubscription.unsubscribe();
            innerFrom_12.innerFrom(_with({
              meta,
              lastValue,
              seen
            })).subscribe(subscriber);
          } catch (err) {
            subscriber.error(err);
          }
        }, delay2);
      };
      originalSourceSubscription = source.subscribe(OperatorSubscriber_12.createOperatorSubscriber(subscriber, function(value) {
        timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
        seen++;
        subscriber.next(lastValue = value);
        each > 0 && startTimer(each);
      }, void 0, void 0, function() {
        if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {
          timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
        }
        lastValue = null;
      }));
      !seen && startTimer(first2 != null ? typeof first2 === "number" ? first2 : +first2 - scheduler2.now() : each);
    });
  }
  exports.timeout = timeout2;
  function timeoutErrorFactory(info) {
    throw new exports.TimeoutError(info);
  }
})(timeout);
var bindCallback$1 = {};
var bindCallbackInternals$1 = {};
var mapOneOrManyArgs$1 = {};
var map$1 = {};
Object.defineProperty(map$1, "__esModule", { value: true });
map$1.map = void 0;
var lift_1$10 = lift$1;
var OperatorSubscriber_1$S = OperatorSubscriber$1;
function map(project, thisArg) {
  return lift_1$10.operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(OperatorSubscriber_1$S.createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index++));
    }));
  });
}
map$1.map = map;
var __read$g = commonjsGlobal && commonjsGlobal.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray$h = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i = 0, il2 = from2.length, j2 = to.length; i < il2; i++, j2++)
    to[j2] = from2[i];
  return to;
};
Object.defineProperty(mapOneOrManyArgs$1, "__esModule", { value: true });
mapOneOrManyArgs$1.mapOneOrManyArgs = void 0;
var map_1$5 = map$1;
var isArray$3 = Array.isArray;
function callOrApply(fn, args2) {
  return isArray$3(args2) ? fn.apply(void 0, __spreadArray$h([], __read$g(args2))) : fn(args2);
}
function mapOneOrManyArgs(fn) {
  return map_1$5.map(function(args2) {
    return callOrApply(fn, args2);
  });
}
mapOneOrManyArgs$1.mapOneOrManyArgs = mapOneOrManyArgs;
var __read$f = commonjsGlobal && commonjsGlobal.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray$g = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i = 0, il2 = from2.length, j2 = to.length; i < il2; i++, j2++)
    to[j2] = from2[i];
  return to;
};
Object.defineProperty(bindCallbackInternals$1, "__esModule", { value: true });
bindCallbackInternals$1.bindCallbackInternals = void 0;
var isScheduler_1$2 = isScheduler$1;
var Observable_1$e = Observable$1;
var subscribeOn_1 = subscribeOn$1;
var mapOneOrManyArgs_1$6 = mapOneOrManyArgs$1;
var observeOn_1 = observeOn$1;
var AsyncSubject_1$1 = AsyncSubject$1;
function bindCallbackInternals(isNodeStyle, callbackFunc, resultSelector, scheduler2) {
  if (resultSelector) {
    if (isScheduler_1$2.isScheduler(resultSelector)) {
      scheduler2 = resultSelector;
    } else {
      return function() {
        var args2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args2[_i] = arguments[_i];
        }
        return bindCallbackInternals(isNodeStyle, callbackFunc, scheduler2).apply(this, args2).pipe(mapOneOrManyArgs_1$6.mapOneOrManyArgs(resultSelector));
      };
    }
  }
  if (scheduler2) {
    return function() {
      var args2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i];
      }
      return bindCallbackInternals(isNodeStyle, callbackFunc).apply(this, args2).pipe(subscribeOn_1.subscribeOn(scheduler2), observeOn_1.observeOn(scheduler2));
    };
  }
  return function() {
    var _this = this;
    var args2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args2[_i] = arguments[_i];
    }
    var subject = new AsyncSubject_1$1.AsyncSubject();
    var uninitialized = true;
    return new Observable_1$e.Observable(function(subscriber) {
      var subs = subject.subscribe(subscriber);
      if (uninitialized) {
        uninitialized = false;
        var isAsync_1 = false;
        var isComplete_1 = false;
        callbackFunc.apply(_this, __spreadArray$g(__spreadArray$g([], __read$f(args2)), [
          function() {
            var results = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              results[_i2] = arguments[_i2];
            }
            if (isNodeStyle) {
              var err = results.shift();
              if (err != null) {
                subject.error(err);
                return;
              }
            }
            subject.next(1 < results.length ? results : results[0]);
            isComplete_1 = true;
            if (isAsync_1) {
              subject.complete();
            }
          }
        ]));
        if (isComplete_1) {
          subject.complete();
        }
        isAsync_1 = true;
      }
      return subs;
    });
  };
}
bindCallbackInternals$1.bindCallbackInternals = bindCallbackInternals;
Object.defineProperty(bindCallback$1, "__esModule", { value: true });
bindCallback$1.bindCallback = void 0;
var bindCallbackInternals_1$1 = bindCallbackInternals$1;
function bindCallback(callbackFunc, resultSelector, scheduler2) {
  return bindCallbackInternals_1$1.bindCallbackInternals(false, callbackFunc, resultSelector, scheduler2);
}
bindCallback$1.bindCallback = bindCallback;
var bindNodeCallback$1 = {};
Object.defineProperty(bindNodeCallback$1, "__esModule", { value: true });
bindNodeCallback$1.bindNodeCallback = void 0;
var bindCallbackInternals_1 = bindCallbackInternals$1;
function bindNodeCallback(callbackFunc, resultSelector, scheduler2) {
  return bindCallbackInternals_1.bindCallbackInternals(true, callbackFunc, resultSelector, scheduler2);
}
bindNodeCallback$1.bindNodeCallback = bindNodeCallback;
var combineLatest$3 = {};
var argsArgArrayOrObject$1 = {};
Object.defineProperty(argsArgArrayOrObject$1, "__esModule", { value: true });
argsArgArrayOrObject$1.argsArgArrayOrObject = void 0;
var isArray$2 = Array.isArray;
var getPrototypeOf = Object.getPrototypeOf, objectProto = Object.prototype, getKeys = Object.keys;
function argsArgArrayOrObject(args2) {
  if (args2.length === 1) {
    var first_1 = args2[0];
    if (isArray$2(first_1)) {
      return { args: first_1, keys: null };
    }
    if (isPOJO(first_1)) {
      var keys = getKeys(first_1);
      return {
        args: keys.map(function(key) {
          return first_1[key];
        }),
        keys
      };
    }
  }
  return { args: args2, keys: null };
}
argsArgArrayOrObject$1.argsArgArrayOrObject = argsArgArrayOrObject;
function isPOJO(obj) {
  return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
}
var createObject$1 = {};
Object.defineProperty(createObject$1, "__esModule", { value: true });
createObject$1.createObject = void 0;
function createObject(keys, values) {
  return keys.reduce(function(result, key, i) {
    return result[key] = values[i], result;
  }, {});
}
createObject$1.createObject = createObject;
Object.defineProperty(combineLatest$3, "__esModule", { value: true });
combineLatest$3.combineLatestInit = combineLatest$3.combineLatest = void 0;
var Observable_1$d = Observable$1;
var argsArgArrayOrObject_1$1 = argsArgArrayOrObject$1;
var from_1$5 = from$2;
var identity_1$e = identity$2;
var mapOneOrManyArgs_1$5 = mapOneOrManyArgs$1;
var args_1$b = args;
var createObject_1$1 = createObject$1;
var OperatorSubscriber_1$R = OperatorSubscriber$1;
var executeSchedule_1$3 = executeSchedule$1;
function combineLatest$2() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  var scheduler2 = args_1$b.popScheduler(args2);
  var resultSelector = args_1$b.popResultSelector(args2);
  var _a = argsArgArrayOrObject_1$1.argsArgArrayOrObject(args2), observables = _a.args, keys = _a.keys;
  if (observables.length === 0) {
    return from_1$5.from([], scheduler2);
  }
  var result = new Observable_1$d.Observable(combineLatestInit(observables, scheduler2, keys ? function(values) {
    return createObject_1$1.createObject(keys, values);
  } : identity_1$e.identity));
  return resultSelector ? result.pipe(mapOneOrManyArgs_1$5.mapOneOrManyArgs(resultSelector)) : result;
}
combineLatest$3.combineLatest = combineLatest$2;
function combineLatestInit(observables, scheduler2, valueTransform) {
  if (valueTransform === void 0) {
    valueTransform = identity_1$e.identity;
  }
  return function(subscriber) {
    maybeSchedule(scheduler2, function() {
      var length2 = observables.length;
      var values = new Array(length2);
      var active = length2;
      var remainingFirstValues = length2;
      var _loop_1 = function(i2) {
        maybeSchedule(scheduler2, function() {
          var source = from_1$5.from(observables[i2], scheduler2);
          var hasFirstValue = false;
          source.subscribe(OperatorSubscriber_1$R.createOperatorSubscriber(subscriber, function(value) {
            values[i2] = value;
            if (!hasFirstValue) {
              hasFirstValue = true;
              remainingFirstValues--;
            }
            if (!remainingFirstValues) {
              subscriber.next(valueTransform(values.slice()));
            }
          }, function() {
            if (!--active) {
              subscriber.complete();
            }
          }));
        }, subscriber);
      };
      for (var i = 0; i < length2; i++) {
        _loop_1(i);
      }
    }, subscriber);
  };
}
combineLatest$3.combineLatestInit = combineLatestInit;
function maybeSchedule(scheduler2, execute, subscription) {
  if (scheduler2) {
    executeSchedule_1$3.executeSchedule(subscription, scheduler2, execute);
  } else {
    execute();
  }
}
var concat$3 = {};
var concatAll$1 = {};
var mergeAll$1 = {};
var mergeMap$1 = {};
var mergeInternals$1 = {};
Object.defineProperty(mergeInternals$1, "__esModule", { value: true });
mergeInternals$1.mergeInternals = void 0;
var innerFrom_1$A = innerFrom$1;
var executeSchedule_1$2 = executeSchedule$1;
var OperatorSubscriber_1$Q = OperatorSubscriber$1;
function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand2, innerSubScheduler, additionalFinalizer) {
  var buffer2 = [];
  var active = 0;
  var index = 0;
  var isComplete = false;
  var checkComplete = function() {
    if (isComplete && !buffer2.length && !active) {
      subscriber.complete();
    }
  };
  var outerNext = function(value) {
    return active < concurrent ? doInnerSub(value) : buffer2.push(value);
  };
  var doInnerSub = function(value) {
    expand2 && subscriber.next(value);
    active++;
    var innerComplete = false;
    innerFrom_1$A.innerFrom(project(value, index++)).subscribe(OperatorSubscriber_1$Q.createOperatorSubscriber(subscriber, function(innerValue) {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand2) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, function() {
      innerComplete = true;
    }, void 0, function() {
      if (innerComplete) {
        try {
          active--;
          var _loop_1 = function() {
            var bufferedValue = buffer2.shift();
            if (innerSubScheduler) {
              executeSchedule_1$2.executeSchedule(subscriber, innerSubScheduler, function() {
                return doInnerSub(bufferedValue);
              });
            } else {
              doInnerSub(bufferedValue);
            }
          };
          while (buffer2.length && active < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source.subscribe(OperatorSubscriber_1$Q.createOperatorSubscriber(subscriber, outerNext, function() {
    isComplete = true;
    checkComplete();
  }));
  return function() {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}
mergeInternals$1.mergeInternals = mergeInternals;
Object.defineProperty(mergeMap$1, "__esModule", { value: true });
mergeMap$1.mergeMap = void 0;
var map_1$4 = map$1;
var innerFrom_1$z = innerFrom$1;
var lift_1$$ = lift$1;
var mergeInternals_1$2 = mergeInternals$1;
var isFunction_1$c = isFunction$2;
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction_1$c.isFunction(resultSelector)) {
    return mergeMap(function(a, i) {
      return map_1$4.map(function(b2, ii2) {
        return resultSelector(a, b2, i, ii2);
      })(innerFrom_1$z.innerFrom(project(a, i)));
    }, concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return lift_1$$.operate(function(source, subscriber) {
    return mergeInternals_1$2.mergeInternals(source, subscriber, project, concurrent);
  });
}
mergeMap$1.mergeMap = mergeMap;
Object.defineProperty(mergeAll$1, "__esModule", { value: true });
mergeAll$1.mergeAll = void 0;
var mergeMap_1$6 = mergeMap$1;
var identity_1$d = identity$2;
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return mergeMap_1$6.mergeMap(identity_1$d.identity, concurrent);
}
mergeAll$1.mergeAll = mergeAll;
Object.defineProperty(concatAll$1, "__esModule", { value: true });
concatAll$1.concatAll = void 0;
var mergeAll_1$2 = mergeAll$1;
function concatAll() {
  return mergeAll_1$2.mergeAll(1);
}
concatAll$1.concatAll = concatAll;
Object.defineProperty(concat$3, "__esModule", { value: true });
concat$3.concat = void 0;
var concatAll_1$1 = concatAll$1;
var args_1$a = args;
var from_1$4 = from$2;
function concat$2() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  return concatAll_1$1.concatAll()(from_1$4.from(args2, args_1$a.popScheduler(args2)));
}
concat$3.concat = concat$2;
var connectable$1 = {};
var defer$1 = {};
Object.defineProperty(defer$1, "__esModule", { value: true });
defer$1.defer = void 0;
var Observable_1$c = Observable$1;
var innerFrom_1$y = innerFrom$1;
function defer(observableFactory) {
  return new Observable_1$c.Observable(function(subscriber) {
    innerFrom_1$y.innerFrom(observableFactory()).subscribe(subscriber);
  });
}
defer$1.defer = defer;
Object.defineProperty(connectable$1, "__esModule", { value: true });
connectable$1.connectable = void 0;
var Subject_1$b = Subject$1;
var Observable_1$b = Observable$1;
var defer_1$2 = defer$1;
var DEFAULT_CONFIG$1 = {
  connector: function() {
    return new Subject_1$b.Subject();
  },
  resetOnDisconnect: true
};
function connectable(source, config2) {
  if (config2 === void 0) {
    config2 = DEFAULT_CONFIG$1;
  }
  var connection = null;
  var connector = config2.connector, _a = config2.resetOnDisconnect, resetOnDisconnect = _a === void 0 ? true : _a;
  var subject = connector();
  var result = new Observable_1$b.Observable(function(subscriber) {
    return subject.subscribe(subscriber);
  });
  result.connect = function() {
    if (!connection || connection.closed) {
      connection = defer_1$2.defer(function() {
        return source;
      }).subscribe(subject);
      if (resetOnDisconnect) {
        connection.add(function() {
          return subject = connector();
        });
      }
    }
    return connection;
  };
  return result;
}
connectable$1.connectable = connectable;
var forkJoin$1 = {};
Object.defineProperty(forkJoin$1, "__esModule", { value: true });
forkJoin$1.forkJoin = void 0;
var Observable_1$a = Observable$1;
var argsArgArrayOrObject_1 = argsArgArrayOrObject$1;
var innerFrom_1$x = innerFrom$1;
var args_1$9 = args;
var OperatorSubscriber_1$P = OperatorSubscriber$1;
var mapOneOrManyArgs_1$4 = mapOneOrManyArgs$1;
var createObject_1 = createObject$1;
function forkJoin() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  var resultSelector = args_1$9.popResultSelector(args2);
  var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args2), sources = _a.args, keys = _a.keys;
  var result = new Observable_1$a.Observable(function(subscriber) {
    var length2 = sources.length;
    if (!length2) {
      subscriber.complete();
      return;
    }
    var values = new Array(length2);
    var remainingCompletions = length2;
    var remainingEmissions = length2;
    var _loop_1 = function(sourceIndex2) {
      var hasValue = false;
      innerFrom_1$x.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1$P.createOperatorSubscriber(subscriber, function(value) {
        if (!hasValue) {
          hasValue = true;
          remainingEmissions--;
        }
        values[sourceIndex2] = value;
      }, function() {
        return remainingCompletions--;
      }, void 0, function() {
        if (!remainingCompletions || !hasValue) {
          if (!remainingEmissions) {
            subscriber.next(keys ? createObject_1.createObject(keys, values) : values);
          }
          subscriber.complete();
        }
      }));
    };
    for (var sourceIndex = 0; sourceIndex < length2; sourceIndex++) {
      _loop_1(sourceIndex);
    }
  });
  return resultSelector ? result.pipe(mapOneOrManyArgs_1$4.mapOneOrManyArgs(resultSelector)) : result;
}
forkJoin$1.forkJoin = forkJoin;
var fromEvent$1 = {};
var __read$e = commonjsGlobal && commonjsGlobal.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
Object.defineProperty(fromEvent$1, "__esModule", { value: true });
fromEvent$1.fromEvent = void 0;
var innerFrom_1$w = innerFrom$1;
var Observable_1$9 = Observable$1;
var mergeMap_1$5 = mergeMap$1;
var isArrayLike_1$1 = isArrayLike;
var isFunction_1$b = isFunction$2;
var mapOneOrManyArgs_1$3 = mapOneOrManyArgs$1;
var nodeEventEmitterMethods = ["addListener", "removeListener"];
var eventTargetMethods = ["addEventListener", "removeEventListener"];
var jqueryMethods = ["on", "off"];
function fromEvent(target, eventName, options, resultSelector) {
  if (isFunction_1$b.isFunction(options)) {
    resultSelector = options;
    options = void 0;
  }
  if (resultSelector) {
    return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs_1$3.mapOneOrManyArgs(resultSelector));
  }
  var _a = __read$e(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler, options);
    };
  }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a[0], remove = _a[1];
  if (!add) {
    if (isArrayLike_1$1.isArrayLike(target)) {
      return mergeMap_1$5.mergeMap(function(subTarget) {
        return fromEvent(subTarget, eventName, options);
      })(innerFrom_1$w.innerFrom(target));
    }
  }
  if (!add) {
    throw new TypeError("Invalid event target");
  }
  return new Observable_1$9.Observable(function(subscriber) {
    var handler = function() {
      var args2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i];
      }
      return subscriber.next(1 < args2.length ? args2 : args2[0]);
    };
    add(handler);
    return function() {
      return remove(handler);
    };
  });
}
fromEvent$1.fromEvent = fromEvent;
function toCommonHandlerRegistry(target, eventName) {
  return function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler);
    };
  };
}
function isNodeStyleEventEmitter(target) {
  return isFunction_1$b.isFunction(target.addListener) && isFunction_1$b.isFunction(target.removeListener);
}
function isJQueryStyleEventEmitter(target) {
  return isFunction_1$b.isFunction(target.on) && isFunction_1$b.isFunction(target.off);
}
function isEventTarget(target) {
  return isFunction_1$b.isFunction(target.addEventListener) && isFunction_1$b.isFunction(target.removeEventListener);
}
var fromEventPattern$1 = {};
Object.defineProperty(fromEventPattern$1, "__esModule", { value: true });
fromEventPattern$1.fromEventPattern = void 0;
var Observable_1$8 = Observable$1;
var isFunction_1$a = isFunction$2;
var mapOneOrManyArgs_1$2 = mapOneOrManyArgs$1;
function fromEventPattern(addHandler, removeHandler, resultSelector) {
  if (resultSelector) {
    return fromEventPattern(addHandler, removeHandler).pipe(mapOneOrManyArgs_1$2.mapOneOrManyArgs(resultSelector));
  }
  return new Observable_1$8.Observable(function(subscriber) {
    var handler = function() {
      var e2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        e2[_i] = arguments[_i];
      }
      return subscriber.next(e2.length === 1 ? e2[0] : e2);
    };
    var retValue = addHandler(handler);
    return isFunction_1$a.isFunction(removeHandler) ? function() {
      return removeHandler(handler, retValue);
    } : void 0;
  });
}
fromEventPattern$1.fromEventPattern = fromEventPattern;
var generate$1 = {};
var __generator$4 = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
Object.defineProperty(generate$1, "__esModule", { value: true });
generate$1.generate = void 0;
var identity_1$c = identity$2;
var isScheduler_1$1 = isScheduler$1;
var defer_1$1 = defer$1;
var scheduleIterable_1 = scheduleIterable$1;
function generate(initialStateOrOptions, condition, iterate, resultSelectorOrScheduler, scheduler2) {
  var _a, _b;
  var resultSelector;
  var initialState;
  if (arguments.length === 1) {
    _a = initialStateOrOptions, initialState = _a.initialState, condition = _a.condition, iterate = _a.iterate, _b = _a.resultSelector, resultSelector = _b === void 0 ? identity_1$c.identity : _b, scheduler2 = _a.scheduler;
  } else {
    initialState = initialStateOrOptions;
    if (!resultSelectorOrScheduler || isScheduler_1$1.isScheduler(resultSelectorOrScheduler)) {
      resultSelector = identity_1$c.identity;
      scheduler2 = resultSelectorOrScheduler;
    } else {
      resultSelector = resultSelectorOrScheduler;
    }
  }
  function gen() {
    var state;
    return __generator$4(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          state = initialState;
          _a2.label = 1;
        case 1:
          if (!(!condition || condition(state)))
            return [3, 4];
          return [4, resultSelector(state)];
        case 2:
          _a2.sent();
          _a2.label = 3;
        case 3:
          state = iterate(state);
          return [3, 1];
        case 4:
          return [2];
      }
    });
  }
  return defer_1$1.defer(scheduler2 ? function() {
    return scheduleIterable_1.scheduleIterable(gen(), scheduler2);
  } : gen);
}
generate$1.generate = generate;
var iif$1 = {};
Object.defineProperty(iif$1, "__esModule", { value: true });
iif$1.iif = void 0;
var defer_1 = defer$1;
function iif(condition, trueResult, falseResult) {
  return defer_1.defer(function() {
    return condition() ? trueResult : falseResult;
  });
}
iif$1.iif = iif;
var interval$1 = {};
var timer$1 = {};
Object.defineProperty(timer$1, "__esModule", { value: true });
timer$1.timer = void 0;
var Observable_1$7 = Observable$1;
var async_1$a = async;
var isScheduler_1 = isScheduler$1;
var isDate_1$1 = isDate$1;
function timer(dueTime, intervalOrScheduler, scheduler2) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  if (scheduler2 === void 0) {
    scheduler2 = async_1$a.async;
  }
  var intervalDuration = -1;
  if (intervalOrScheduler != null) {
    if (isScheduler_1.isScheduler(intervalOrScheduler)) {
      scheduler2 = intervalOrScheduler;
    } else {
      intervalDuration = intervalOrScheduler;
    }
  }
  return new Observable_1$7.Observable(function(subscriber) {
    var due = isDate_1$1.isValidDate(dueTime) ? +dueTime - scheduler2.now() : dueTime;
    if (due < 0) {
      due = 0;
    }
    var n2 = 0;
    return scheduler2.schedule(function() {
      if (!subscriber.closed) {
        subscriber.next(n2++);
        if (0 <= intervalDuration) {
          this.schedule(void 0, intervalDuration);
        } else {
          subscriber.complete();
        }
      }
    }, due);
  });
}
timer$1.timer = timer;
Object.defineProperty(interval$1, "__esModule", { value: true });
interval$1.interval = void 0;
var async_1$9 = async;
var timer_1$5 = timer$1;
function interval(period, scheduler2) {
  if (period === void 0) {
    period = 0;
  }
  if (scheduler2 === void 0) {
    scheduler2 = async_1$9.asyncScheduler;
  }
  if (period < 0) {
    period = 0;
  }
  return timer_1$5.timer(period, period, scheduler2);
}
interval$1.interval = interval;
var merge$5 = {};
Object.defineProperty(merge$5, "__esModule", { value: true });
merge$5.merge = void 0;
var mergeAll_1$1 = mergeAll$1;
var innerFrom_1$v = innerFrom$1;
var empty_1$6 = empty;
var args_1$8 = args;
var from_1$3 = from$2;
function merge$4() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  var scheduler2 = args_1$8.popScheduler(args2);
  var concurrent = args_1$8.popNumber(args2, Infinity);
  var sources = args2;
  return !sources.length ? empty_1$6.EMPTY : sources.length === 1 ? innerFrom_1$v.innerFrom(sources[0]) : mergeAll_1$1.mergeAll(concurrent)(from_1$3.from(sources, scheduler2));
}
merge$5.merge = merge$4;
var never = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.never = exports.NEVER = void 0;
  var Observable_12 = Observable$1;
  var noop_12 = noop$1;
  exports.NEVER = new Observable_12.Observable(noop_12.noop);
  function never2() {
    return exports.NEVER;
  }
  exports.never = never2;
})(never);
var onErrorResumeNext$1 = {};
var argsOrArgArray$1 = {};
Object.defineProperty(argsOrArgArray$1, "__esModule", { value: true });
argsOrArgArray$1.argsOrArgArray = void 0;
var isArray$1 = Array.isArray;
function argsOrArgArray(args2) {
  return args2.length === 1 && isArray$1(args2[0]) ? args2[0] : args2;
}
argsOrArgArray$1.argsOrArgArray = argsOrArgArray;
Object.defineProperty(onErrorResumeNext$1, "__esModule", { value: true });
onErrorResumeNext$1.onErrorResumeNext = void 0;
var Observable_1$6 = Observable$1;
var argsOrArgArray_1$5 = argsOrArgArray$1;
var OperatorSubscriber_1$O = OperatorSubscriber$1;
var noop_1$d = noop$1;
var innerFrom_1$u = innerFrom$1;
function onErrorResumeNext() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  var nextSources = argsOrArgArray_1$5.argsOrArgArray(sources);
  return new Observable_1$6.Observable(function(subscriber) {
    var sourceIndex = 0;
    var subscribeNext = function() {
      if (sourceIndex < nextSources.length) {
        var nextSource = void 0;
        try {
          nextSource = innerFrom_1$u.innerFrom(nextSources[sourceIndex++]);
        } catch (err) {
          subscribeNext();
          return;
        }
        var innerSubscriber = new OperatorSubscriber_1$O.OperatorSubscriber(subscriber, void 0, noop_1$d.noop, noop_1$d.noop);
        nextSource.subscribe(innerSubscriber);
        innerSubscriber.add(subscribeNext);
      } else {
        subscriber.complete();
      }
    };
    subscribeNext();
  });
}
onErrorResumeNext$1.onErrorResumeNext = onErrorResumeNext;
var pairs$1 = {};
Object.defineProperty(pairs$1, "__esModule", { value: true });
pairs$1.pairs = void 0;
var from_1$2 = from$2;
function pairs(obj, scheduler2) {
  return from_1$2.from(Object.entries(obj), scheduler2);
}
pairs$1.pairs = pairs;
var partition$1 = {};
var not$1 = {};
Object.defineProperty(not$1, "__esModule", { value: true });
not$1.not = void 0;
function not(pred, thisArg) {
  return function(value, index) {
    return !pred.call(thisArg, value, index);
  };
}
not$1.not = not;
var filter$2 = {};
Object.defineProperty(filter$2, "__esModule", { value: true });
filter$2.filter = void 0;
var lift_1$_ = lift$1;
var OperatorSubscriber_1$N = OperatorSubscriber$1;
function filter$1(predicate, thisArg) {
  return lift_1$_.operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(OperatorSubscriber_1$N.createOperatorSubscriber(subscriber, function(value) {
      return predicate.call(thisArg, value, index++) && subscriber.next(value);
    }));
  });
}
filter$2.filter = filter$1;
Object.defineProperty(partition$1, "__esModule", { value: true });
partition$1.partition = void 0;
var not_1 = not$1;
var filter_1$5 = filter$2;
var innerFrom_1$t = innerFrom$1;
function partition(source, predicate, thisArg) {
  return [filter_1$5.filter(predicate, thisArg)(innerFrom_1$t.innerFrom(source)), filter_1$5.filter(not_1.not(predicate, thisArg))(innerFrom_1$t.innerFrom(source))];
}
partition$1.partition = partition;
var race$1 = {};
Object.defineProperty(race$1, "__esModule", { value: true });
race$1.raceInit = race$1.race = void 0;
var Observable_1$5 = Observable$1;
var innerFrom_1$s = innerFrom$1;
var argsOrArgArray_1$4 = argsOrArgArray$1;
var OperatorSubscriber_1$M = OperatorSubscriber$1;
function race() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  sources = argsOrArgArray_1$4.argsOrArgArray(sources);
  return sources.length === 1 ? innerFrom_1$s.innerFrom(sources[0]) : new Observable_1$5.Observable(raceInit(sources));
}
race$1.race = race;
function raceInit(sources) {
  return function(subscriber) {
    var subscriptions = [];
    var _loop_1 = function(i2) {
      subscriptions.push(innerFrom_1$s.innerFrom(sources[i2]).subscribe(OperatorSubscriber_1$M.createOperatorSubscriber(subscriber, function(value) {
        if (subscriptions) {
          for (var s = 0; s < subscriptions.length; s++) {
            s !== i2 && subscriptions[s].unsubscribe();
          }
          subscriptions = null;
        }
        subscriber.next(value);
      })));
    };
    for (var i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {
      _loop_1(i);
    }
  };
}
race$1.raceInit = raceInit;
var range$1 = {};
Object.defineProperty(range$1, "__esModule", { value: true });
range$1.range = void 0;
var Observable_1$4 = Observable$1;
var empty_1$5 = empty;
function range(start, count2, scheduler2) {
  if (count2 == null) {
    count2 = start;
    start = 0;
  }
  if (count2 <= 0) {
    return empty_1$5.EMPTY;
  }
  var end = count2 + start;
  return new Observable_1$4.Observable(scheduler2 ? function(subscriber) {
    var n2 = start;
    return scheduler2.schedule(function() {
      if (n2 < end) {
        subscriber.next(n2++);
        this.schedule();
      } else {
        subscriber.complete();
      }
    });
  } : function(subscriber) {
    var n2 = start;
    while (n2 < end && !subscriber.closed) {
      subscriber.next(n2++);
    }
    subscriber.complete();
  });
}
range$1.range = range;
var using$1 = {};
Object.defineProperty(using$1, "__esModule", { value: true });
using$1.using = void 0;
var Observable_1$3 = Observable$1;
var innerFrom_1$r = innerFrom$1;
var empty_1$4 = empty;
function using(resourceFactory, observableFactory) {
  return new Observable_1$3.Observable(function(subscriber) {
    var resource = resourceFactory();
    var result = observableFactory(resource);
    var source = result ? innerFrom_1$r.innerFrom(result) : empty_1$4.EMPTY;
    source.subscribe(subscriber);
    return function() {
      if (resource) {
        resource.unsubscribe();
      }
    };
  });
}
using$1.using = using;
var zip$3 = {};
var __read$d = commonjsGlobal && commonjsGlobal.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray$f = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i = 0, il2 = from2.length, j2 = to.length; i < il2; i++, j2++)
    to[j2] = from2[i];
  return to;
};
Object.defineProperty(zip$3, "__esModule", { value: true });
zip$3.zip = void 0;
var Observable_1$2 = Observable$1;
var innerFrom_1$q = innerFrom$1;
var argsOrArgArray_1$3 = argsOrArgArray$1;
var empty_1$3 = empty;
var OperatorSubscriber_1$L = OperatorSubscriber$1;
var args_1$7 = args;
function zip$2() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  var resultSelector = args_1$7.popResultSelector(args2);
  var sources = argsOrArgArray_1$3.argsOrArgArray(args2);
  return sources.length ? new Observable_1$2.Observable(function(subscriber) {
    var buffers = sources.map(function() {
      return [];
    });
    var completed = sources.map(function() {
      return false;
    });
    subscriber.add(function() {
      buffers = completed = null;
    });
    var _loop_1 = function(sourceIndex2) {
      innerFrom_1$q.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1$L.createOperatorSubscriber(subscriber, function(value) {
        buffers[sourceIndex2].push(value);
        if (buffers.every(function(buffer2) {
          return buffer2.length;
        })) {
          var result = buffers.map(function(buffer2) {
            return buffer2.shift();
          });
          subscriber.next(resultSelector ? resultSelector.apply(void 0, __spreadArray$f([], __read$d(result))) : result);
          if (buffers.some(function(buffer2, i) {
            return !buffer2.length && completed[i];
          })) {
            subscriber.complete();
          }
        }
      }, function() {
        completed[sourceIndex2] = true;
        !buffers[sourceIndex2].length && subscriber.complete();
      }));
    };
    for (var sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {
      _loop_1(sourceIndex);
    }
    return function() {
      buffers = completed = null;
    };
  }) : empty_1$3.EMPTY;
}
zip$3.zip = zip$2;
var types = {};
Object.defineProperty(types, "__esModule", { value: true });
var audit$1 = {};
Object.defineProperty(audit$1, "__esModule", { value: true });
audit$1.audit = void 0;
var lift_1$Z = lift$1;
var innerFrom_1$p = innerFrom$1;
var OperatorSubscriber_1$K = OperatorSubscriber$1;
function audit(durationSelector) {
  return lift_1$Z.operate(function(source, subscriber) {
    var hasValue = false;
    var lastValue = null;
    var durationSubscriber = null;
    var isComplete = false;
    var endDuration = function() {
      durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
      durationSubscriber = null;
      if (hasValue) {
        hasValue = false;
        var value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
      isComplete && subscriber.complete();
    };
    var cleanupDuration = function() {
      durationSubscriber = null;
      isComplete && subscriber.complete();
    };
    source.subscribe(OperatorSubscriber_1$K.createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      lastValue = value;
      if (!durationSubscriber) {
        innerFrom_1$p.innerFrom(durationSelector(value)).subscribe(durationSubscriber = OperatorSubscriber_1$K.createOperatorSubscriber(subscriber, endDuration, cleanupDuration));
      }
    }, function() {
      isComplete = true;
      (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
    }));
  });
}
audit$1.audit = audit;
var auditTime$1 = {};
Object.defineProperty(auditTime$1, "__esModule", { value: true });
auditTime$1.auditTime = void 0;
var async_1$8 = async;
var audit_1 = audit$1;
var timer_1$4 = timer$1;
function auditTime(duration, scheduler2) {
  if (scheduler2 === void 0) {
    scheduler2 = async_1$8.asyncScheduler;
  }
  return audit_1.audit(function() {
    return timer_1$4.timer(duration, scheduler2);
  });
}
auditTime$1.auditTime = auditTime;
var buffer$1 = {};
Object.defineProperty(buffer$1, "__esModule", { value: true });
buffer$1.buffer = void 0;
var lift_1$Y = lift$1;
var noop_1$c = noop$1;
var OperatorSubscriber_1$J = OperatorSubscriber$1;
var innerFrom_1$o = innerFrom$1;
function buffer(closingNotifier) {
  return lift_1$Y.operate(function(source, subscriber) {
    var currentBuffer = [];
    source.subscribe(OperatorSubscriber_1$J.createOperatorSubscriber(subscriber, function(value) {
      return currentBuffer.push(value);
    }, function() {
      subscriber.next(currentBuffer);
      subscriber.complete();
    }));
    innerFrom_1$o.innerFrom(closingNotifier).subscribe(OperatorSubscriber_1$J.createOperatorSubscriber(subscriber, function() {
      var b2 = currentBuffer;
      currentBuffer = [];
      subscriber.next(b2);
    }, noop_1$c.noop));
    return function() {
      currentBuffer = null;
    };
  });
}
buffer$1.buffer = buffer;
var bufferCount$1 = {};
var __values$5 = commonjsGlobal && commonjsGlobal.__values || function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o[s], i = 0;
  if (m2)
    return m2.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(bufferCount$1, "__esModule", { value: true });
bufferCount$1.bufferCount = void 0;
var lift_1$X = lift$1;
var OperatorSubscriber_1$I = OperatorSubscriber$1;
var arrRemove_1$4 = arrRemove$1;
function bufferCount(bufferSize, startBufferEvery) {
  if (startBufferEvery === void 0) {
    startBufferEvery = null;
  }
  startBufferEvery = startBufferEvery !== null && startBufferEvery !== void 0 ? startBufferEvery : bufferSize;
  return lift_1$X.operate(function(source, subscriber) {
    var buffers = [];
    var count2 = 0;
    source.subscribe(OperatorSubscriber_1$I.createOperatorSubscriber(subscriber, function(value) {
      var e_1, _a, e_2, _b;
      var toEmit = null;
      if (count2++ % startBufferEvery === 0) {
        buffers.push([]);
      }
      try {
        for (var buffers_1 = __values$5(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
          var buffer2 = buffers_1_1.value;
          buffer2.push(value);
          if (bufferSize <= buffer2.length) {
            toEmit = toEmit !== null && toEmit !== void 0 ? toEmit : [];
            toEmit.push(buffer2);
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return))
            _a.call(buffers_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      if (toEmit) {
        try {
          for (var toEmit_1 = __values$5(toEmit), toEmit_1_1 = toEmit_1.next(); !toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {
            var buffer2 = toEmit_1_1.value;
            arrRemove_1$4.arrRemove(buffers, buffer2);
            subscriber.next(buffer2);
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (toEmit_1_1 && !toEmit_1_1.done && (_b = toEmit_1.return))
              _b.call(toEmit_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
    }, function() {
      var e_3, _a;
      try {
        for (var buffers_2 = __values$5(buffers), buffers_2_1 = buffers_2.next(); !buffers_2_1.done; buffers_2_1 = buffers_2.next()) {
          var buffer2 = buffers_2_1.value;
          subscriber.next(buffer2);
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (buffers_2_1 && !buffers_2_1.done && (_a = buffers_2.return))
            _a.call(buffers_2);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      subscriber.complete();
    }, void 0, function() {
      buffers = null;
    }));
  });
}
bufferCount$1.bufferCount = bufferCount;
var bufferTime$1 = {};
var __values$4 = commonjsGlobal && commonjsGlobal.__values || function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o[s], i = 0;
  if (m2)
    return m2.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(bufferTime$1, "__esModule", { value: true });
bufferTime$1.bufferTime = void 0;
var Subscription_1$3 = Subscription$1;
var lift_1$W = lift$1;
var OperatorSubscriber_1$H = OperatorSubscriber$1;
var arrRemove_1$3 = arrRemove$1;
var async_1$7 = async;
var args_1$6 = args;
var executeSchedule_1$1 = executeSchedule$1;
function bufferTime(bufferTimeSpan) {
  var _a, _b;
  var otherArgs = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    otherArgs[_i - 1] = arguments[_i];
  }
  var scheduler2 = (_a = args_1$6.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1$7.asyncScheduler;
  var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
  var maxBufferSize = otherArgs[1] || Infinity;
  return lift_1$W.operate(function(source, subscriber) {
    var bufferRecords = [];
    var restartOnEmit = false;
    var emit = function(record) {
      var buffer2 = record.buffer, subs = record.subs;
      subs.unsubscribe();
      arrRemove_1$3.arrRemove(bufferRecords, record);
      subscriber.next(buffer2);
      restartOnEmit && startBuffer();
    };
    var startBuffer = function() {
      if (bufferRecords) {
        var subs = new Subscription_1$3.Subscription();
        subscriber.add(subs);
        var buffer2 = [];
        var record_1 = {
          buffer: buffer2,
          subs
        };
        bufferRecords.push(record_1);
        executeSchedule_1$1.executeSchedule(subs, scheduler2, function() {
          return emit(record_1);
        }, bufferTimeSpan);
      }
    };
    if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
      executeSchedule_1$1.executeSchedule(subscriber, scheduler2, startBuffer, bufferCreationInterval, true);
    } else {
      restartOnEmit = true;
    }
    startBuffer();
    var bufferTimeSubscriber = OperatorSubscriber_1$H.createOperatorSubscriber(subscriber, function(value) {
      var e_1, _a2;
      var recordsCopy = bufferRecords.slice();
      try {
        for (var recordsCopy_1 = __values$4(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
          var record = recordsCopy_1_1.value;
          var buffer2 = record.buffer;
          buffer2.push(value);
          maxBufferSize <= buffer2.length && emit(record);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a2 = recordsCopy_1.return))
            _a2.call(recordsCopy_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }, function() {
      while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {
        subscriber.next(bufferRecords.shift().buffer);
      }
      bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();
      subscriber.complete();
      subscriber.unsubscribe();
    }, void 0, function() {
      return bufferRecords = null;
    });
    source.subscribe(bufferTimeSubscriber);
  });
}
bufferTime$1.bufferTime = bufferTime;
var bufferToggle$1 = {};
var __values$3 = commonjsGlobal && commonjsGlobal.__values || function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o[s], i = 0;
  if (m2)
    return m2.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(bufferToggle$1, "__esModule", { value: true });
bufferToggle$1.bufferToggle = void 0;
var Subscription_1$2 = Subscription$1;
var lift_1$V = lift$1;
var innerFrom_1$n = innerFrom$1;
var OperatorSubscriber_1$G = OperatorSubscriber$1;
var noop_1$b = noop$1;
var arrRemove_1$2 = arrRemove$1;
function bufferToggle(openings, closingSelector) {
  return lift_1$V.operate(function(source, subscriber) {
    var buffers = [];
    innerFrom_1$n.innerFrom(openings).subscribe(OperatorSubscriber_1$G.createOperatorSubscriber(subscriber, function(openValue) {
      var buffer2 = [];
      buffers.push(buffer2);
      var closingSubscription = new Subscription_1$2.Subscription();
      var emitBuffer = function() {
        arrRemove_1$2.arrRemove(buffers, buffer2);
        subscriber.next(buffer2);
        closingSubscription.unsubscribe();
      };
      closingSubscription.add(innerFrom_1$n.innerFrom(closingSelector(openValue)).subscribe(OperatorSubscriber_1$G.createOperatorSubscriber(subscriber, emitBuffer, noop_1$b.noop)));
    }, noop_1$b.noop));
    source.subscribe(OperatorSubscriber_1$G.createOperatorSubscriber(subscriber, function(value) {
      var e_1, _a;
      try {
        for (var buffers_1 = __values$3(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
          var buffer2 = buffers_1_1.value;
          buffer2.push(value);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return))
            _a.call(buffers_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }, function() {
      while (buffers.length > 0) {
        subscriber.next(buffers.shift());
      }
      subscriber.complete();
    }));
  });
}
bufferToggle$1.bufferToggle = bufferToggle;
var bufferWhen$1 = {};
Object.defineProperty(bufferWhen$1, "__esModule", { value: true });
bufferWhen$1.bufferWhen = void 0;
var lift_1$U = lift$1;
var noop_1$a = noop$1;
var OperatorSubscriber_1$F = OperatorSubscriber$1;
var innerFrom_1$m = innerFrom$1;
function bufferWhen(closingSelector) {
  return lift_1$U.operate(function(source, subscriber) {
    var buffer2 = null;
    var closingSubscriber = null;
    var openBuffer = function() {
      closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
      var b2 = buffer2;
      buffer2 = [];
      b2 && subscriber.next(b2);
      innerFrom_1$m.innerFrom(closingSelector()).subscribe(closingSubscriber = OperatorSubscriber_1$F.createOperatorSubscriber(subscriber, openBuffer, noop_1$a.noop));
    };
    openBuffer();
    source.subscribe(OperatorSubscriber_1$F.createOperatorSubscriber(subscriber, function(value) {
      return buffer2 === null || buffer2 === void 0 ? void 0 : buffer2.push(value);
    }, function() {
      buffer2 && subscriber.next(buffer2);
      subscriber.complete();
    }, void 0, function() {
      return buffer2 = closingSubscriber = null;
    }));
  });
}
bufferWhen$1.bufferWhen = bufferWhen;
var catchError$1 = {};
Object.defineProperty(catchError$1, "__esModule", { value: true });
catchError$1.catchError = void 0;
var innerFrom_1$l = innerFrom$1;
var OperatorSubscriber_1$E = OperatorSubscriber$1;
var lift_1$T = lift$1;
function catchError(selector) {
  return lift_1$T.operate(function(source, subscriber) {
    var innerSub = null;
    var syncUnsub = false;
    var handledResult;
    innerSub = source.subscribe(OperatorSubscriber_1$E.createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
      handledResult = innerFrom_1$l.innerFrom(selector(err, catchError(selector)(source)));
      if (innerSub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      } else {
        syncUnsub = true;
      }
    }));
    if (syncUnsub) {
      innerSub.unsubscribe();
      innerSub = null;
      handledResult.subscribe(subscriber);
    }
  });
}
catchError$1.catchError = catchError;
var combineAll = {};
var combineLatestAll$1 = {};
var joinAllInternals$1 = {};
var toArray$1 = {};
var reduce$1 = {};
var scanInternals$1 = {};
Object.defineProperty(scanInternals$1, "__esModule", { value: true });
scanInternals$1.scanInternals = void 0;
var OperatorSubscriber_1$D = OperatorSubscriber$1;
function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
  return function(source, subscriber) {
    var hasState = hasSeed;
    var state = seed;
    var index = 0;
    source.subscribe(OperatorSubscriber_1$D.createOperatorSubscriber(subscriber, function(value) {
      var i = index++;
      state = hasState ? accumulator(state, value, i) : (hasState = true, value);
      emitOnNext && subscriber.next(state);
    }, emitBeforeComplete && function() {
      hasState && subscriber.next(state);
      subscriber.complete();
    }));
  };
}
scanInternals$1.scanInternals = scanInternals;
Object.defineProperty(reduce$1, "__esModule", { value: true });
reduce$1.reduce = void 0;
var scanInternals_1$1 = scanInternals$1;
var lift_1$S = lift$1;
function reduce(accumulator, seed) {
  return lift_1$S.operate(scanInternals_1$1.scanInternals(accumulator, seed, arguments.length >= 2, false, true));
}
reduce$1.reduce = reduce;
Object.defineProperty(toArray$1, "__esModule", { value: true });
toArray$1.toArray = void 0;
var reduce_1$3 = reduce$1;
var lift_1$R = lift$1;
var arrReducer = function(arr, value) {
  return arr.push(value), arr;
};
function toArray() {
  return lift_1$R.operate(function(source, subscriber) {
    reduce_1$3.reduce(arrReducer, [])(source).subscribe(subscriber);
  });
}
toArray$1.toArray = toArray;
Object.defineProperty(joinAllInternals$1, "__esModule", { value: true });
joinAllInternals$1.joinAllInternals = void 0;
var identity_1$b = identity$2;
var mapOneOrManyArgs_1$1 = mapOneOrManyArgs$1;
var pipe_1$1 = pipe$2;
var mergeMap_1$4 = mergeMap$1;
var toArray_1 = toArray$1;
function joinAllInternals(joinFn, project) {
  return pipe_1$1.pipe(toArray_1.toArray(), mergeMap_1$4.mergeMap(function(sources) {
    return joinFn(sources);
  }), project ? mapOneOrManyArgs_1$1.mapOneOrManyArgs(project) : identity_1$b.identity);
}
joinAllInternals$1.joinAllInternals = joinAllInternals;
Object.defineProperty(combineLatestAll$1, "__esModule", { value: true });
combineLatestAll$1.combineLatestAll = void 0;
var combineLatest_1$2 = combineLatest$3;
var joinAllInternals_1$1 = joinAllInternals$1;
function combineLatestAll(project) {
  return joinAllInternals_1$1.joinAllInternals(combineLatest_1$2.combineLatest, project);
}
combineLatestAll$1.combineLatestAll = combineLatestAll;
Object.defineProperty(combineAll, "__esModule", { value: true });
combineAll.combineAll = void 0;
var combineLatestAll_1 = combineLatestAll$1;
combineAll.combineAll = combineLatestAll_1.combineLatestAll;
var combineLatestWith$1 = {};
var combineLatest$1 = {};
var __read$c = commonjsGlobal && commonjsGlobal.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray$e = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i = 0, il2 = from2.length, j2 = to.length; i < il2; i++, j2++)
    to[j2] = from2[i];
  return to;
};
Object.defineProperty(combineLatest$1, "__esModule", { value: true });
combineLatest$1.combineLatest = void 0;
var combineLatest_1$1 = combineLatest$3;
var lift_1$Q = lift$1;
var argsOrArgArray_1$2 = argsOrArgArray$1;
var mapOneOrManyArgs_1 = mapOneOrManyArgs$1;
var pipe_1 = pipe$2;
var args_1$5 = args;
function combineLatest() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  var resultSelector = args_1$5.popResultSelector(args2);
  return resultSelector ? pipe_1.pipe(combineLatest.apply(void 0, __spreadArray$e([], __read$c(args2))), mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : lift_1$Q.operate(function(source, subscriber) {
    combineLatest_1$1.combineLatestInit(__spreadArray$e([source], __read$c(argsOrArgArray_1$2.argsOrArgArray(args2))))(subscriber);
  });
}
combineLatest$1.combineLatest = combineLatest;
var __read$b = commonjsGlobal && commonjsGlobal.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray$d = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i = 0, il2 = from2.length, j2 = to.length; i < il2; i++, j2++)
    to[j2] = from2[i];
  return to;
};
Object.defineProperty(combineLatestWith$1, "__esModule", { value: true });
combineLatestWith$1.combineLatestWith = void 0;
var combineLatest_1 = combineLatest$1;
function combineLatestWith() {
  var otherSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherSources[_i] = arguments[_i];
  }
  return combineLatest_1.combineLatest.apply(void 0, __spreadArray$d([], __read$b(otherSources)));
}
combineLatestWith$1.combineLatestWith = combineLatestWith;
var concatMap$1 = {};
Object.defineProperty(concatMap$1, "__esModule", { value: true });
concatMap$1.concatMap = void 0;
var mergeMap_1$3 = mergeMap$1;
var isFunction_1$9 = isFunction$2;
function concatMap(project, resultSelector) {
  return isFunction_1$9.isFunction(resultSelector) ? mergeMap_1$3.mergeMap(project, resultSelector, 1) : mergeMap_1$3.mergeMap(project, 1);
}
concatMap$1.concatMap = concatMap;
var concatMapTo$1 = {};
Object.defineProperty(concatMapTo$1, "__esModule", { value: true });
concatMapTo$1.concatMapTo = void 0;
var concatMap_1 = concatMap$1;
var isFunction_1$8 = isFunction$2;
function concatMapTo(innerObservable, resultSelector) {
  return isFunction_1$8.isFunction(resultSelector) ? concatMap_1.concatMap(function() {
    return innerObservable;
  }, resultSelector) : concatMap_1.concatMap(function() {
    return innerObservable;
  });
}
concatMapTo$1.concatMapTo = concatMapTo;
var concatWith$1 = {};
var concat$1 = {};
var __read$a = commonjsGlobal && commonjsGlobal.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray$c = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i = 0, il2 = from2.length, j2 = to.length; i < il2; i++, j2++)
    to[j2] = from2[i];
  return to;
};
Object.defineProperty(concat$1, "__esModule", { value: true });
concat$1.concat = void 0;
var lift_1$P = lift$1;
var concatAll_1 = concatAll$1;
var args_1$4 = args;
var from_1$1 = from$2;
function concat() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  var scheduler2 = args_1$4.popScheduler(args2);
  return lift_1$P.operate(function(source, subscriber) {
    concatAll_1.concatAll()(from_1$1.from(__spreadArray$c([source], __read$a(args2)), scheduler2)).subscribe(subscriber);
  });
}
concat$1.concat = concat;
var __read$9 = commonjsGlobal && commonjsGlobal.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray$b = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i = 0, il2 = from2.length, j2 = to.length; i < il2; i++, j2++)
    to[j2] = from2[i];
  return to;
};
Object.defineProperty(concatWith$1, "__esModule", { value: true });
concatWith$1.concatWith = void 0;
var concat_1$3 = concat$1;
function concatWith() {
  var otherSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherSources[_i] = arguments[_i];
  }
  return concat_1$3.concat.apply(void 0, __spreadArray$b([], __read$9(otherSources)));
}
concatWith$1.concatWith = concatWith;
var connect$1 = {};
var fromSubscribable$1 = {};
Object.defineProperty(fromSubscribable$1, "__esModule", { value: true });
fromSubscribable$1.fromSubscribable = void 0;
var Observable_1$1 = Observable$1;
function fromSubscribable(subscribable) {
  return new Observable_1$1.Observable(function(subscriber) {
    return subscribable.subscribe(subscriber);
  });
}
fromSubscribable$1.fromSubscribable = fromSubscribable;
Object.defineProperty(connect$1, "__esModule", { value: true });
connect$1.connect = void 0;
var Subject_1$a = Subject$1;
var innerFrom_1$k = innerFrom$1;
var lift_1$O = lift$1;
var fromSubscribable_1 = fromSubscribable$1;
var DEFAULT_CONFIG = {
  connector: function() {
    return new Subject_1$a.Subject();
  }
};
function connect(selector, config2) {
  if (config2 === void 0) {
    config2 = DEFAULT_CONFIG;
  }
  var connector = config2.connector;
  return lift_1$O.operate(function(source, subscriber) {
    var subject = connector();
    innerFrom_1$k.innerFrom(selector(fromSubscribable_1.fromSubscribable(subject))).subscribe(subscriber);
    subscriber.add(source.subscribe(subject));
  });
}
connect$1.connect = connect;
var count$1 = {};
Object.defineProperty(count$1, "__esModule", { value: true });
count$1.count = void 0;
var reduce_1$2 = reduce$1;
function count(predicate) {
  return reduce_1$2.reduce(function(total, value, i) {
    return !predicate || predicate(value, i) ? total + 1 : total;
  }, 0);
}
count$1.count = count;
var debounce$1 = {};
Object.defineProperty(debounce$1, "__esModule", { value: true });
debounce$1.debounce = void 0;
var lift_1$N = lift$1;
var noop_1$9 = noop$1;
var OperatorSubscriber_1$C = OperatorSubscriber$1;
var innerFrom_1$j = innerFrom$1;
function debounce(durationSelector) {
  return lift_1$N.operate(function(source, subscriber) {
    var hasValue = false;
    var lastValue = null;
    var durationSubscriber = null;
    var emit = function() {
      durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
      durationSubscriber = null;
      if (hasValue) {
        hasValue = false;
        var value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
    };
    source.subscribe(OperatorSubscriber_1$C.createOperatorSubscriber(subscriber, function(value) {
      durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
      hasValue = true;
      lastValue = value;
      durationSubscriber = OperatorSubscriber_1$C.createOperatorSubscriber(subscriber, emit, noop_1$9.noop);
      innerFrom_1$j.innerFrom(durationSelector(value)).subscribe(durationSubscriber);
    }, function() {
      emit();
      subscriber.complete();
    }, void 0, function() {
      lastValue = durationSubscriber = null;
    }));
  });
}
debounce$1.debounce = debounce;
var debounceTime$1 = {};
Object.defineProperty(debounceTime$1, "__esModule", { value: true });
debounceTime$1.debounceTime = void 0;
var async_1$6 = async;
var lift_1$M = lift$1;
var OperatorSubscriber_1$B = OperatorSubscriber$1;
function debounceTime(dueTime, scheduler2) {
  if (scheduler2 === void 0) {
    scheduler2 = async_1$6.asyncScheduler;
  }
  return lift_1$M.operate(function(source, subscriber) {
    var activeTask = null;
    var lastValue = null;
    var lastTime = null;
    var emit = function() {
      if (activeTask) {
        activeTask.unsubscribe();
        activeTask = null;
        var value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
    };
    function emitWhenIdle() {
      var targetTime = lastTime + dueTime;
      var now2 = scheduler2.now();
      if (now2 < targetTime) {
        activeTask = this.schedule(void 0, targetTime - now2);
        subscriber.add(activeTask);
        return;
      }
      emit();
    }
    source.subscribe(OperatorSubscriber_1$B.createOperatorSubscriber(subscriber, function(value) {
      lastValue = value;
      lastTime = scheduler2.now();
      if (!activeTask) {
        activeTask = scheduler2.schedule(emitWhenIdle, dueTime);
        subscriber.add(activeTask);
      }
    }, function() {
      emit();
      subscriber.complete();
    }, void 0, function() {
      lastValue = activeTask = null;
    }));
  });
}
debounceTime$1.debounceTime = debounceTime;
var defaultIfEmpty$1 = {};
Object.defineProperty(defaultIfEmpty$1, "__esModule", { value: true });
defaultIfEmpty$1.defaultIfEmpty = void 0;
var lift_1$L = lift$1;
var OperatorSubscriber_1$A = OperatorSubscriber$1;
function defaultIfEmpty(defaultValue) {
  return lift_1$L.operate(function(source, subscriber) {
    var hasValue = false;
    source.subscribe(OperatorSubscriber_1$A.createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      subscriber.next(value);
    }, function() {
      if (!hasValue) {
        subscriber.next(defaultValue);
      }
      subscriber.complete();
    }));
  });
}
defaultIfEmpty$1.defaultIfEmpty = defaultIfEmpty;
var delay$1 = {};
var delayWhen$1 = {};
var take$1 = {};
Object.defineProperty(take$1, "__esModule", { value: true });
take$1.take = void 0;
var empty_1$2 = empty;
var lift_1$K = lift$1;
var OperatorSubscriber_1$z = OperatorSubscriber$1;
function take(count2) {
  return count2 <= 0 ? function() {
    return empty_1$2.EMPTY;
  } : lift_1$K.operate(function(source, subscriber) {
    var seen = 0;
    source.subscribe(OperatorSubscriber_1$z.createOperatorSubscriber(subscriber, function(value) {
      if (++seen <= count2) {
        subscriber.next(value);
        if (count2 <= seen) {
          subscriber.complete();
        }
      }
    }));
  });
}
take$1.take = take;
var ignoreElements$1 = {};
Object.defineProperty(ignoreElements$1, "__esModule", { value: true });
ignoreElements$1.ignoreElements = void 0;
var lift_1$J = lift$1;
var OperatorSubscriber_1$y = OperatorSubscriber$1;
var noop_1$8 = noop$1;
function ignoreElements() {
  return lift_1$J.operate(function(source, subscriber) {
    source.subscribe(OperatorSubscriber_1$y.createOperatorSubscriber(subscriber, noop_1$8.noop));
  });
}
ignoreElements$1.ignoreElements = ignoreElements;
var mapTo$1 = {};
Object.defineProperty(mapTo$1, "__esModule", { value: true });
mapTo$1.mapTo = void 0;
var map_1$3 = map$1;
function mapTo(value) {
  return map_1$3.map(function() {
    return value;
  });
}
mapTo$1.mapTo = mapTo;
Object.defineProperty(delayWhen$1, "__esModule", { value: true });
delayWhen$1.delayWhen = void 0;
var concat_1$2 = concat$3;
var take_1$2 = take$1;
var ignoreElements_1 = ignoreElements$1;
var mapTo_1 = mapTo$1;
var mergeMap_1$2 = mergeMap$1;
var innerFrom_1$i = innerFrom$1;
function delayWhen(delayDurationSelector, subscriptionDelay) {
  if (subscriptionDelay) {
    return function(source) {
      return concat_1$2.concat(subscriptionDelay.pipe(take_1$2.take(1), ignoreElements_1.ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));
    };
  }
  return mergeMap_1$2.mergeMap(function(value, index) {
    return innerFrom_1$i.innerFrom(delayDurationSelector(value, index)).pipe(take_1$2.take(1), mapTo_1.mapTo(value));
  });
}
delayWhen$1.delayWhen = delayWhen;
Object.defineProperty(delay$1, "__esModule", { value: true });
delay$1.delay = void 0;
var async_1$5 = async;
var delayWhen_1 = delayWhen$1;
var timer_1$3 = timer$1;
function delay(due, scheduler2) {
  if (scheduler2 === void 0) {
    scheduler2 = async_1$5.asyncScheduler;
  }
  var duration = timer_1$3.timer(due, scheduler2);
  return delayWhen_1.delayWhen(function() {
    return duration;
  });
}
delay$1.delay = delay;
var dematerialize$1 = {};
Object.defineProperty(dematerialize$1, "__esModule", { value: true });
dematerialize$1.dematerialize = void 0;
var Notification_1$1 = Notification;
var lift_1$I = lift$1;
var OperatorSubscriber_1$x = OperatorSubscriber$1;
function dematerialize() {
  return lift_1$I.operate(function(source, subscriber) {
    source.subscribe(OperatorSubscriber_1$x.createOperatorSubscriber(subscriber, function(notification) {
      return Notification_1$1.observeNotification(notification, subscriber);
    }));
  });
}
dematerialize$1.dematerialize = dematerialize;
var distinct$1 = {};
Object.defineProperty(distinct$1, "__esModule", { value: true });
distinct$1.distinct = void 0;
var lift_1$H = lift$1;
var OperatorSubscriber_1$w = OperatorSubscriber$1;
var noop_1$7 = noop$1;
var innerFrom_1$h = innerFrom$1;
function distinct(keySelector, flushes) {
  return lift_1$H.operate(function(source, subscriber) {
    var distinctKeys = /* @__PURE__ */ new Set();
    source.subscribe(OperatorSubscriber_1$w.createOperatorSubscriber(subscriber, function(value) {
      var key = keySelector ? keySelector(value) : value;
      if (!distinctKeys.has(key)) {
        distinctKeys.add(key);
        subscriber.next(value);
      }
    }));
    flushes && innerFrom_1$h.innerFrom(flushes).subscribe(OperatorSubscriber_1$w.createOperatorSubscriber(subscriber, function() {
      return distinctKeys.clear();
    }, noop_1$7.noop));
  });
}
distinct$1.distinct = distinct;
var distinctUntilChanged$1 = {};
Object.defineProperty(distinctUntilChanged$1, "__esModule", { value: true });
distinctUntilChanged$1.distinctUntilChanged = void 0;
var identity_1$a = identity$2;
var lift_1$G = lift$1;
var OperatorSubscriber_1$v = OperatorSubscriber$1;
function distinctUntilChanged(comparator, keySelector) {
  if (keySelector === void 0) {
    keySelector = identity_1$a.identity;
  }
  comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
  return lift_1$G.operate(function(source, subscriber) {
    var previousKey;
    var first2 = true;
    source.subscribe(OperatorSubscriber_1$v.createOperatorSubscriber(subscriber, function(value) {
      var currentKey = keySelector(value);
      if (first2 || !comparator(previousKey, currentKey)) {
        first2 = false;
        previousKey = currentKey;
        subscriber.next(value);
      }
    }));
  });
}
distinctUntilChanged$1.distinctUntilChanged = distinctUntilChanged;
function defaultCompare(a, b2) {
  return a === b2;
}
var distinctUntilKeyChanged$1 = {};
Object.defineProperty(distinctUntilKeyChanged$1, "__esModule", { value: true });
distinctUntilKeyChanged$1.distinctUntilKeyChanged = void 0;
var distinctUntilChanged_1 = distinctUntilChanged$1;
function distinctUntilKeyChanged(key, compare2) {
  return distinctUntilChanged_1.distinctUntilChanged(function(x2, y2) {
    return compare2 ? compare2(x2[key], y2[key]) : x2[key] === y2[key];
  });
}
distinctUntilKeyChanged$1.distinctUntilKeyChanged = distinctUntilKeyChanged;
var elementAt$1 = {};
var throwIfEmpty$1 = {};
Object.defineProperty(throwIfEmpty$1, "__esModule", { value: true });
throwIfEmpty$1.throwIfEmpty = void 0;
var EmptyError_1$3 = EmptyError;
var lift_1$F = lift$1;
var OperatorSubscriber_1$u = OperatorSubscriber$1;
function throwIfEmpty(errorFactory) {
  if (errorFactory === void 0) {
    errorFactory = defaultErrorFactory;
  }
  return lift_1$F.operate(function(source, subscriber) {
    var hasValue = false;
    source.subscribe(OperatorSubscriber_1$u.createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      subscriber.next(value);
    }, function() {
      return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
    }));
  });
}
throwIfEmpty$1.throwIfEmpty = throwIfEmpty;
function defaultErrorFactory() {
  return new EmptyError_1$3.EmptyError();
}
Object.defineProperty(elementAt$1, "__esModule", { value: true });
elementAt$1.elementAt = void 0;
var ArgumentOutOfRangeError_1 = ArgumentOutOfRangeError;
var filter_1$4 = filter$2;
var throwIfEmpty_1$2 = throwIfEmpty$1;
var defaultIfEmpty_1$2 = defaultIfEmpty$1;
var take_1$1 = take$1;
function elementAt(index, defaultValue) {
  if (index < 0) {
    throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
  }
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(filter_1$4.filter(function(v2, i) {
      return i === index;
    }), take_1$1.take(1), hasDefaultValue ? defaultIfEmpty_1$2.defaultIfEmpty(defaultValue) : throwIfEmpty_1$2.throwIfEmpty(function() {
      return new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
    }));
  };
}
elementAt$1.elementAt = elementAt;
var endWith$1 = {};
var __read$8 = commonjsGlobal && commonjsGlobal.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray$a = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i = 0, il2 = from2.length, j2 = to.length; i < il2; i++, j2++)
    to[j2] = from2[i];
  return to;
};
Object.defineProperty(endWith$1, "__esModule", { value: true });
endWith$1.endWith = void 0;
var concat_1$1 = concat$3;
var of_1 = of$1;
function endWith() {
  var values = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }
  return function(source) {
    return concat_1$1.concat(source, of_1.of.apply(void 0, __spreadArray$a([], __read$8(values))));
  };
}
endWith$1.endWith = endWith;
var every$1 = {};
Object.defineProperty(every$1, "__esModule", { value: true });
every$1.every = void 0;
var lift_1$E = lift$1;
var OperatorSubscriber_1$t = OperatorSubscriber$1;
function every(predicate, thisArg) {
  return lift_1$E.operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(OperatorSubscriber_1$t.createOperatorSubscriber(subscriber, function(value) {
      if (!predicate.call(thisArg, value, index++, source)) {
        subscriber.next(false);
        subscriber.complete();
      }
    }, function() {
      subscriber.next(true);
      subscriber.complete();
    }));
  });
}
every$1.every = every;
var exhaust = {};
var exhaustAll$1 = {};
var exhaustMap$1 = {};
Object.defineProperty(exhaustMap$1, "__esModule", { value: true });
exhaustMap$1.exhaustMap = void 0;
var map_1$2 = map$1;
var innerFrom_1$g = innerFrom$1;
var lift_1$D = lift$1;
var OperatorSubscriber_1$s = OperatorSubscriber$1;
function exhaustMap(project, resultSelector) {
  if (resultSelector) {
    return function(source) {
      return source.pipe(exhaustMap(function(a, i) {
        return innerFrom_1$g.innerFrom(project(a, i)).pipe(map_1$2.map(function(b2, ii2) {
          return resultSelector(a, b2, i, ii2);
        }));
      }));
    };
  }
  return lift_1$D.operate(function(source, subscriber) {
    var index = 0;
    var innerSub = null;
    var isComplete = false;
    source.subscribe(OperatorSubscriber_1$s.createOperatorSubscriber(subscriber, function(outerValue) {
      if (!innerSub) {
        innerSub = OperatorSubscriber_1$s.createOperatorSubscriber(subscriber, void 0, function() {
          innerSub = null;
          isComplete && subscriber.complete();
        });
        innerFrom_1$g.innerFrom(project(outerValue, index++)).subscribe(innerSub);
      }
    }, function() {
      isComplete = true;
      !innerSub && subscriber.complete();
    }));
  });
}
exhaustMap$1.exhaustMap = exhaustMap;
Object.defineProperty(exhaustAll$1, "__esModule", { value: true });
exhaustAll$1.exhaustAll = void 0;
var exhaustMap_1 = exhaustMap$1;
var identity_1$9 = identity$2;
function exhaustAll() {
  return exhaustMap_1.exhaustMap(identity_1$9.identity);
}
exhaustAll$1.exhaustAll = exhaustAll;
Object.defineProperty(exhaust, "__esModule", { value: true });
exhaust.exhaust = void 0;
var exhaustAll_1 = exhaustAll$1;
exhaust.exhaust = exhaustAll_1.exhaustAll;
var expand$1 = {};
Object.defineProperty(expand$1, "__esModule", { value: true });
expand$1.expand = void 0;
var lift_1$C = lift$1;
var mergeInternals_1$1 = mergeInternals$1;
function expand(project, concurrent, scheduler2) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;
  return lift_1$C.operate(function(source, subscriber) {
    return mergeInternals_1$1.mergeInternals(source, subscriber, project, concurrent, void 0, true, scheduler2);
  });
}
expand$1.expand = expand;
var finalize$1 = {};
Object.defineProperty(finalize$1, "__esModule", { value: true });
finalize$1.finalize = void 0;
var lift_1$B = lift$1;
function finalize(callback) {
  return lift_1$B.operate(function(source, subscriber) {
    try {
      source.subscribe(subscriber);
    } finally {
      subscriber.add(callback);
    }
  });
}
finalize$1.finalize = finalize;
var find$1 = {};
Object.defineProperty(find$1, "__esModule", { value: true });
find$1.createFind = find$1.find = void 0;
var lift_1$A = lift$1;
var OperatorSubscriber_1$r = OperatorSubscriber$1;
function find(predicate, thisArg) {
  return lift_1$A.operate(createFind(predicate, thisArg, "value"));
}
find$1.find = find;
function createFind(predicate, thisArg, emit) {
  var findIndex2 = emit === "index";
  return function(source, subscriber) {
    var index = 0;
    source.subscribe(OperatorSubscriber_1$r.createOperatorSubscriber(subscriber, function(value) {
      var i = index++;
      if (predicate.call(thisArg, value, i, source)) {
        subscriber.next(findIndex2 ? i : value);
        subscriber.complete();
      }
    }, function() {
      subscriber.next(findIndex2 ? -1 : void 0);
      subscriber.complete();
    }));
  };
}
find$1.createFind = createFind;
var findIndex$1 = {};
Object.defineProperty(findIndex$1, "__esModule", { value: true });
findIndex$1.findIndex = void 0;
var lift_1$z = lift$1;
var find_1 = find$1;
function findIndex(predicate, thisArg) {
  return lift_1$z.operate(find_1.createFind(predicate, thisArg, "index"));
}
findIndex$1.findIndex = findIndex;
var first$2 = {};
Object.defineProperty(first$2, "__esModule", { value: true });
first$2.first = void 0;
var EmptyError_1$2 = EmptyError;
var filter_1$3 = filter$2;
var take_1 = take$1;
var defaultIfEmpty_1$1 = defaultIfEmpty$1;
var throwIfEmpty_1$1 = throwIfEmpty$1;
var identity_1$8 = identity$2;
function first$1(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter_1$3.filter(function(v2, i) {
      return predicate(v2, i, source);
    }) : identity_1$8.identity, take_1.take(1), hasDefaultValue ? defaultIfEmpty_1$1.defaultIfEmpty(defaultValue) : throwIfEmpty_1$1.throwIfEmpty(function() {
      return new EmptyError_1$2.EmptyError();
    }));
  };
}
first$2.first = first$1;
var groupBy$2 = {};
Object.defineProperty(groupBy$2, "__esModule", { value: true });
groupBy$2.groupBy = void 0;
var Observable_1 = Observable$1;
var innerFrom_1$f = innerFrom$1;
var Subject_1$9 = Subject$1;
var lift_1$y = lift$1;
var OperatorSubscriber_1$q = OperatorSubscriber$1;
function groupBy$1(keySelector, elementOrOptions, duration, connector) {
  return lift_1$y.operate(function(source, subscriber) {
    var element;
    if (!elementOrOptions || typeof elementOrOptions === "function") {
      element = elementOrOptions;
    } else {
      duration = elementOrOptions.duration, element = elementOrOptions.element, connector = elementOrOptions.connector;
    }
    var groups = /* @__PURE__ */ new Map();
    var notify = function(cb2) {
      groups.forEach(cb2);
      cb2(subscriber);
    };
    var handleError = function(err) {
      return notify(function(consumer) {
        return consumer.error(err);
      });
    };
    var activeGroups = 0;
    var teardownAttempted = false;
    var groupBySourceSubscriber = new OperatorSubscriber_1$q.OperatorSubscriber(subscriber, function(value) {
      try {
        var key_1 = keySelector(value);
        var group_1 = groups.get(key_1);
        if (!group_1) {
          groups.set(key_1, group_1 = connector ? connector() : new Subject_1$9.Subject());
          var grouped = createGroupedObservable(key_1, group_1);
          subscriber.next(grouped);
          if (duration) {
            var durationSubscriber_1 = OperatorSubscriber_1$q.createOperatorSubscriber(group_1, function() {
              group_1.complete();
              durationSubscriber_1 === null || durationSubscriber_1 === void 0 ? void 0 : durationSubscriber_1.unsubscribe();
            }, void 0, void 0, function() {
              return groups.delete(key_1);
            });
            groupBySourceSubscriber.add(innerFrom_1$f.innerFrom(duration(grouped)).subscribe(durationSubscriber_1));
          }
        }
        group_1.next(element ? element(value) : value);
      } catch (err) {
        handleError(err);
      }
    }, function() {
      return notify(function(consumer) {
        return consumer.complete();
      });
    }, handleError, function() {
      return groups.clear();
    }, function() {
      teardownAttempted = true;
      return activeGroups === 0;
    });
    source.subscribe(groupBySourceSubscriber);
    function createGroupedObservable(key, groupSubject) {
      var result = new Observable_1.Observable(function(groupSubscriber) {
        activeGroups++;
        var innerSub = groupSubject.subscribe(groupSubscriber);
        return function() {
          innerSub.unsubscribe();
          --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();
        };
      });
      result.key = key;
      return result;
    }
  });
}
groupBy$2.groupBy = groupBy$1;
var isEmpty$2 = {};
Object.defineProperty(isEmpty$2, "__esModule", { value: true });
isEmpty$2.isEmpty = void 0;
var lift_1$x = lift$1;
var OperatorSubscriber_1$p = OperatorSubscriber$1;
function isEmpty$1() {
  return lift_1$x.operate(function(source, subscriber) {
    source.subscribe(OperatorSubscriber_1$p.createOperatorSubscriber(subscriber, function() {
      subscriber.next(false);
      subscriber.complete();
    }, function() {
      subscriber.next(true);
      subscriber.complete();
    }));
  });
}
isEmpty$2.isEmpty = isEmpty$1;
var last$1 = {};
var takeLast$1 = {};
var __values$2 = commonjsGlobal && commonjsGlobal.__values || function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o[s], i = 0;
  if (m2)
    return m2.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(takeLast$1, "__esModule", { value: true });
takeLast$1.takeLast = void 0;
var empty_1$1 = empty;
var lift_1$w = lift$1;
var OperatorSubscriber_1$o = OperatorSubscriber$1;
function takeLast(count2) {
  return count2 <= 0 ? function() {
    return empty_1$1.EMPTY;
  } : lift_1$w.operate(function(source, subscriber) {
    var buffer2 = [];
    source.subscribe(OperatorSubscriber_1$o.createOperatorSubscriber(subscriber, function(value) {
      buffer2.push(value);
      count2 < buffer2.length && buffer2.shift();
    }, function() {
      var e_1, _a;
      try {
        for (var buffer_1 = __values$2(buffer2), buffer_1_1 = buffer_1.next(); !buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
          var value = buffer_1_1.value;
          subscriber.next(value);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return))
            _a.call(buffer_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      subscriber.complete();
    }, void 0, function() {
      buffer2 = null;
    }));
  });
}
takeLast$1.takeLast = takeLast;
Object.defineProperty(last$1, "__esModule", { value: true });
last$1.last = void 0;
var EmptyError_1$1 = EmptyError;
var filter_1$2 = filter$2;
var takeLast_1 = takeLast$1;
var throwIfEmpty_1 = throwIfEmpty$1;
var defaultIfEmpty_1 = defaultIfEmpty$1;
var identity_1$7 = identity$2;
function last(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter_1$2.filter(function(v2, i) {
      return predicate(v2, i, source);
    }) : identity_1$7.identity, takeLast_1.takeLast(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
      return new EmptyError_1$1.EmptyError();
    }));
  };
}
last$1.last = last;
var materialize$1 = {};
Object.defineProperty(materialize$1, "__esModule", { value: true });
materialize$1.materialize = void 0;
var Notification_1 = Notification;
var lift_1$v = lift$1;
var OperatorSubscriber_1$n = OperatorSubscriber$1;
function materialize() {
  return lift_1$v.operate(function(source, subscriber) {
    source.subscribe(OperatorSubscriber_1$n.createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(Notification_1.Notification.createNext(value));
    }, function() {
      subscriber.next(Notification_1.Notification.createComplete());
      subscriber.complete();
    }, function(err) {
      subscriber.next(Notification_1.Notification.createError(err));
      subscriber.complete();
    }));
  });
}
materialize$1.materialize = materialize;
var max$1 = {};
Object.defineProperty(max$1, "__esModule", { value: true });
max$1.max = void 0;
var reduce_1$1 = reduce$1;
var isFunction_1$7 = isFunction$2;
function max(comparer) {
  return reduce_1$1.reduce(isFunction_1$7.isFunction(comparer) ? function(x2, y2) {
    return comparer(x2, y2) > 0 ? x2 : y2;
  } : function(x2, y2) {
    return x2 > y2 ? x2 : y2;
  });
}
max$1.max = max;
var flatMap = {};
Object.defineProperty(flatMap, "__esModule", { value: true });
flatMap.flatMap = void 0;
var mergeMap_1$1 = mergeMap$1;
flatMap.flatMap = mergeMap_1$1.mergeMap;
var mergeMapTo$1 = {};
Object.defineProperty(mergeMapTo$1, "__esModule", { value: true });
mergeMapTo$1.mergeMapTo = void 0;
var mergeMap_1 = mergeMap$1;
var isFunction_1$6 = isFunction$2;
function mergeMapTo(innerObservable, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction_1$6.isFunction(resultSelector)) {
    return mergeMap_1.mergeMap(function() {
      return innerObservable;
    }, resultSelector, concurrent);
  }
  if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return mergeMap_1.mergeMap(function() {
    return innerObservable;
  }, concurrent);
}
mergeMapTo$1.mergeMapTo = mergeMapTo;
var mergeScan$1 = {};
Object.defineProperty(mergeScan$1, "__esModule", { value: true });
mergeScan$1.mergeScan = void 0;
var lift_1$u = lift$1;
var mergeInternals_1 = mergeInternals$1;
function mergeScan(accumulator, seed, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return lift_1$u.operate(function(source, subscriber) {
    var state = seed;
    return mergeInternals_1.mergeInternals(source, subscriber, function(value, index) {
      return accumulator(state, value, index);
    }, concurrent, function(value) {
      state = value;
    }, false, void 0, function() {
      return state = null;
    });
  });
}
mergeScan$1.mergeScan = mergeScan;
var mergeWith$1 = {};
var merge$3 = {};
var __read$7 = commonjsGlobal && commonjsGlobal.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray$9 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i = 0, il2 = from2.length, j2 = to.length; i < il2; i++, j2++)
    to[j2] = from2[i];
  return to;
};
Object.defineProperty(merge$3, "__esModule", { value: true });
merge$3.merge = void 0;
var lift_1$t = lift$1;
var argsOrArgArray_1$1 = argsOrArgArray$1;
var mergeAll_1 = mergeAll$1;
var args_1$3 = args;
var from_1 = from$2;
function merge$2() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  var scheduler2 = args_1$3.popScheduler(args2);
  var concurrent = args_1$3.popNumber(args2, Infinity);
  args2 = argsOrArgArray_1$1.argsOrArgArray(args2);
  return lift_1$t.operate(function(source, subscriber) {
    mergeAll_1.mergeAll(concurrent)(from_1.from(__spreadArray$9([source], __read$7(args2)), scheduler2)).subscribe(subscriber);
  });
}
merge$3.merge = merge$2;
var __read$6 = commonjsGlobal && commonjsGlobal.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray$8 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i = 0, il2 = from2.length, j2 = to.length; i < il2; i++, j2++)
    to[j2] = from2[i];
  return to;
};
Object.defineProperty(mergeWith$1, "__esModule", { value: true });
mergeWith$1.mergeWith = void 0;
var merge_1 = merge$3;
function mergeWith() {
  var otherSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherSources[_i] = arguments[_i];
  }
  return merge_1.merge.apply(void 0, __spreadArray$8([], __read$6(otherSources)));
}
mergeWith$1.mergeWith = mergeWith;
var min$1 = {};
Object.defineProperty(min$1, "__esModule", { value: true });
min$1.min = void 0;
var reduce_1 = reduce$1;
var isFunction_1$5 = isFunction$2;
function min(comparer) {
  return reduce_1.reduce(isFunction_1$5.isFunction(comparer) ? function(x2, y2) {
    return comparer(x2, y2) < 0 ? x2 : y2;
  } : function(x2, y2) {
    return x2 < y2 ? x2 : y2;
  });
}
min$1.min = min;
var multicast$1 = {};
Object.defineProperty(multicast$1, "__esModule", { value: true });
multicast$1.multicast = void 0;
var ConnectableObservable_1$2 = ConnectableObservable$1;
var isFunction_1$4 = isFunction$2;
var connect_1$1 = connect$1;
function multicast(subjectOrSubjectFactory, selector) {
  var subjectFactory = isFunction_1$4.isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function() {
    return subjectOrSubjectFactory;
  };
  if (isFunction_1$4.isFunction(selector)) {
    return connect_1$1.connect(selector, {
      connector: subjectFactory
    });
  }
  return function(source) {
    return new ConnectableObservable_1$2.ConnectableObservable(source, subjectFactory);
  };
}
multicast$1.multicast = multicast;
var onErrorResumeNextWith$1 = {};
var __read$5 = commonjsGlobal && commonjsGlobal.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray$7 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i = 0, il2 = from2.length, j2 = to.length; i < il2; i++, j2++)
    to[j2] = from2[i];
  return to;
};
Object.defineProperty(onErrorResumeNextWith$1, "__esModule", { value: true });
onErrorResumeNextWith$1.onErrorResumeNext = onErrorResumeNextWith$1.onErrorResumeNextWith = void 0;
var argsOrArgArray_1 = argsOrArgArray$1;
var onErrorResumeNext_1 = onErrorResumeNext$1;
function onErrorResumeNextWith() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
  return function(source) {
    return onErrorResumeNext_1.onErrorResumeNext.apply(void 0, __spreadArray$7([source], __read$5(nextSources)));
  };
}
onErrorResumeNextWith$1.onErrorResumeNextWith = onErrorResumeNextWith;
onErrorResumeNextWith$1.onErrorResumeNext = onErrorResumeNextWith;
var pairwise$1 = {};
Object.defineProperty(pairwise$1, "__esModule", { value: true });
pairwise$1.pairwise = void 0;
var lift_1$s = lift$1;
var OperatorSubscriber_1$m = OperatorSubscriber$1;
function pairwise() {
  return lift_1$s.operate(function(source, subscriber) {
    var prev2;
    var hasPrev = false;
    source.subscribe(OperatorSubscriber_1$m.createOperatorSubscriber(subscriber, function(value) {
      var p2 = prev2;
      prev2 = value;
      hasPrev && subscriber.next([p2, value]);
      hasPrev = true;
    }));
  });
}
pairwise$1.pairwise = pairwise;
var pluck$1 = {};
Object.defineProperty(pluck$1, "__esModule", { value: true });
pluck$1.pluck = void 0;
var map_1$1 = map$1;
function pluck() {
  var properties = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    properties[_i] = arguments[_i];
  }
  var length2 = properties.length;
  if (length2 === 0) {
    throw new Error("list of properties cannot be empty.");
  }
  return map_1$1.map(function(x2) {
    var currentProp = x2;
    for (var i = 0; i < length2; i++) {
      var p2 = currentProp === null || currentProp === void 0 ? void 0 : currentProp[properties[i]];
      if (typeof p2 !== "undefined") {
        currentProp = p2;
      } else {
        return void 0;
      }
    }
    return currentProp;
  });
}
pluck$1.pluck = pluck;
var publish$1 = {};
Object.defineProperty(publish$1, "__esModule", { value: true });
publish$1.publish = void 0;
var Subject_1$8 = Subject$1;
var multicast_1$1 = multicast$1;
var connect_1 = connect$1;
function publish(selector) {
  return selector ? function(source) {
    return connect_1.connect(selector)(source);
  } : function(source) {
    return multicast_1$1.multicast(new Subject_1$8.Subject())(source);
  };
}
publish$1.publish = publish;
var publishBehavior$1 = {};
Object.defineProperty(publishBehavior$1, "__esModule", { value: true });
publishBehavior$1.publishBehavior = void 0;
var BehaviorSubject_1 = BehaviorSubject$1;
var ConnectableObservable_1$1 = ConnectableObservable$1;
function publishBehavior(initialValue) {
  return function(source) {
    var subject = new BehaviorSubject_1.BehaviorSubject(initialValue);
    return new ConnectableObservable_1$1.ConnectableObservable(source, function() {
      return subject;
    });
  };
}
publishBehavior$1.publishBehavior = publishBehavior;
var publishLast$1 = {};
Object.defineProperty(publishLast$1, "__esModule", { value: true });
publishLast$1.publishLast = void 0;
var AsyncSubject_1 = AsyncSubject$1;
var ConnectableObservable_1 = ConnectableObservable$1;
function publishLast() {
  return function(source) {
    var subject = new AsyncSubject_1.AsyncSubject();
    return new ConnectableObservable_1.ConnectableObservable(source, function() {
      return subject;
    });
  };
}
publishLast$1.publishLast = publishLast;
var publishReplay$1 = {};
Object.defineProperty(publishReplay$1, "__esModule", { value: true });
publishReplay$1.publishReplay = void 0;
var ReplaySubject_1$1 = ReplaySubject$1;
var multicast_1 = multicast$1;
var isFunction_1$3 = isFunction$2;
function publishReplay(bufferSize, windowTime2, selectorOrScheduler, timestampProvider) {
  if (selectorOrScheduler && !isFunction_1$3.isFunction(selectorOrScheduler)) {
    timestampProvider = selectorOrScheduler;
  }
  var selector = isFunction_1$3.isFunction(selectorOrScheduler) ? selectorOrScheduler : void 0;
  return function(source) {
    return multicast_1.multicast(new ReplaySubject_1$1.ReplaySubject(bufferSize, windowTime2, timestampProvider), selector)(source);
  };
}
publishReplay$1.publishReplay = publishReplay;
var raceWith$1 = {};
var __read$4 = commonjsGlobal && commonjsGlobal.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray$6 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i = 0, il2 = from2.length, j2 = to.length; i < il2; i++, j2++)
    to[j2] = from2[i];
  return to;
};
Object.defineProperty(raceWith$1, "__esModule", { value: true });
raceWith$1.raceWith = void 0;
var race_1 = race$1;
var lift_1$r = lift$1;
var identity_1$6 = identity$2;
function raceWith() {
  var otherSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherSources[_i] = arguments[_i];
  }
  return !otherSources.length ? identity_1$6.identity : lift_1$r.operate(function(source, subscriber) {
    race_1.raceInit(__spreadArray$6([source], __read$4(otherSources)))(subscriber);
  });
}
raceWith$1.raceWith = raceWith;
var repeat$1 = {};
Object.defineProperty(repeat$1, "__esModule", { value: true });
repeat$1.repeat = void 0;
var empty_1 = empty;
var lift_1$q = lift$1;
var OperatorSubscriber_1$l = OperatorSubscriber$1;
var innerFrom_1$e = innerFrom$1;
var timer_1$2 = timer$1;
function repeat(countOrConfig) {
  var _a;
  var count2 = Infinity;
  var delay2;
  if (countOrConfig != null) {
    if (typeof countOrConfig === "object") {
      _a = countOrConfig.count, count2 = _a === void 0 ? Infinity : _a, delay2 = countOrConfig.delay;
    } else {
      count2 = countOrConfig;
    }
  }
  return count2 <= 0 ? function() {
    return empty_1.EMPTY;
  } : lift_1$q.operate(function(source, subscriber) {
    var soFar = 0;
    var sourceSub;
    var resubscribe = function() {
      sourceSub === null || sourceSub === void 0 ? void 0 : sourceSub.unsubscribe();
      sourceSub = null;
      if (delay2 != null) {
        var notifier = typeof delay2 === "number" ? timer_1$2.timer(delay2) : innerFrom_1$e.innerFrom(delay2(soFar));
        var notifierSubscriber_1 = OperatorSubscriber_1$l.createOperatorSubscriber(subscriber, function() {
          notifierSubscriber_1.unsubscribe();
          subscribeToSource();
        });
        notifier.subscribe(notifierSubscriber_1);
      } else {
        subscribeToSource();
      }
    };
    var subscribeToSource = function() {
      var syncUnsub = false;
      sourceSub = source.subscribe(OperatorSubscriber_1$l.createOperatorSubscriber(subscriber, void 0, function() {
        if (++soFar < count2) {
          if (sourceSub) {
            resubscribe();
          } else {
            syncUnsub = true;
          }
        } else {
          subscriber.complete();
        }
      }));
      if (syncUnsub) {
        resubscribe();
      }
    };
    subscribeToSource();
  });
}
repeat$1.repeat = repeat;
var repeatWhen$1 = {};
Object.defineProperty(repeatWhen$1, "__esModule", { value: true });
repeatWhen$1.repeatWhen = void 0;
var innerFrom_1$d = innerFrom$1;
var Subject_1$7 = Subject$1;
var lift_1$p = lift$1;
var OperatorSubscriber_1$k = OperatorSubscriber$1;
function repeatWhen(notifier) {
  return lift_1$p.operate(function(source, subscriber) {
    var innerSub;
    var syncResub = false;
    var completions$;
    var isNotifierComplete = false;
    var isMainComplete = false;
    var checkComplete = function() {
      return isMainComplete && isNotifierComplete && (subscriber.complete(), true);
    };
    var getCompletionSubject = function() {
      if (!completions$) {
        completions$ = new Subject_1$7.Subject();
        innerFrom_1$d.innerFrom(notifier(completions$)).subscribe(OperatorSubscriber_1$k.createOperatorSubscriber(subscriber, function() {
          if (innerSub) {
            subscribeForRepeatWhen();
          } else {
            syncResub = true;
          }
        }, function() {
          isNotifierComplete = true;
          checkComplete();
        }));
      }
      return completions$;
    };
    var subscribeForRepeatWhen = function() {
      isMainComplete = false;
      innerSub = source.subscribe(OperatorSubscriber_1$k.createOperatorSubscriber(subscriber, void 0, function() {
        isMainComplete = true;
        !checkComplete() && getCompletionSubject().next();
      }));
      if (syncResub) {
        innerSub.unsubscribe();
        innerSub = null;
        syncResub = false;
        subscribeForRepeatWhen();
      }
    };
    subscribeForRepeatWhen();
  });
}
repeatWhen$1.repeatWhen = repeatWhen;
var retry$1 = {};
Object.defineProperty(retry$1, "__esModule", { value: true });
retry$1.retry = void 0;
var lift_1$o = lift$1;
var OperatorSubscriber_1$j = OperatorSubscriber$1;
var identity_1$5 = identity$2;
var timer_1$1 = timer$1;
var innerFrom_1$c = innerFrom$1;
function retry(configOrCount) {
  if (configOrCount === void 0) {
    configOrCount = Infinity;
  }
  var config2;
  if (configOrCount && typeof configOrCount === "object") {
    config2 = configOrCount;
  } else {
    config2 = {
      count: configOrCount
    };
  }
  var _a = config2.count, count2 = _a === void 0 ? Infinity : _a, delay2 = config2.delay, _b = config2.resetOnSuccess, resetOnSuccess = _b === void 0 ? false : _b;
  return count2 <= 0 ? identity_1$5.identity : lift_1$o.operate(function(source, subscriber) {
    var soFar = 0;
    var innerSub;
    var subscribeForRetry = function() {
      var syncUnsub = false;
      innerSub = source.subscribe(OperatorSubscriber_1$j.createOperatorSubscriber(subscriber, function(value) {
        if (resetOnSuccess) {
          soFar = 0;
        }
        subscriber.next(value);
      }, void 0, function(err) {
        if (soFar++ < count2) {
          var resub_1 = function() {
            if (innerSub) {
              innerSub.unsubscribe();
              innerSub = null;
              subscribeForRetry();
            } else {
              syncUnsub = true;
            }
          };
          if (delay2 != null) {
            var notifier = typeof delay2 === "number" ? timer_1$1.timer(delay2) : innerFrom_1$c.innerFrom(delay2(err, soFar));
            var notifierSubscriber_1 = OperatorSubscriber_1$j.createOperatorSubscriber(subscriber, function() {
              notifierSubscriber_1.unsubscribe();
              resub_1();
            }, function() {
              subscriber.complete();
            });
            notifier.subscribe(notifierSubscriber_1);
          } else {
            resub_1();
          }
        } else {
          subscriber.error(err);
        }
      }));
      if (syncUnsub) {
        innerSub.unsubscribe();
        innerSub = null;
        subscribeForRetry();
      }
    };
    subscribeForRetry();
  });
}
retry$1.retry = retry;
var retryWhen$1 = {};
Object.defineProperty(retryWhen$1, "__esModule", { value: true });
retryWhen$1.retryWhen = void 0;
var innerFrom_1$b = innerFrom$1;
var Subject_1$6 = Subject$1;
var lift_1$n = lift$1;
var OperatorSubscriber_1$i = OperatorSubscriber$1;
function retryWhen(notifier) {
  return lift_1$n.operate(function(source, subscriber) {
    var innerSub;
    var syncResub = false;
    var errors$;
    var subscribeForRetryWhen = function() {
      innerSub = source.subscribe(OperatorSubscriber_1$i.createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
        if (!errors$) {
          errors$ = new Subject_1$6.Subject();
          innerFrom_1$b.innerFrom(notifier(errors$)).subscribe(OperatorSubscriber_1$i.createOperatorSubscriber(subscriber, function() {
            return innerSub ? subscribeForRetryWhen() : syncResub = true;
          }));
        }
        if (errors$) {
          errors$.next(err);
        }
      }));
      if (syncResub) {
        innerSub.unsubscribe();
        innerSub = null;
        syncResub = false;
        subscribeForRetryWhen();
      }
    };
    subscribeForRetryWhen();
  });
}
retryWhen$1.retryWhen = retryWhen;
var sample$1 = {};
Object.defineProperty(sample$1, "__esModule", { value: true });
sample$1.sample = void 0;
var innerFrom_1$a = innerFrom$1;
var lift_1$m = lift$1;
var noop_1$6 = noop$1;
var OperatorSubscriber_1$h = OperatorSubscriber$1;
function sample(notifier) {
  return lift_1$m.operate(function(source, subscriber) {
    var hasValue = false;
    var lastValue = null;
    source.subscribe(OperatorSubscriber_1$h.createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      lastValue = value;
    }));
    innerFrom_1$a.innerFrom(notifier).subscribe(OperatorSubscriber_1$h.createOperatorSubscriber(subscriber, function() {
      if (hasValue) {
        hasValue = false;
        var value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
    }, noop_1$6.noop));
  });
}
sample$1.sample = sample;
var sampleTime$1 = {};
Object.defineProperty(sampleTime$1, "__esModule", { value: true });
sampleTime$1.sampleTime = void 0;
var async_1$4 = async;
var sample_1 = sample$1;
var interval_1 = interval$1;
function sampleTime(period, scheduler2) {
  if (scheduler2 === void 0) {
    scheduler2 = async_1$4.asyncScheduler;
  }
  return sample_1.sample(interval_1.interval(period, scheduler2));
}
sampleTime$1.sampleTime = sampleTime;
var scan$1 = {};
Object.defineProperty(scan$1, "__esModule", { value: true });
scan$1.scan = void 0;
var lift_1$l = lift$1;
var scanInternals_1 = scanInternals$1;
function scan(accumulator, seed) {
  return lift_1$l.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, true));
}
scan$1.scan = scan;
var sequenceEqual$1 = {};
Object.defineProperty(sequenceEqual$1, "__esModule", { value: true });
sequenceEqual$1.sequenceEqual = void 0;
var lift_1$k = lift$1;
var OperatorSubscriber_1$g = OperatorSubscriber$1;
var innerFrom_1$9 = innerFrom$1;
function sequenceEqual(compareTo, comparator) {
  if (comparator === void 0) {
    comparator = function(a, b2) {
      return a === b2;
    };
  }
  return lift_1$k.operate(function(source, subscriber) {
    var aState = createState();
    var bState = createState();
    var emit = function(isEqual2) {
      subscriber.next(isEqual2);
      subscriber.complete();
    };
    var createSubscriber = function(selfState, otherState) {
      var sequenceEqualSubscriber = OperatorSubscriber_1$g.createOperatorSubscriber(subscriber, function(a) {
        var buffer2 = otherState.buffer, complete = otherState.complete;
        if (buffer2.length === 0) {
          complete ? emit(false) : selfState.buffer.push(a);
        } else {
          !comparator(a, buffer2.shift()) && emit(false);
        }
      }, function() {
        selfState.complete = true;
        var complete = otherState.complete, buffer2 = otherState.buffer;
        complete && emit(buffer2.length === 0);
        sequenceEqualSubscriber === null || sequenceEqualSubscriber === void 0 ? void 0 : sequenceEqualSubscriber.unsubscribe();
      });
      return sequenceEqualSubscriber;
    };
    source.subscribe(createSubscriber(aState, bState));
    innerFrom_1$9.innerFrom(compareTo).subscribe(createSubscriber(bState, aState));
  });
}
sequenceEqual$1.sequenceEqual = sequenceEqual;
function createState() {
  return {
    buffer: [],
    complete: false
  };
}
var share$1 = {};
var __read$3 = commonjsGlobal && commonjsGlobal.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray$5 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i = 0, il2 = from2.length, j2 = to.length; i < il2; i++, j2++)
    to[j2] = from2[i];
  return to;
};
Object.defineProperty(share$1, "__esModule", { value: true });
share$1.share = void 0;
var innerFrom_1$8 = innerFrom$1;
var Subject_1$5 = Subject$1;
var Subscriber_1 = Subscriber;
var lift_1$j = lift$1;
function share(options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.connector, connector = _a === void 0 ? function() {
    return new Subject_1$5.Subject();
  } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
  return function(wrapperSource) {
    var connection;
    var resetConnection;
    var subject;
    var refCount2 = 0;
    var hasCompleted = false;
    var hasErrored = false;
    var cancelReset = function() {
      resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
      resetConnection = void 0;
    };
    var reset = function() {
      cancelReset();
      connection = subject = void 0;
      hasCompleted = hasErrored = false;
    };
    var resetAndUnsubscribe = function() {
      var conn = connection;
      reset();
      conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
    };
    return lift_1$j.operate(function(source, subscriber) {
      refCount2++;
      if (!hasErrored && !hasCompleted) {
        cancelReset();
      }
      var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
      subscriber.add(function() {
        refCount2--;
        if (refCount2 === 0 && !hasErrored && !hasCompleted) {
          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
        }
      });
      dest.subscribe(subscriber);
      if (!connection && refCount2 > 0) {
        connection = new Subscriber_1.SafeSubscriber({
          next: function(value) {
            return dest.next(value);
          },
          error: function(err) {
            hasErrored = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnError, err);
            dest.error(err);
          },
          complete: function() {
            hasCompleted = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnComplete);
            dest.complete();
          }
        });
        innerFrom_1$8.innerFrom(source).subscribe(connection);
      }
    })(wrapperSource);
  };
}
share$1.share = share;
function handleReset(reset, on) {
  var args2 = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args2[_i - 2] = arguments[_i];
  }
  if (on === true) {
    reset();
    return;
  }
  if (on === false) {
    return;
  }
  var onSubscriber = new Subscriber_1.SafeSubscriber({
    next: function() {
      onSubscriber.unsubscribe();
      reset();
    }
  });
  return innerFrom_1$8.innerFrom(on.apply(void 0, __spreadArray$5([], __read$3(args2)))).subscribe(onSubscriber);
}
var shareReplay$1 = {};
Object.defineProperty(shareReplay$1, "__esModule", { value: true });
shareReplay$1.shareReplay = void 0;
var ReplaySubject_1 = ReplaySubject$1;
var share_1 = share$1;
function shareReplay(configOrBufferSize, windowTime2, scheduler2) {
  var _a, _b, _c;
  var bufferSize;
  var refCount2 = false;
  if (configOrBufferSize && typeof configOrBufferSize === "object") {
    _a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime2 = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount2 = _c === void 0 ? false : _c, scheduler2 = configOrBufferSize.scheduler;
  } else {
    bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
  }
  return share_1.share({
    connector: function() {
      return new ReplaySubject_1.ReplaySubject(bufferSize, windowTime2, scheduler2);
    },
    resetOnError: true,
    resetOnComplete: false,
    resetOnRefCountZero: refCount2
  });
}
shareReplay$1.shareReplay = shareReplay;
var single$1 = {};
Object.defineProperty(single$1, "__esModule", { value: true });
single$1.single = void 0;
var EmptyError_1 = EmptyError;
var SequenceError_1 = SequenceError;
var NotFoundError_1 = NotFoundError;
var lift_1$i = lift$1;
var OperatorSubscriber_1$f = OperatorSubscriber$1;
function single(predicate) {
  return lift_1$i.operate(function(source, subscriber) {
    var hasValue = false;
    var singleValue;
    var seenValue = false;
    var index = 0;
    source.subscribe(OperatorSubscriber_1$f.createOperatorSubscriber(subscriber, function(value) {
      seenValue = true;
      if (!predicate || predicate(value, index++, source)) {
        hasValue && subscriber.error(new SequenceError_1.SequenceError("Too many matching values"));
        hasValue = true;
        singleValue = value;
      }
    }, function() {
      if (hasValue) {
        subscriber.next(singleValue);
        subscriber.complete();
      } else {
        subscriber.error(seenValue ? new NotFoundError_1.NotFoundError("No matching values") : new EmptyError_1.EmptyError());
      }
    }));
  });
}
single$1.single = single;
var skip$1 = {};
Object.defineProperty(skip$1, "__esModule", { value: true });
skip$1.skip = void 0;
var filter_1$1 = filter$2;
function skip(count2) {
  return filter_1$1.filter(function(_2, index) {
    return count2 <= index;
  });
}
skip$1.skip = skip;
var skipLast$1 = {};
Object.defineProperty(skipLast$1, "__esModule", { value: true });
skipLast$1.skipLast = void 0;
var identity_1$4 = identity$2;
var lift_1$h = lift$1;
var OperatorSubscriber_1$e = OperatorSubscriber$1;
function skipLast(skipCount) {
  return skipCount <= 0 ? identity_1$4.identity : lift_1$h.operate(function(source, subscriber) {
    var ring = new Array(skipCount);
    var seen = 0;
    source.subscribe(OperatorSubscriber_1$e.createOperatorSubscriber(subscriber, function(value) {
      var valueIndex = seen++;
      if (valueIndex < skipCount) {
        ring[valueIndex] = value;
      } else {
        var index = valueIndex % skipCount;
        var oldValue = ring[index];
        ring[index] = value;
        subscriber.next(oldValue);
      }
    }));
    return function() {
      ring = null;
    };
  });
}
skipLast$1.skipLast = skipLast;
var skipUntil$1 = {};
Object.defineProperty(skipUntil$1, "__esModule", { value: true });
skipUntil$1.skipUntil = void 0;
var lift_1$g = lift$1;
var OperatorSubscriber_1$d = OperatorSubscriber$1;
var innerFrom_1$7 = innerFrom$1;
var noop_1$5 = noop$1;
function skipUntil(notifier) {
  return lift_1$g.operate(function(source, subscriber) {
    var taking = false;
    var skipSubscriber = OperatorSubscriber_1$d.createOperatorSubscriber(subscriber, function() {
      skipSubscriber === null || skipSubscriber === void 0 ? void 0 : skipSubscriber.unsubscribe();
      taking = true;
    }, noop_1$5.noop);
    innerFrom_1$7.innerFrom(notifier).subscribe(skipSubscriber);
    source.subscribe(OperatorSubscriber_1$d.createOperatorSubscriber(subscriber, function(value) {
      return taking && subscriber.next(value);
    }));
  });
}
skipUntil$1.skipUntil = skipUntil;
var skipWhile$1 = {};
Object.defineProperty(skipWhile$1, "__esModule", { value: true });
skipWhile$1.skipWhile = void 0;
var lift_1$f = lift$1;
var OperatorSubscriber_1$c = OperatorSubscriber$1;
function skipWhile(predicate) {
  return lift_1$f.operate(function(source, subscriber) {
    var taking = false;
    var index = 0;
    source.subscribe(OperatorSubscriber_1$c.createOperatorSubscriber(subscriber, function(value) {
      return (taking || (taking = !predicate(value, index++))) && subscriber.next(value);
    }));
  });
}
skipWhile$1.skipWhile = skipWhile;
var startWith$1 = {};
Object.defineProperty(startWith$1, "__esModule", { value: true });
startWith$1.startWith = void 0;
var concat_1 = concat$3;
var args_1$2 = args;
var lift_1$e = lift$1;
function startWith() {
  var values = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }
  var scheduler2 = args_1$2.popScheduler(values);
  return lift_1$e.operate(function(source, subscriber) {
    (scheduler2 ? concat_1.concat(values, source, scheduler2) : concat_1.concat(values, source)).subscribe(subscriber);
  });
}
startWith$1.startWith = startWith;
var switchAll$1 = {};
var switchMap$1 = {};
Object.defineProperty(switchMap$1, "__esModule", { value: true });
switchMap$1.switchMap = void 0;
var innerFrom_1$6 = innerFrom$1;
var lift_1$d = lift$1;
var OperatorSubscriber_1$b = OperatorSubscriber$1;
function switchMap(project, resultSelector) {
  return lift_1$d.operate(function(source, subscriber) {
    var innerSubscriber = null;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      return isComplete && !innerSubscriber && subscriber.complete();
    };
    source.subscribe(OperatorSubscriber_1$b.createOperatorSubscriber(subscriber, function(value) {
      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
      var innerIndex = 0;
      var outerIndex = index++;
      innerFrom_1$6.innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = OperatorSubscriber_1$b.createOperatorSubscriber(subscriber, function(innerValue) {
        return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
      }, function() {
        innerSubscriber = null;
        checkComplete();
      }));
    }, function() {
      isComplete = true;
      checkComplete();
    }));
  });
}
switchMap$1.switchMap = switchMap;
Object.defineProperty(switchAll$1, "__esModule", { value: true });
switchAll$1.switchAll = void 0;
var switchMap_1$2 = switchMap$1;
var identity_1$3 = identity$2;
function switchAll() {
  return switchMap_1$2.switchMap(identity_1$3.identity);
}
switchAll$1.switchAll = switchAll;
var switchMapTo$1 = {};
Object.defineProperty(switchMapTo$1, "__esModule", { value: true });
switchMapTo$1.switchMapTo = void 0;
var switchMap_1$1 = switchMap$1;
var isFunction_1$2 = isFunction$2;
function switchMapTo(innerObservable, resultSelector) {
  return isFunction_1$2.isFunction(resultSelector) ? switchMap_1$1.switchMap(function() {
    return innerObservable;
  }, resultSelector) : switchMap_1$1.switchMap(function() {
    return innerObservable;
  });
}
switchMapTo$1.switchMapTo = switchMapTo;
var switchScan$1 = {};
Object.defineProperty(switchScan$1, "__esModule", { value: true });
switchScan$1.switchScan = void 0;
var switchMap_1 = switchMap$1;
var lift_1$c = lift$1;
function switchScan(accumulator, seed) {
  return lift_1$c.operate(function(source, subscriber) {
    var state = seed;
    switchMap_1.switchMap(function(value, index) {
      return accumulator(state, value, index);
    }, function(_2, innerValue) {
      return state = innerValue, innerValue;
    })(source).subscribe(subscriber);
    return function() {
      state = null;
    };
  });
}
switchScan$1.switchScan = switchScan;
var takeUntil$1 = {};
Object.defineProperty(takeUntil$1, "__esModule", { value: true });
takeUntil$1.takeUntil = void 0;
var lift_1$b = lift$1;
var OperatorSubscriber_1$a = OperatorSubscriber$1;
var innerFrom_1$5 = innerFrom$1;
var noop_1$4 = noop$1;
function takeUntil(notifier) {
  return lift_1$b.operate(function(source, subscriber) {
    innerFrom_1$5.innerFrom(notifier).subscribe(OperatorSubscriber_1$a.createOperatorSubscriber(subscriber, function() {
      return subscriber.complete();
    }, noop_1$4.noop));
    !subscriber.closed && source.subscribe(subscriber);
  });
}
takeUntil$1.takeUntil = takeUntil;
var takeWhile$1 = {};
Object.defineProperty(takeWhile$1, "__esModule", { value: true });
takeWhile$1.takeWhile = void 0;
var lift_1$a = lift$1;
var OperatorSubscriber_1$9 = OperatorSubscriber$1;
function takeWhile(predicate, inclusive) {
  if (inclusive === void 0) {
    inclusive = false;
  }
  return lift_1$a.operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(OperatorSubscriber_1$9.createOperatorSubscriber(subscriber, function(value) {
      var result = predicate(value, index++);
      (result || inclusive) && subscriber.next(value);
      !result && subscriber.complete();
    }));
  });
}
takeWhile$1.takeWhile = takeWhile;
var tap$1 = {};
Object.defineProperty(tap$1, "__esModule", { value: true });
tap$1.tap = void 0;
var isFunction_1$1 = isFunction$2;
var lift_1$9 = lift$1;
var OperatorSubscriber_1$8 = OperatorSubscriber$1;
var identity_1$2 = identity$2;
function tap(observerOrNext, error, complete) {
  var tapObserver = isFunction_1$1.isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
  return tapObserver ? lift_1$9.operate(function(source, subscriber) {
    var _a;
    (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
    var isUnsub = true;
    source.subscribe(OperatorSubscriber_1$8.createOperatorSubscriber(subscriber, function(value) {
      var _a2;
      (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
      subscriber.next(value);
    }, function() {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      subscriber.complete();
    }, function(err) {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
      subscriber.error(err);
    }, function() {
      var _a2, _b;
      if (isUnsub) {
        (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      }
      (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
    }));
  }) : identity_1$2.identity;
}
tap$1.tap = tap;
var throttle$1 = {};
Object.defineProperty(throttle$1, "__esModule", { value: true });
throttle$1.throttle = void 0;
var lift_1$8 = lift$1;
var OperatorSubscriber_1$7 = OperatorSubscriber$1;
var innerFrom_1$4 = innerFrom$1;
function throttle(durationSelector, config2) {
  return lift_1$8.operate(function(source, subscriber) {
    var _a = config2 !== null && config2 !== void 0 ? config2 : {}, _b = _a.leading, leading = _b === void 0 ? true : _b, _c = _a.trailing, trailing = _c === void 0 ? false : _c;
    var hasValue = false;
    var sendValue = null;
    var throttled = null;
    var isComplete = false;
    var endThrottling = function() {
      throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
      throttled = null;
      if (trailing) {
        send();
        isComplete && subscriber.complete();
      }
    };
    var cleanupThrottling = function() {
      throttled = null;
      isComplete && subscriber.complete();
    };
    var startThrottle = function(value) {
      return throttled = innerFrom_1$4.innerFrom(durationSelector(value)).subscribe(OperatorSubscriber_1$7.createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling));
    };
    var send = function() {
      if (hasValue) {
        hasValue = false;
        var value = sendValue;
        sendValue = null;
        subscriber.next(value);
        !isComplete && startThrottle(value);
      }
    };
    source.subscribe(OperatorSubscriber_1$7.createOperatorSubscriber(subscriber, function(value) {
      hasValue = true;
      sendValue = value;
      !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
    }, function() {
      isComplete = true;
      !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
    }));
  });
}
throttle$1.throttle = throttle;
var throttleTime$1 = {};
Object.defineProperty(throttleTime$1, "__esModule", { value: true });
throttleTime$1.throttleTime = void 0;
var async_1$3 = async;
var throttle_1$1 = throttle$1;
var timer_1 = timer$1;
function throttleTime(duration, scheduler2, config2) {
  if (scheduler2 === void 0) {
    scheduler2 = async_1$3.asyncScheduler;
  }
  var duration$ = timer_1.timer(duration, scheduler2);
  return throttle_1$1.throttle(function() {
    return duration$;
  }, config2);
}
throttleTime$1.throttleTime = throttleTime;
var timeInterval$1 = {};
Object.defineProperty(timeInterval$1, "__esModule", { value: true });
timeInterval$1.TimeInterval = timeInterval$1.timeInterval = void 0;
var async_1$2 = async;
var lift_1$7 = lift$1;
var OperatorSubscriber_1$6 = OperatorSubscriber$1;
function timeInterval(scheduler2) {
  if (scheduler2 === void 0) {
    scheduler2 = async_1$2.asyncScheduler;
  }
  return lift_1$7.operate(function(source, subscriber) {
    var last2 = scheduler2.now();
    source.subscribe(OperatorSubscriber_1$6.createOperatorSubscriber(subscriber, function(value) {
      var now2 = scheduler2.now();
      var interval2 = now2 - last2;
      last2 = now2;
      subscriber.next(new TimeInterval(value, interval2));
    }));
  });
}
timeInterval$1.timeInterval = timeInterval;
var TimeInterval = /* @__PURE__ */ function() {
  function TimeInterval2(value, interval2) {
    this.value = value;
    this.interval = interval2;
  }
  return TimeInterval2;
}();
timeInterval$1.TimeInterval = TimeInterval;
var timeoutWith$1 = {};
Object.defineProperty(timeoutWith$1, "__esModule", { value: true });
timeoutWith$1.timeoutWith = void 0;
var async_1$1 = async;
var isDate_1 = isDate$1;
var timeout_1 = timeout;
function timeoutWith(due, withObservable, scheduler2) {
  var first2;
  var each;
  var _with;
  scheduler2 = scheduler2 !== null && scheduler2 !== void 0 ? scheduler2 : async_1$1.async;
  if (isDate_1.isValidDate(due)) {
    first2 = due;
  } else if (typeof due === "number") {
    each = due;
  }
  if (withObservable) {
    _with = function() {
      return withObservable;
    };
  } else {
    throw new TypeError("No observable provided to switch to");
  }
  if (first2 == null && each == null) {
    throw new TypeError("No timeout provided.");
  }
  return timeout_1.timeout({
    first: first2,
    each,
    scheduler: scheduler2,
    with: _with
  });
}
timeoutWith$1.timeoutWith = timeoutWith;
var timestamp$1 = {};
Object.defineProperty(timestamp$1, "__esModule", { value: true });
timestamp$1.timestamp = void 0;
var dateTimestampProvider_1 = dateTimestampProvider;
var map_1 = map$1;
function timestamp(timestampProvider) {
  if (timestampProvider === void 0) {
    timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
  }
  return map_1.map(function(value) {
    return { value, timestamp: timestampProvider.now() };
  });
}
timestamp$1.timestamp = timestamp;
var window$2 = {};
Object.defineProperty(window$2, "__esModule", { value: true });
window$2.window = void 0;
var Subject_1$4 = Subject$1;
var lift_1$6 = lift$1;
var OperatorSubscriber_1$5 = OperatorSubscriber$1;
var noop_1$3 = noop$1;
var innerFrom_1$3 = innerFrom$1;
function window$1(windowBoundaries) {
  return lift_1$6.operate(function(source, subscriber) {
    var windowSubject = new Subject_1$4.Subject();
    subscriber.next(windowSubject.asObservable());
    var errorHandler = function(err) {
      windowSubject.error(err);
      subscriber.error(err);
    };
    source.subscribe(OperatorSubscriber_1$5.createOperatorSubscriber(subscriber, function(value) {
      return windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.next(value);
    }, function() {
      windowSubject.complete();
      subscriber.complete();
    }, errorHandler));
    innerFrom_1$3.innerFrom(windowBoundaries).subscribe(OperatorSubscriber_1$5.createOperatorSubscriber(subscriber, function() {
      windowSubject.complete();
      subscriber.next(windowSubject = new Subject_1$4.Subject());
    }, noop_1$3.noop, errorHandler));
    return function() {
      windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.unsubscribe();
      windowSubject = null;
    };
  });
}
window$2.window = window$1;
var windowCount$1 = {};
var __values$1 = commonjsGlobal && commonjsGlobal.__values || function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o[s], i = 0;
  if (m2)
    return m2.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(windowCount$1, "__esModule", { value: true });
windowCount$1.windowCount = void 0;
var Subject_1$3 = Subject$1;
var lift_1$5 = lift$1;
var OperatorSubscriber_1$4 = OperatorSubscriber$1;
function windowCount(windowSize, startWindowEvery) {
  if (startWindowEvery === void 0) {
    startWindowEvery = 0;
  }
  var startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;
  return lift_1$5.operate(function(source, subscriber) {
    var windows = [new Subject_1$3.Subject()];
    var count2 = 0;
    subscriber.next(windows[0].asObservable());
    source.subscribe(OperatorSubscriber_1$4.createOperatorSubscriber(subscriber, function(value) {
      var e_1, _a;
      try {
        for (var windows_1 = __values$1(windows), windows_1_1 = windows_1.next(); !windows_1_1.done; windows_1_1 = windows_1.next()) {
          var window_1 = windows_1_1.value;
          window_1.next(value);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (windows_1_1 && !windows_1_1.done && (_a = windows_1.return))
            _a.call(windows_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      var c = count2 - windowSize + 1;
      if (c >= 0 && c % startEvery === 0) {
        windows.shift().complete();
      }
      if (++count2 % startEvery === 0) {
        var window_2 = new Subject_1$3.Subject();
        windows.push(window_2);
        subscriber.next(window_2.asObservable());
      }
    }, function() {
      while (windows.length > 0) {
        windows.shift().complete();
      }
      subscriber.complete();
    }, function(err) {
      while (windows.length > 0) {
        windows.shift().error(err);
      }
      subscriber.error(err);
    }, function() {
      windows = null;
    }));
  });
}
windowCount$1.windowCount = windowCount;
var windowTime$1 = {};
Object.defineProperty(windowTime$1, "__esModule", { value: true });
windowTime$1.windowTime = void 0;
var Subject_1$2 = Subject$1;
var async_1 = async;
var Subscription_1$1 = Subscription$1;
var lift_1$4 = lift$1;
var OperatorSubscriber_1$3 = OperatorSubscriber$1;
var arrRemove_1$1 = arrRemove$1;
var args_1$1 = args;
var executeSchedule_1 = executeSchedule$1;
function windowTime(windowTimeSpan) {
  var _a, _b;
  var otherArgs = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    otherArgs[_i - 1] = arguments[_i];
  }
  var scheduler2 = (_a = args_1$1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1.asyncScheduler;
  var windowCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
  var maxWindowSize = otherArgs[1] || Infinity;
  return lift_1$4.operate(function(source, subscriber) {
    var windowRecords = [];
    var restartOnClose = false;
    var closeWindow = function(record) {
      var window2 = record.window, subs = record.subs;
      window2.complete();
      subs.unsubscribe();
      arrRemove_1$1.arrRemove(windowRecords, record);
      restartOnClose && startWindow();
    };
    var startWindow = function() {
      if (windowRecords) {
        var subs = new Subscription_1$1.Subscription();
        subscriber.add(subs);
        var window_1 = new Subject_1$2.Subject();
        var record_1 = {
          window: window_1,
          subs,
          seen: 0
        };
        windowRecords.push(record_1);
        subscriber.next(window_1.asObservable());
        executeSchedule_1.executeSchedule(subs, scheduler2, function() {
          return closeWindow(record_1);
        }, windowTimeSpan);
      }
    };
    if (windowCreationInterval !== null && windowCreationInterval >= 0) {
      executeSchedule_1.executeSchedule(subscriber, scheduler2, startWindow, windowCreationInterval, true);
    } else {
      restartOnClose = true;
    }
    startWindow();
    var loop = function(cb2) {
      return windowRecords.slice().forEach(cb2);
    };
    var terminate = function(cb2) {
      loop(function(_a2) {
        var window2 = _a2.window;
        return cb2(window2);
      });
      cb2(subscriber);
      subscriber.unsubscribe();
    };
    source.subscribe(OperatorSubscriber_1$3.createOperatorSubscriber(subscriber, function(value) {
      loop(function(record) {
        record.window.next(value);
        maxWindowSize <= ++record.seen && closeWindow(record);
      });
    }, function() {
      return terminate(function(consumer) {
        return consumer.complete();
      });
    }, function(err) {
      return terminate(function(consumer) {
        return consumer.error(err);
      });
    }));
    return function() {
      windowRecords = null;
    };
  });
}
windowTime$1.windowTime = windowTime;
var windowToggle$1 = {};
var __values = commonjsGlobal && commonjsGlobal.__values || function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o[s], i = 0;
  if (m2)
    return m2.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(windowToggle$1, "__esModule", { value: true });
windowToggle$1.windowToggle = void 0;
var Subject_1$1 = Subject$1;
var Subscription_1 = Subscription$1;
var lift_1$3 = lift$1;
var innerFrom_1$2 = innerFrom$1;
var OperatorSubscriber_1$2 = OperatorSubscriber$1;
var noop_1$2 = noop$1;
var arrRemove_1 = arrRemove$1;
function windowToggle(openings, closingSelector) {
  return lift_1$3.operate(function(source, subscriber) {
    var windows = [];
    var handleError = function(err) {
      while (0 < windows.length) {
        windows.shift().error(err);
      }
      subscriber.error(err);
    };
    innerFrom_1$2.innerFrom(openings).subscribe(OperatorSubscriber_1$2.createOperatorSubscriber(subscriber, function(openValue) {
      var window2 = new Subject_1$1.Subject();
      windows.push(window2);
      var closingSubscription = new Subscription_1.Subscription();
      var closeWindow = function() {
        arrRemove_1.arrRemove(windows, window2);
        window2.complete();
        closingSubscription.unsubscribe();
      };
      var closingNotifier;
      try {
        closingNotifier = innerFrom_1$2.innerFrom(closingSelector(openValue));
      } catch (err) {
        handleError(err);
        return;
      }
      subscriber.next(window2.asObservable());
      closingSubscription.add(closingNotifier.subscribe(OperatorSubscriber_1$2.createOperatorSubscriber(subscriber, closeWindow, noop_1$2.noop, handleError)));
    }, noop_1$2.noop));
    source.subscribe(OperatorSubscriber_1$2.createOperatorSubscriber(subscriber, function(value) {
      var e_1, _a;
      var windowsCopy = windows.slice();
      try {
        for (var windowsCopy_1 = __values(windowsCopy), windowsCopy_1_1 = windowsCopy_1.next(); !windowsCopy_1_1.done; windowsCopy_1_1 = windowsCopy_1.next()) {
          var window_1 = windowsCopy_1_1.value;
          window_1.next(value);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (windowsCopy_1_1 && !windowsCopy_1_1.done && (_a = windowsCopy_1.return))
            _a.call(windowsCopy_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }, function() {
      while (0 < windows.length) {
        windows.shift().complete();
      }
      subscriber.complete();
    }, handleError, function() {
      while (0 < windows.length) {
        windows.shift().unsubscribe();
      }
    }));
  });
}
windowToggle$1.windowToggle = windowToggle;
var windowWhen$1 = {};
Object.defineProperty(windowWhen$1, "__esModule", { value: true });
windowWhen$1.windowWhen = void 0;
var Subject_1 = Subject$1;
var lift_1$2 = lift$1;
var OperatorSubscriber_1$1 = OperatorSubscriber$1;
var innerFrom_1$1 = innerFrom$1;
function windowWhen(closingSelector) {
  return lift_1$2.operate(function(source, subscriber) {
    var window2;
    var closingSubscriber;
    var handleError = function(err) {
      window2.error(err);
      subscriber.error(err);
    };
    var openWindow = function() {
      closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
      window2 === null || window2 === void 0 ? void 0 : window2.complete();
      window2 = new Subject_1.Subject();
      subscriber.next(window2.asObservable());
      var closingNotifier;
      try {
        closingNotifier = innerFrom_1$1.innerFrom(closingSelector());
      } catch (err) {
        handleError(err);
        return;
      }
      closingNotifier.subscribe(closingSubscriber = OperatorSubscriber_1$1.createOperatorSubscriber(subscriber, openWindow, openWindow, handleError));
    };
    openWindow();
    source.subscribe(OperatorSubscriber_1$1.createOperatorSubscriber(subscriber, function(value) {
      return window2.next(value);
    }, function() {
      window2.complete();
      subscriber.complete();
    }, handleError, function() {
      closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
      window2 = null;
    }));
  });
}
windowWhen$1.windowWhen = windowWhen;
var withLatestFrom$1 = {};
var __read$2 = commonjsGlobal && commonjsGlobal.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray$4 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i = 0, il2 = from2.length, j2 = to.length; i < il2; i++, j2++)
    to[j2] = from2[i];
  return to;
};
Object.defineProperty(withLatestFrom$1, "__esModule", { value: true });
withLatestFrom$1.withLatestFrom = void 0;
var lift_1$1 = lift$1;
var OperatorSubscriber_1 = OperatorSubscriber$1;
var innerFrom_1 = innerFrom$1;
var identity_1$1 = identity$2;
var noop_1$1 = noop$1;
var args_1 = args;
function withLatestFrom() {
  var inputs = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    inputs[_i] = arguments[_i];
  }
  var project = args_1.popResultSelector(inputs);
  return lift_1$1.operate(function(source, subscriber) {
    var len = inputs.length;
    var otherValues = new Array(len);
    var hasValue = inputs.map(function() {
      return false;
    });
    var ready = false;
    var _loop_1 = function(i2) {
      innerFrom_1.innerFrom(inputs[i2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        otherValues[i2] = value;
        if (!ready && !hasValue[i2]) {
          hasValue[i2] = true;
          (ready = hasValue.every(identity_1$1.identity)) && (hasValue = null);
        }
      }, noop_1$1.noop));
    };
    for (var i = 0; i < len; i++) {
      _loop_1(i);
    }
    source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
      if (ready) {
        var values = __spreadArray$4([value], __read$2(otherValues));
        subscriber.next(project ? project.apply(void 0, __spreadArray$4([], __read$2(values))) : values);
      }
    }));
  });
}
withLatestFrom$1.withLatestFrom = withLatestFrom;
var zipAll$1 = {};
Object.defineProperty(zipAll$1, "__esModule", { value: true });
zipAll$1.zipAll = void 0;
var zip_1$2 = zip$3;
var joinAllInternals_1 = joinAllInternals$1;
function zipAll(project) {
  return joinAllInternals_1.joinAllInternals(zip_1$2.zip, project);
}
zipAll$1.zipAll = zipAll;
var zipWith$1 = {};
var zip$1 = {};
var __read$1 = commonjsGlobal && commonjsGlobal.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray$3 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i = 0, il2 = from2.length, j2 = to.length; i < il2; i++, j2++)
    to[j2] = from2[i];
  return to;
};
Object.defineProperty(zip$1, "__esModule", { value: true });
zip$1.zip = void 0;
var zip_1$1 = zip$3;
var lift_1 = lift$1;
function zip() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  return lift_1.operate(function(source, subscriber) {
    zip_1$1.zip.apply(void 0, __spreadArray$3([source], __read$1(sources))).subscribe(subscriber);
  });
}
zip$1.zip = zip;
var __read = commonjsGlobal && commonjsGlobal.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
};
var __spreadArray$2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2) {
  for (var i = 0, il2 = from2.length, j2 = to.length; i < il2; i++, j2++)
    to[j2] = from2[i];
  return to;
};
Object.defineProperty(zipWith$1, "__esModule", { value: true });
zipWith$1.zipWith = void 0;
var zip_1 = zip$1;
function zipWith() {
  var otherInputs = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherInputs[_i] = arguments[_i];
  }
  return zip_1.zip.apply(void 0, __spreadArray$2([], __read(otherInputs)));
}
zipWith$1.zipWith = zipWith;
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    Object.defineProperty(o, k22, { enumerable: true, get: function() {
      return m2[k2];
    } });
  } : function(o, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding2(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.interval = exports.iif = exports.generate = exports.fromEventPattern = exports.fromEvent = exports.from = exports.forkJoin = exports.empty = exports.defer = exports.connectable = exports.concat = exports.combineLatest = exports.bindNodeCallback = exports.bindCallback = exports.UnsubscriptionError = exports.TimeoutError = exports.SequenceError = exports.ObjectUnsubscribedError = exports.NotFoundError = exports.EmptyError = exports.ArgumentOutOfRangeError = exports.firstValueFrom = exports.lastValueFrom = exports.isObservable = exports.identity = exports.noop = exports.pipe = exports.NotificationKind = exports.Notification = exports.Subscriber = exports.Subscription = exports.Scheduler = exports.VirtualAction = exports.VirtualTimeScheduler = exports.animationFrameScheduler = exports.animationFrame = exports.queueScheduler = exports.queue = exports.asyncScheduler = exports.async = exports.asapScheduler = exports.asap = exports.AsyncSubject = exports.ReplaySubject = exports.BehaviorSubject = exports.Subject = exports.animationFrames = exports.observable = exports.ConnectableObservable = exports.Observable = void 0;
  exports.filter = exports.expand = exports.exhaustMap = exports.exhaustAll = exports.exhaust = exports.every = exports.endWith = exports.elementAt = exports.distinctUntilKeyChanged = exports.distinctUntilChanged = exports.distinct = exports.dematerialize = exports.delayWhen = exports.delay = exports.defaultIfEmpty = exports.debounceTime = exports.debounce = exports.count = exports.connect = exports.concatWith = exports.concatMapTo = exports.concatMap = exports.concatAll = exports.combineLatestWith = exports.combineLatestAll = exports.combineAll = exports.catchError = exports.bufferWhen = exports.bufferToggle = exports.bufferTime = exports.bufferCount = exports.buffer = exports.auditTime = exports.audit = exports.config = exports.NEVER = exports.EMPTY = exports.scheduled = exports.zip = exports.using = exports.timer = exports.throwError = exports.range = exports.race = exports.partition = exports.pairs = exports.onErrorResumeNext = exports.of = exports.never = exports.merge = void 0;
  exports.switchMap = exports.switchAll = exports.subscribeOn = exports.startWith = exports.skipWhile = exports.skipUntil = exports.skipLast = exports.skip = exports.single = exports.shareReplay = exports.share = exports.sequenceEqual = exports.scan = exports.sampleTime = exports.sample = exports.refCount = exports.retryWhen = exports.retry = exports.repeatWhen = exports.repeat = exports.reduce = exports.raceWith = exports.publishReplay = exports.publishLast = exports.publishBehavior = exports.publish = exports.pluck = exports.pairwise = exports.onErrorResumeNextWith = exports.observeOn = exports.multicast = exports.min = exports.mergeWith = exports.mergeScan = exports.mergeMapTo = exports.mergeMap = exports.flatMap = exports.mergeAll = exports.max = exports.materialize = exports.mapTo = exports.map = exports.last = exports.isEmpty = exports.ignoreElements = exports.groupBy = exports.first = exports.findIndex = exports.find = exports.finalize = void 0;
  exports.zipWith = exports.zipAll = exports.withLatestFrom = exports.windowWhen = exports.windowToggle = exports.windowTime = exports.windowCount = exports.window = exports.toArray = exports.timestamp = exports.timeoutWith = exports.timeout = exports.timeInterval = exports.throwIfEmpty = exports.throttleTime = exports.throttle = exports.tap = exports.takeWhile = exports.takeUntil = exports.takeLast = exports.take = exports.switchScan = exports.switchMapTo = void 0;
  var Observable_12 = Observable$1;
  Object.defineProperty(exports, "Observable", { enumerable: true, get: function() {
    return Observable_12.Observable;
  } });
  var ConnectableObservable_12 = ConnectableObservable$1;
  Object.defineProperty(exports, "ConnectableObservable", { enumerable: true, get: function() {
    return ConnectableObservable_12.ConnectableObservable;
  } });
  var observable_12 = observable;
  Object.defineProperty(exports, "observable", { enumerable: true, get: function() {
    return observable_12.observable;
  } });
  var animationFrames_1 = animationFrames$1;
  Object.defineProperty(exports, "animationFrames", { enumerable: true, get: function() {
    return animationFrames_1.animationFrames;
  } });
  var Subject_12 = Subject$1;
  Object.defineProperty(exports, "Subject", { enumerable: true, get: function() {
    return Subject_12.Subject;
  } });
  var BehaviorSubject_12 = BehaviorSubject$1;
  Object.defineProperty(exports, "BehaviorSubject", { enumerable: true, get: function() {
    return BehaviorSubject_12.BehaviorSubject;
  } });
  var ReplaySubject_12 = ReplaySubject$1;
  Object.defineProperty(exports, "ReplaySubject", { enumerable: true, get: function() {
    return ReplaySubject_12.ReplaySubject;
  } });
  var AsyncSubject_12 = AsyncSubject$1;
  Object.defineProperty(exports, "AsyncSubject", { enumerable: true, get: function() {
    return AsyncSubject_12.AsyncSubject;
  } });
  var asap_1 = asap;
  Object.defineProperty(exports, "asap", { enumerable: true, get: function() {
    return asap_1.asap;
  } });
  Object.defineProperty(exports, "asapScheduler", { enumerable: true, get: function() {
    return asap_1.asapScheduler;
  } });
  var async_12 = async;
  Object.defineProperty(exports, "async", { enumerable: true, get: function() {
    return async_12.async;
  } });
  Object.defineProperty(exports, "asyncScheduler", { enumerable: true, get: function() {
    return async_12.asyncScheduler;
  } });
  var queue_1 = queue;
  Object.defineProperty(exports, "queue", { enumerable: true, get: function() {
    return queue_1.queue;
  } });
  Object.defineProperty(exports, "queueScheduler", { enumerable: true, get: function() {
    return queue_1.queueScheduler;
  } });
  var animationFrame_1 = animationFrame;
  Object.defineProperty(exports, "animationFrame", { enumerable: true, get: function() {
    return animationFrame_1.animationFrame;
  } });
  Object.defineProperty(exports, "animationFrameScheduler", { enumerable: true, get: function() {
    return animationFrame_1.animationFrameScheduler;
  } });
  var VirtualTimeScheduler_1 = VirtualTimeScheduler$1;
  Object.defineProperty(exports, "VirtualTimeScheduler", { enumerable: true, get: function() {
    return VirtualTimeScheduler_1.VirtualTimeScheduler;
  } });
  Object.defineProperty(exports, "VirtualAction", { enumerable: true, get: function() {
    return VirtualTimeScheduler_1.VirtualAction;
  } });
  var Scheduler_12 = Scheduler$1;
  Object.defineProperty(exports, "Scheduler", { enumerable: true, get: function() {
    return Scheduler_12.Scheduler;
  } });
  var Subscription_12 = Subscription$1;
  Object.defineProperty(exports, "Subscription", { enumerable: true, get: function() {
    return Subscription_12.Subscription;
  } });
  var Subscriber_12 = Subscriber;
  Object.defineProperty(exports, "Subscriber", { enumerable: true, get: function() {
    return Subscriber_12.Subscriber;
  } });
  var Notification_12 = Notification;
  Object.defineProperty(exports, "Notification", { enumerable: true, get: function() {
    return Notification_12.Notification;
  } });
  Object.defineProperty(exports, "NotificationKind", { enumerable: true, get: function() {
    return Notification_12.NotificationKind;
  } });
  var pipe_12 = pipe$2;
  Object.defineProperty(exports, "pipe", { enumerable: true, get: function() {
    return pipe_12.pipe;
  } });
  var noop_12 = noop$1;
  Object.defineProperty(exports, "noop", { enumerable: true, get: function() {
    return noop_12.noop;
  } });
  var identity_12 = identity$2;
  Object.defineProperty(exports, "identity", { enumerable: true, get: function() {
    return identity_12.identity;
  } });
  var isObservable_1 = isObservable$1;
  Object.defineProperty(exports, "isObservable", { enumerable: true, get: function() {
    return isObservable_1.isObservable;
  } });
  var lastValueFrom_1 = lastValueFrom$1;
  Object.defineProperty(exports, "lastValueFrom", { enumerable: true, get: function() {
    return lastValueFrom_1.lastValueFrom;
  } });
  var firstValueFrom_1 = firstValueFrom$1;
  Object.defineProperty(exports, "firstValueFrom", { enumerable: true, get: function() {
    return firstValueFrom_1.firstValueFrom;
  } });
  var ArgumentOutOfRangeError_12 = ArgumentOutOfRangeError;
  Object.defineProperty(exports, "ArgumentOutOfRangeError", { enumerable: true, get: function() {
    return ArgumentOutOfRangeError_12.ArgumentOutOfRangeError;
  } });
  var EmptyError_12 = EmptyError;
  Object.defineProperty(exports, "EmptyError", { enumerable: true, get: function() {
    return EmptyError_12.EmptyError;
  } });
  var NotFoundError_12 = NotFoundError;
  Object.defineProperty(exports, "NotFoundError", { enumerable: true, get: function() {
    return NotFoundError_12.NotFoundError;
  } });
  var ObjectUnsubscribedError_12 = ObjectUnsubscribedError;
  Object.defineProperty(exports, "ObjectUnsubscribedError", { enumerable: true, get: function() {
    return ObjectUnsubscribedError_12.ObjectUnsubscribedError;
  } });
  var SequenceError_12 = SequenceError;
  Object.defineProperty(exports, "SequenceError", { enumerable: true, get: function() {
    return SequenceError_12.SequenceError;
  } });
  var timeout_12 = timeout;
  Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
    return timeout_12.TimeoutError;
  } });
  var UnsubscriptionError_12 = UnsubscriptionError;
  Object.defineProperty(exports, "UnsubscriptionError", { enumerable: true, get: function() {
    return UnsubscriptionError_12.UnsubscriptionError;
  } });
  var bindCallback_1 = bindCallback$1;
  Object.defineProperty(exports, "bindCallback", { enumerable: true, get: function() {
    return bindCallback_1.bindCallback;
  } });
  var bindNodeCallback_1 = bindNodeCallback$1;
  Object.defineProperty(exports, "bindNodeCallback", { enumerable: true, get: function() {
    return bindNodeCallback_1.bindNodeCallback;
  } });
  var combineLatest_12 = combineLatest$3;
  Object.defineProperty(exports, "combineLatest", { enumerable: true, get: function() {
    return combineLatest_12.combineLatest;
  } });
  var concat_12 = concat$3;
  Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
    return concat_12.concat;
  } });
  var connectable_1 = connectable$1;
  Object.defineProperty(exports, "connectable", { enumerable: true, get: function() {
    return connectable_1.connectable;
  } });
  var defer_12 = defer$1;
  Object.defineProperty(exports, "defer", { enumerable: true, get: function() {
    return defer_12.defer;
  } });
  var empty_12 = empty;
  Object.defineProperty(exports, "empty", { enumerable: true, get: function() {
    return empty_12.empty;
  } });
  var forkJoin_1 = forkJoin$1;
  Object.defineProperty(exports, "forkJoin", { enumerable: true, get: function() {
    return forkJoin_1.forkJoin;
  } });
  var from_12 = from$2;
  Object.defineProperty(exports, "from", { enumerable: true, get: function() {
    return from_12.from;
  } });
  var fromEvent_1 = fromEvent$1;
  Object.defineProperty(exports, "fromEvent", { enumerable: true, get: function() {
    return fromEvent_1.fromEvent;
  } });
  var fromEventPattern_1 = fromEventPattern$1;
  Object.defineProperty(exports, "fromEventPattern", { enumerable: true, get: function() {
    return fromEventPattern_1.fromEventPattern;
  } });
  var generate_1 = generate$1;
  Object.defineProperty(exports, "generate", { enumerable: true, get: function() {
    return generate_1.generate;
  } });
  var iif_1 = iif$1;
  Object.defineProperty(exports, "iif", { enumerable: true, get: function() {
    return iif_1.iif;
  } });
  var interval_12 = interval$1;
  Object.defineProperty(exports, "interval", { enumerable: true, get: function() {
    return interval_12.interval;
  } });
  var merge_12 = merge$5;
  Object.defineProperty(exports, "merge", { enumerable: true, get: function() {
    return merge_12.merge;
  } });
  var never_1 = never;
  Object.defineProperty(exports, "never", { enumerable: true, get: function() {
    return never_1.never;
  } });
  var of_12 = of$1;
  Object.defineProperty(exports, "of", { enumerable: true, get: function() {
    return of_12.of;
  } });
  var onErrorResumeNext_12 = onErrorResumeNext$1;
  Object.defineProperty(exports, "onErrorResumeNext", { enumerable: true, get: function() {
    return onErrorResumeNext_12.onErrorResumeNext;
  } });
  var pairs_1 = pairs$1;
  Object.defineProperty(exports, "pairs", { enumerable: true, get: function() {
    return pairs_1.pairs;
  } });
  var partition_1 = partition$1;
  Object.defineProperty(exports, "partition", { enumerable: true, get: function() {
    return partition_1.partition;
  } });
  var race_12 = race$1;
  Object.defineProperty(exports, "race", { enumerable: true, get: function() {
    return race_12.race;
  } });
  var range_1 = range$1;
  Object.defineProperty(exports, "range", { enumerable: true, get: function() {
    return range_1.range;
  } });
  var throwError_1 = throwError$1;
  Object.defineProperty(exports, "throwError", { enumerable: true, get: function() {
    return throwError_1.throwError;
  } });
  var timer_12 = timer$1;
  Object.defineProperty(exports, "timer", { enumerable: true, get: function() {
    return timer_12.timer;
  } });
  var using_1 = using$1;
  Object.defineProperty(exports, "using", { enumerable: true, get: function() {
    return using_1.using;
  } });
  var zip_12 = zip$3;
  Object.defineProperty(exports, "zip", { enumerable: true, get: function() {
    return zip_12.zip;
  } });
  var scheduled_12 = scheduled$1;
  Object.defineProperty(exports, "scheduled", { enumerable: true, get: function() {
    return scheduled_12.scheduled;
  } });
  var empty_2 = empty;
  Object.defineProperty(exports, "EMPTY", { enumerable: true, get: function() {
    return empty_2.EMPTY;
  } });
  var never_2 = never;
  Object.defineProperty(exports, "NEVER", { enumerable: true, get: function() {
    return never_2.NEVER;
  } });
  __exportStar(types, exports);
  var config_12 = config;
  Object.defineProperty(exports, "config", { enumerable: true, get: function() {
    return config_12.config;
  } });
  var audit_12 = audit$1;
  Object.defineProperty(exports, "audit", { enumerable: true, get: function() {
    return audit_12.audit;
  } });
  var auditTime_1 = auditTime$1;
  Object.defineProperty(exports, "auditTime", { enumerable: true, get: function() {
    return auditTime_1.auditTime;
  } });
  var buffer_1 = buffer$1;
  Object.defineProperty(exports, "buffer", { enumerable: true, get: function() {
    return buffer_1.buffer;
  } });
  var bufferCount_1 = bufferCount$1;
  Object.defineProperty(exports, "bufferCount", { enumerable: true, get: function() {
    return bufferCount_1.bufferCount;
  } });
  var bufferTime_1 = bufferTime$1;
  Object.defineProperty(exports, "bufferTime", { enumerable: true, get: function() {
    return bufferTime_1.bufferTime;
  } });
  var bufferToggle_1 = bufferToggle$1;
  Object.defineProperty(exports, "bufferToggle", { enumerable: true, get: function() {
    return bufferToggle_1.bufferToggle;
  } });
  var bufferWhen_1 = bufferWhen$1;
  Object.defineProperty(exports, "bufferWhen", { enumerable: true, get: function() {
    return bufferWhen_1.bufferWhen;
  } });
  var catchError_1 = catchError$1;
  Object.defineProperty(exports, "catchError", { enumerable: true, get: function() {
    return catchError_1.catchError;
  } });
  var combineAll_1 = combineAll;
  Object.defineProperty(exports, "combineAll", { enumerable: true, get: function() {
    return combineAll_1.combineAll;
  } });
  var combineLatestAll_12 = combineLatestAll$1;
  Object.defineProperty(exports, "combineLatestAll", { enumerable: true, get: function() {
    return combineLatestAll_12.combineLatestAll;
  } });
  var combineLatestWith_1 = combineLatestWith$1;
  Object.defineProperty(exports, "combineLatestWith", { enumerable: true, get: function() {
    return combineLatestWith_1.combineLatestWith;
  } });
  var concatAll_12 = concatAll$1;
  Object.defineProperty(exports, "concatAll", { enumerable: true, get: function() {
    return concatAll_12.concatAll;
  } });
  var concatMap_12 = concatMap$1;
  Object.defineProperty(exports, "concatMap", { enumerable: true, get: function() {
    return concatMap_12.concatMap;
  } });
  var concatMapTo_1 = concatMapTo$1;
  Object.defineProperty(exports, "concatMapTo", { enumerable: true, get: function() {
    return concatMapTo_1.concatMapTo;
  } });
  var concatWith_1 = concatWith$1;
  Object.defineProperty(exports, "concatWith", { enumerable: true, get: function() {
    return concatWith_1.concatWith;
  } });
  var connect_12 = connect$1;
  Object.defineProperty(exports, "connect", { enumerable: true, get: function() {
    return connect_12.connect;
  } });
  var count_1 = count$1;
  Object.defineProperty(exports, "count", { enumerable: true, get: function() {
    return count_1.count;
  } });
  var debounce_12 = debounce$1;
  Object.defineProperty(exports, "debounce", { enumerable: true, get: function() {
    return debounce_12.debounce;
  } });
  var debounceTime_1 = debounceTime$1;
  Object.defineProperty(exports, "debounceTime", { enumerable: true, get: function() {
    return debounceTime_1.debounceTime;
  } });
  var defaultIfEmpty_12 = defaultIfEmpty$1;
  Object.defineProperty(exports, "defaultIfEmpty", { enumerable: true, get: function() {
    return defaultIfEmpty_12.defaultIfEmpty;
  } });
  var delay_1 = delay$1;
  Object.defineProperty(exports, "delay", { enumerable: true, get: function() {
    return delay_1.delay;
  } });
  var delayWhen_12 = delayWhen$1;
  Object.defineProperty(exports, "delayWhen", { enumerable: true, get: function() {
    return delayWhen_12.delayWhen;
  } });
  var dematerialize_1 = dematerialize$1;
  Object.defineProperty(exports, "dematerialize", { enumerable: true, get: function() {
    return dematerialize_1.dematerialize;
  } });
  var distinct_1 = distinct$1;
  Object.defineProperty(exports, "distinct", { enumerable: true, get: function() {
    return distinct_1.distinct;
  } });
  var distinctUntilChanged_12 = distinctUntilChanged$1;
  Object.defineProperty(exports, "distinctUntilChanged", { enumerable: true, get: function() {
    return distinctUntilChanged_12.distinctUntilChanged;
  } });
  var distinctUntilKeyChanged_1 = distinctUntilKeyChanged$1;
  Object.defineProperty(exports, "distinctUntilKeyChanged", { enumerable: true, get: function() {
    return distinctUntilKeyChanged_1.distinctUntilKeyChanged;
  } });
  var elementAt_1 = elementAt$1;
  Object.defineProperty(exports, "elementAt", { enumerable: true, get: function() {
    return elementAt_1.elementAt;
  } });
  var endWith_1 = endWith$1;
  Object.defineProperty(exports, "endWith", { enumerable: true, get: function() {
    return endWith_1.endWith;
  } });
  var every_1 = every$1;
  Object.defineProperty(exports, "every", { enumerable: true, get: function() {
    return every_1.every;
  } });
  var exhaust_1 = exhaust;
  Object.defineProperty(exports, "exhaust", { enumerable: true, get: function() {
    return exhaust_1.exhaust;
  } });
  var exhaustAll_12 = exhaustAll$1;
  Object.defineProperty(exports, "exhaustAll", { enumerable: true, get: function() {
    return exhaustAll_12.exhaustAll;
  } });
  var exhaustMap_12 = exhaustMap$1;
  Object.defineProperty(exports, "exhaustMap", { enumerable: true, get: function() {
    return exhaustMap_12.exhaustMap;
  } });
  var expand_1 = expand$1;
  Object.defineProperty(exports, "expand", { enumerable: true, get: function() {
    return expand_1.expand;
  } });
  var filter_12 = filter$2;
  Object.defineProperty(exports, "filter", { enumerable: true, get: function() {
    return filter_12.filter;
  } });
  var finalize_1 = finalize$1;
  Object.defineProperty(exports, "finalize", { enumerable: true, get: function() {
    return finalize_1.finalize;
  } });
  var find_12 = find$1;
  Object.defineProperty(exports, "find", { enumerable: true, get: function() {
    return find_12.find;
  } });
  var findIndex_1 = findIndex$1;
  Object.defineProperty(exports, "findIndex", { enumerable: true, get: function() {
    return findIndex_1.findIndex;
  } });
  var first_1 = first$2;
  Object.defineProperty(exports, "first", { enumerable: true, get: function() {
    return first_1.first;
  } });
  var groupBy_1 = groupBy$2;
  Object.defineProperty(exports, "groupBy", { enumerable: true, get: function() {
    return groupBy_1.groupBy;
  } });
  var ignoreElements_12 = ignoreElements$1;
  Object.defineProperty(exports, "ignoreElements", { enumerable: true, get: function() {
    return ignoreElements_12.ignoreElements;
  } });
  var isEmpty_1 = isEmpty$2;
  Object.defineProperty(exports, "isEmpty", { enumerable: true, get: function() {
    return isEmpty_1.isEmpty;
  } });
  var last_1 = last$1;
  Object.defineProperty(exports, "last", { enumerable: true, get: function() {
    return last_1.last;
  } });
  var map_12 = map$1;
  Object.defineProperty(exports, "map", { enumerable: true, get: function() {
    return map_12.map;
  } });
  var mapTo_12 = mapTo$1;
  Object.defineProperty(exports, "mapTo", { enumerable: true, get: function() {
    return mapTo_12.mapTo;
  } });
  var materialize_1 = materialize$1;
  Object.defineProperty(exports, "materialize", { enumerable: true, get: function() {
    return materialize_1.materialize;
  } });
  var max_1 = max$1;
  Object.defineProperty(exports, "max", { enumerable: true, get: function() {
    return max_1.max;
  } });
  var mergeAll_12 = mergeAll$1;
  Object.defineProperty(exports, "mergeAll", { enumerable: true, get: function() {
    return mergeAll_12.mergeAll;
  } });
  var flatMap_1 = flatMap;
  Object.defineProperty(exports, "flatMap", { enumerable: true, get: function() {
    return flatMap_1.flatMap;
  } });
  var mergeMap_12 = mergeMap$1;
  Object.defineProperty(exports, "mergeMap", { enumerable: true, get: function() {
    return mergeMap_12.mergeMap;
  } });
  var mergeMapTo_1 = mergeMapTo$1;
  Object.defineProperty(exports, "mergeMapTo", { enumerable: true, get: function() {
    return mergeMapTo_1.mergeMapTo;
  } });
  var mergeScan_1 = mergeScan$1;
  Object.defineProperty(exports, "mergeScan", { enumerable: true, get: function() {
    return mergeScan_1.mergeScan;
  } });
  var mergeWith_1 = mergeWith$1;
  Object.defineProperty(exports, "mergeWith", { enumerable: true, get: function() {
    return mergeWith_1.mergeWith;
  } });
  var min_1 = min$1;
  Object.defineProperty(exports, "min", { enumerable: true, get: function() {
    return min_1.min;
  } });
  var multicast_12 = multicast$1;
  Object.defineProperty(exports, "multicast", { enumerable: true, get: function() {
    return multicast_12.multicast;
  } });
  var observeOn_12 = observeOn$1;
  Object.defineProperty(exports, "observeOn", { enumerable: true, get: function() {
    return observeOn_12.observeOn;
  } });
  var onErrorResumeNextWith_1 = onErrorResumeNextWith$1;
  Object.defineProperty(exports, "onErrorResumeNextWith", { enumerable: true, get: function() {
    return onErrorResumeNextWith_1.onErrorResumeNextWith;
  } });
  var pairwise_1 = pairwise$1;
  Object.defineProperty(exports, "pairwise", { enumerable: true, get: function() {
    return pairwise_1.pairwise;
  } });
  var pluck_1 = pluck$1;
  Object.defineProperty(exports, "pluck", { enumerable: true, get: function() {
    return pluck_1.pluck;
  } });
  var publish_1 = publish$1;
  Object.defineProperty(exports, "publish", { enumerable: true, get: function() {
    return publish_1.publish;
  } });
  var publishBehavior_1 = publishBehavior$1;
  Object.defineProperty(exports, "publishBehavior", { enumerable: true, get: function() {
    return publishBehavior_1.publishBehavior;
  } });
  var publishLast_1 = publishLast$1;
  Object.defineProperty(exports, "publishLast", { enumerable: true, get: function() {
    return publishLast_1.publishLast;
  } });
  var publishReplay_1 = publishReplay$1;
  Object.defineProperty(exports, "publishReplay", { enumerable: true, get: function() {
    return publishReplay_1.publishReplay;
  } });
  var raceWith_1 = raceWith$1;
  Object.defineProperty(exports, "raceWith", { enumerable: true, get: function() {
    return raceWith_1.raceWith;
  } });
  var reduce_12 = reduce$1;
  Object.defineProperty(exports, "reduce", { enumerable: true, get: function() {
    return reduce_12.reduce;
  } });
  var repeat_1 = repeat$1;
  Object.defineProperty(exports, "repeat", { enumerable: true, get: function() {
    return repeat_1.repeat;
  } });
  var repeatWhen_1 = repeatWhen$1;
  Object.defineProperty(exports, "repeatWhen", { enumerable: true, get: function() {
    return repeatWhen_1.repeatWhen;
  } });
  var retry_1 = retry$1;
  Object.defineProperty(exports, "retry", { enumerable: true, get: function() {
    return retry_1.retry;
  } });
  var retryWhen_1 = retryWhen$1;
  Object.defineProperty(exports, "retryWhen", { enumerable: true, get: function() {
    return retryWhen_1.retryWhen;
  } });
  var refCount_12 = refCount$1;
  Object.defineProperty(exports, "refCount", { enumerable: true, get: function() {
    return refCount_12.refCount;
  } });
  var sample_12 = sample$1;
  Object.defineProperty(exports, "sample", { enumerable: true, get: function() {
    return sample_12.sample;
  } });
  var sampleTime_1 = sampleTime$1;
  Object.defineProperty(exports, "sampleTime", { enumerable: true, get: function() {
    return sampleTime_1.sampleTime;
  } });
  var scan_1 = scan$1;
  Object.defineProperty(exports, "scan", { enumerable: true, get: function() {
    return scan_1.scan;
  } });
  var sequenceEqual_1 = sequenceEqual$1;
  Object.defineProperty(exports, "sequenceEqual", { enumerable: true, get: function() {
    return sequenceEqual_1.sequenceEqual;
  } });
  var share_12 = share$1;
  Object.defineProperty(exports, "share", { enumerable: true, get: function() {
    return share_12.share;
  } });
  var shareReplay_1 = shareReplay$1;
  Object.defineProperty(exports, "shareReplay", { enumerable: true, get: function() {
    return shareReplay_1.shareReplay;
  } });
  var single_1 = single$1;
  Object.defineProperty(exports, "single", { enumerable: true, get: function() {
    return single_1.single;
  } });
  var skip_1 = skip$1;
  Object.defineProperty(exports, "skip", { enumerable: true, get: function() {
    return skip_1.skip;
  } });
  var skipLast_1 = skipLast$1;
  Object.defineProperty(exports, "skipLast", { enumerable: true, get: function() {
    return skipLast_1.skipLast;
  } });
  var skipUntil_1 = skipUntil$1;
  Object.defineProperty(exports, "skipUntil", { enumerable: true, get: function() {
    return skipUntil_1.skipUntil;
  } });
  var skipWhile_1 = skipWhile$1;
  Object.defineProperty(exports, "skipWhile", { enumerable: true, get: function() {
    return skipWhile_1.skipWhile;
  } });
  var startWith_1 = startWith$1;
  Object.defineProperty(exports, "startWith", { enumerable: true, get: function() {
    return startWith_1.startWith;
  } });
  var subscribeOn_12 = subscribeOn$1;
  Object.defineProperty(exports, "subscribeOn", { enumerable: true, get: function() {
    return subscribeOn_12.subscribeOn;
  } });
  var switchAll_1 = switchAll$1;
  Object.defineProperty(exports, "switchAll", { enumerable: true, get: function() {
    return switchAll_1.switchAll;
  } });
  var switchMap_12 = switchMap$1;
  Object.defineProperty(exports, "switchMap", { enumerable: true, get: function() {
    return switchMap_12.switchMap;
  } });
  var switchMapTo_1 = switchMapTo$1;
  Object.defineProperty(exports, "switchMapTo", { enumerable: true, get: function() {
    return switchMapTo_1.switchMapTo;
  } });
  var switchScan_1 = switchScan$1;
  Object.defineProperty(exports, "switchScan", { enumerable: true, get: function() {
    return switchScan_1.switchScan;
  } });
  var take_12 = take$1;
  Object.defineProperty(exports, "take", { enumerable: true, get: function() {
    return take_12.take;
  } });
  var takeLast_12 = takeLast$1;
  Object.defineProperty(exports, "takeLast", { enumerable: true, get: function() {
    return takeLast_12.takeLast;
  } });
  var takeUntil_1 = takeUntil$1;
  Object.defineProperty(exports, "takeUntil", { enumerable: true, get: function() {
    return takeUntil_1.takeUntil;
  } });
  var takeWhile_1 = takeWhile$1;
  Object.defineProperty(exports, "takeWhile", { enumerable: true, get: function() {
    return takeWhile_1.takeWhile;
  } });
  var tap_1 = tap$1;
  Object.defineProperty(exports, "tap", { enumerable: true, get: function() {
    return tap_1.tap;
  } });
  var throttle_12 = throttle$1;
  Object.defineProperty(exports, "throttle", { enumerable: true, get: function() {
    return throttle_12.throttle;
  } });
  var throttleTime_1 = throttleTime$1;
  Object.defineProperty(exports, "throttleTime", { enumerable: true, get: function() {
    return throttleTime_1.throttleTime;
  } });
  var throwIfEmpty_12 = throwIfEmpty$1;
  Object.defineProperty(exports, "throwIfEmpty", { enumerable: true, get: function() {
    return throwIfEmpty_12.throwIfEmpty;
  } });
  var timeInterval_1 = timeInterval$1;
  Object.defineProperty(exports, "timeInterval", { enumerable: true, get: function() {
    return timeInterval_1.timeInterval;
  } });
  var timeout_2 = timeout;
  Object.defineProperty(exports, "timeout", { enumerable: true, get: function() {
    return timeout_2.timeout;
  } });
  var timeoutWith_1 = timeoutWith$1;
  Object.defineProperty(exports, "timeoutWith", { enumerable: true, get: function() {
    return timeoutWith_1.timeoutWith;
  } });
  var timestamp_1 = timestamp$1;
  Object.defineProperty(exports, "timestamp", { enumerable: true, get: function() {
    return timestamp_1.timestamp;
  } });
  var toArray_12 = toArray$1;
  Object.defineProperty(exports, "toArray", { enumerable: true, get: function() {
    return toArray_12.toArray;
  } });
  var window_1 = window$2;
  Object.defineProperty(exports, "window", { enumerable: true, get: function() {
    return window_1.window;
  } });
  var windowCount_1 = windowCount$1;
  Object.defineProperty(exports, "windowCount", { enumerable: true, get: function() {
    return windowCount_1.windowCount;
  } });
  var windowTime_1 = windowTime$1;
  Object.defineProperty(exports, "windowTime", { enumerable: true, get: function() {
    return windowTime_1.windowTime;
  } });
  var windowToggle_1 = windowToggle$1;
  Object.defineProperty(exports, "windowToggle", { enumerable: true, get: function() {
    return windowToggle_1.windowToggle;
  } });
  var windowWhen_1 = windowWhen$1;
  Object.defineProperty(exports, "windowWhen", { enumerable: true, get: function() {
    return windowWhen_1.windowWhen;
  } });
  var withLatestFrom_1 = withLatestFrom$1;
  Object.defineProperty(exports, "withLatestFrom", { enumerable: true, get: function() {
    return withLatestFrom_1.withLatestFrom;
  } });
  var zipAll_1 = zipAll$1;
  Object.defineProperty(exports, "zipAll", { enumerable: true, get: function() {
    return zipAll_1.zipAll;
  } });
  var zipWith_1 = zipWith$1;
  Object.defineProperty(exports, "zipWith", { enumerable: true, get: function() {
    return zipWith_1.zipWith;
  } });
})(cjs);
function lastOfArray(ar) {
  return ar[ar.length - 1];
}
function isObject$2(value) {
  const type2 = typeof value;
  return value !== null && (type2 === "object" || type2 === "function");
}
function getProperty(object, path, value) {
  if (Array.isArray(path)) {
    path = path.join(".");
  }
  if (!isObject$2(object) || typeof path !== "string") {
    return value === void 0 ? object : value;
  }
  const pathArray = path.split(".");
  if (pathArray.length === 0) {
    return value;
  }
  for (let index = 0; index < pathArray.length; index++) {
    const key = pathArray[index];
    if (isStringIndex(object, key)) {
      object = index === pathArray.length - 1 ? void 0 : null;
    } else {
      object = object[key];
    }
    if (object === void 0 || object === null) {
      if (index !== pathArray.length - 1) {
        return value;
      }
      break;
    }
  }
  return object === void 0 ? value : object;
}
function isStringIndex(object, key) {
  if (typeof key !== "number" && Array.isArray(object)) {
    const index = Number.parseInt(key, 10);
    return Number.isInteger(index) && object[index] === object[key];
  }
  return false;
}
const hasLimit = (input) => {
  return !!input.queryParams.limit;
};
const isFindOne = (input) => {
  return input.queryParams.limit === 1;
};
const hasSkip = (input) => {
  if (input.queryParams.skip && input.queryParams.skip > 0) {
    return true;
  } else {
    return false;
  }
};
const isDelete = (input) => {
  return input.changeEvent.operation === "DELETE";
};
const isInsert = (input) => {
  return input.changeEvent.operation === "INSERT";
};
const isUpdate = (input) => {
  return input.changeEvent.operation === "UPDATE";
};
const wasLimitReached = (input) => {
  return hasLimit(input) && input.previousResults.length >= input.queryParams.limit;
};
const sortParamsChanged = (input) => {
  const sortFields = input.queryParams.sortFields;
  const prev2 = input.changeEvent.previous;
  const doc = input.changeEvent.doc;
  if (!doc) {
    return false;
  }
  if (!prev2) {
    return true;
  }
  for (let i = 0; i < sortFields.length; i++) {
    const field = sortFields[i];
    const beforeData = getProperty(prev2, field);
    const afterData = getProperty(doc, field);
    if (beforeData !== afterData) {
      return true;
    }
  }
  return false;
};
const wasInResult = (input) => {
  const id2 = input.changeEvent.id;
  if (input.keyDocumentMap) {
    const has2 = input.keyDocumentMap.has(id2);
    return has2;
  } else {
    const primary = input.queryParams.primaryKey;
    const results = input.previousResults;
    for (let i = 0; i < results.length; i++) {
      const item = results[i];
      if (item[primary] === id2) {
        return true;
      }
    }
    return false;
  }
};
const wasFirst = (input) => {
  const first2 = input.previousResults[0];
  if (first2 && first2[input.queryParams.primaryKey] === input.changeEvent.id) {
    return true;
  } else {
    return false;
  }
};
const wasLast = (input) => {
  const last2 = lastOfArray(input.previousResults);
  if (last2 && last2[input.queryParams.primaryKey] === input.changeEvent.id) {
    return true;
  } else {
    return false;
  }
};
const wasSortedBeforeFirst = (input) => {
  const prev2 = input.changeEvent.previous;
  if (!prev2) {
    return false;
  }
  const first2 = input.previousResults[0];
  if (!first2) {
    return false;
  }
  if (first2[input.queryParams.primaryKey] === input.changeEvent.id) {
    return true;
  }
  const comp = input.queryParams.sortComparator(prev2, first2);
  return comp < 0;
};
const wasSortedAfterLast = (input) => {
  const prev2 = input.changeEvent.previous;
  if (!prev2) {
    return false;
  }
  const last2 = lastOfArray(input.previousResults);
  if (!last2) {
    return false;
  }
  if (last2[input.queryParams.primaryKey] === input.changeEvent.id) {
    return true;
  }
  const comp = input.queryParams.sortComparator(prev2, last2);
  return comp > 0;
};
const isSortedBeforeFirst = (input) => {
  const doc = input.changeEvent.doc;
  if (!doc) {
    return false;
  }
  const first2 = input.previousResults[0];
  if (!first2) {
    return false;
  }
  if (first2[input.queryParams.primaryKey] === input.changeEvent.id) {
    return true;
  }
  const comp = input.queryParams.sortComparator(doc, first2);
  return comp < 0;
};
const isSortedAfterLast = (input) => {
  const doc = input.changeEvent.doc;
  if (!doc) {
    return false;
  }
  const last2 = lastOfArray(input.previousResults);
  if (!last2) {
    return false;
  }
  if (last2[input.queryParams.primaryKey] === input.changeEvent.id) {
    return true;
  }
  const comp = input.queryParams.sortComparator(doc, last2);
  return comp > 0;
};
const wasMatching = (input) => {
  const prev2 = input.changeEvent.previous;
  if (!prev2) {
    return false;
  }
  return input.queryParams.queryMatcher(prev2);
};
const doesMatchNow = (input) => {
  const doc = input.changeEvent.doc;
  if (!doc) {
    return false;
  }
  const ret = input.queryParams.queryMatcher(doc);
  return ret;
};
const wasResultsEmpty = (input) => {
  return input.previousResults.length === 0;
};
const stateResolveFunctionByIndex = {
  0: isInsert,
  1: isUpdate,
  2: isDelete,
  3: hasLimit,
  4: isFindOne,
  5: hasSkip,
  6: wasResultsEmpty,
  7: wasLimitReached,
  8: wasFirst,
  9: wasLast,
  10: sortParamsChanged,
  11: wasInResult,
  12: wasSortedBeforeFirst,
  13: wasSortedAfterLast,
  14: isSortedBeforeFirst,
  15: isSortedAfterLast,
  16: wasMatching,
  17: doesMatchNow
};
function pushAtSortPosition(array, item, compareFunction, low) {
  var length2 = array.length;
  var high = length2 - 1;
  var mid = 0;
  if (length2 === 0) {
    array.push(item);
    return 0;
  }
  var lastMidDoc;
  while (low <= high) {
    mid = low + (high - low >> 1);
    lastMidDoc = array[mid];
    if (compareFunction(lastMidDoc, item) <= 0) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  if (compareFunction(lastMidDoc, item) <= 0) {
    mid++;
  }
  array.splice(mid, 0, item);
  return mid;
}
const doNothing = (_input) => {
};
const insertFirst = (input) => {
  input.previousResults.unshift(input.changeEvent.doc);
  if (input.keyDocumentMap) {
    input.keyDocumentMap.set(input.changeEvent.id, input.changeEvent.doc);
  }
};
const insertLast = (input) => {
  input.previousResults.push(input.changeEvent.doc);
  if (input.keyDocumentMap) {
    input.keyDocumentMap.set(input.changeEvent.id, input.changeEvent.doc);
  }
};
const removeFirstItem = (input) => {
  const first2 = input.previousResults.shift();
  if (input.keyDocumentMap && first2) {
    input.keyDocumentMap.delete(first2[input.queryParams.primaryKey]);
  }
};
const removeLastItem = (input) => {
  const last2 = input.previousResults.pop();
  if (input.keyDocumentMap && last2) {
    input.keyDocumentMap.delete(last2[input.queryParams.primaryKey]);
  }
};
const removeFirstInsertLast = (input) => {
  removeFirstItem(input);
  insertLast(input);
};
const removeLastInsertFirst = (input) => {
  removeLastItem(input);
  insertFirst(input);
};
const removeFirstInsertFirst = (input) => {
  removeFirstItem(input);
  insertFirst(input);
};
const removeLastInsertLast = (input) => {
  removeLastItem(input);
  insertLast(input);
};
const removeExisting = (input) => {
  if (input.keyDocumentMap) {
    input.keyDocumentMap.delete(input.changeEvent.id);
  }
  const primary = input.queryParams.primaryKey;
  const results = input.previousResults;
  for (let i = 0; i < results.length; i++) {
    const item = results[i];
    if (item[primary] === input.changeEvent.id) {
      results.splice(i, 1);
      break;
    }
  }
};
const replaceExisting = (input) => {
  const doc = input.changeEvent.doc;
  const primary = input.queryParams.primaryKey;
  const results = input.previousResults;
  for (let i = 0; i < results.length; i++) {
    const item = results[i];
    if (item[primary] === input.changeEvent.id) {
      results[i] = doc;
      if (input.keyDocumentMap) {
        input.keyDocumentMap.set(input.changeEvent.id, doc);
      }
      break;
    }
  }
};
const alwaysWrong = (input) => {
  const wrongHuman = {
    _id: "wrongHuman" + (/* @__PURE__ */ new Date()).getTime()
  };
  input.previousResults.length = 0;
  input.previousResults.push(wrongHuman);
  if (input.keyDocumentMap) {
    input.keyDocumentMap.clear();
    input.keyDocumentMap.set(wrongHuman._id, wrongHuman);
  }
};
const insertAtSortPosition = (input) => {
  const docId = input.changeEvent.id;
  const doc = input.changeEvent.doc;
  if (input.keyDocumentMap) {
    if (input.keyDocumentMap.has(docId)) {
      return;
    }
    input.keyDocumentMap.set(docId, doc);
  } else {
    const isDocInResults = input.previousResults.find((d) => d[input.queryParams.primaryKey] === docId);
    if (isDocInResults) {
      return;
    }
  }
  pushAtSortPosition(input.previousResults, doc, input.queryParams.sortComparator, 0);
};
const removeExistingAndInsertAtSortPosition = (input) => {
  removeExisting(input);
  insertAtSortPosition(input);
};
const runFullQueryAgain = (_input) => {
  throw new Error("Action runFullQueryAgain must be implemented by yourself");
};
const unknownAction = (_input) => {
  throw new Error("Action unknownAction should never be called");
};
const orderedActionList = [
  "doNothing",
  "insertFirst",
  "insertLast",
  "removeFirstItem",
  "removeLastItem",
  "removeFirstInsertLast",
  "removeLastInsertFirst",
  "removeFirstInsertFirst",
  "removeLastInsertLast",
  "removeExisting",
  "replaceExisting",
  "alwaysWrong",
  "insertAtSortPosition",
  "removeExistingAndInsertAtSortPosition",
  "runFullQueryAgain",
  "unknownAction"
];
const actionFunctions = {
  doNothing,
  insertFirst,
  insertLast,
  removeFirstItem,
  removeLastItem,
  removeFirstInsertLast,
  removeLastInsertFirst,
  removeFirstInsertFirst,
  removeLastInsertLast,
  removeExisting,
  replaceExisting,
  alwaysWrong,
  insertAtSortPosition,
  removeExistingAndInsertAtSortPosition,
  runFullQueryAgain,
  unknownAction
};
const CHAR_CODE_OFFSET = 40;
function getNumberOfChar(char2) {
  const charCode = char2.charCodeAt(0);
  return charCode - CHAR_CODE_OFFSET;
}
function booleanToBooleanString(b2) {
  if (b2) {
    return "1";
  } else {
    return "0";
  }
}
function splitStringToChunks(str, chunkSize) {
  const chunks = [];
  for (let i = 0, charsLength = str.length; i < charsLength; i += chunkSize) {
    chunks.push(str.substring(i, i + chunkSize));
  }
  return chunks;
}
function minimalStringToSimpleBdd(str) {
  const nodesById = /* @__PURE__ */ new Map();
  const leafNodeAmount = parseInt(str.charAt(0) + str.charAt(1), 10);
  const lastLeafNodeChar = 2 + leafNodeAmount * 2;
  const leafNodeChars = str.substring(2, lastLeafNodeChar);
  const leafNodeChunks = splitStringToChunks(leafNodeChars, 2);
  for (let i = 0; i < leafNodeChunks.length; i++) {
    const chunk = leafNodeChunks[i];
    const id2 = chunk.charAt(0);
    const value = getNumberOfChar(chunk.charAt(1));
    nodesById.set(id2, value);
  }
  const internalNodeChars = str.substring(lastLeafNodeChar, str.length - 3);
  const internalNodeChunks = splitStringToChunks(internalNodeChars, 4);
  for (let i = 0; i < internalNodeChunks.length; i++) {
    const chunk = internalNodeChunks[i];
    const id2 = chunk.charAt(0);
    const idOf0Branch = chunk.charAt(1);
    const idOf1Branch = chunk.charAt(2);
    const level = getNumberOfChar(chunk.charAt(3));
    if (!nodesById.has(idOf0Branch)) {
      throw new Error("missing node with id " + idOf0Branch);
    }
    if (!nodesById.has(idOf1Branch)) {
      throw new Error("missing node with id " + idOf1Branch);
    }
    const node0 = nodesById.get(idOf0Branch);
    const node1 = nodesById.get(idOf1Branch);
    const node2 = {
      l: level,
      // level is first for prettier json output
      0: node0,
      1: node1
    };
    nodesById.set(id2, node2);
  }
  const last3 = str.slice(-3);
  const idOf0 = last3.charAt(0);
  const idOf1 = last3.charAt(1);
  const levelOfRoot = getNumberOfChar(last3.charAt(2));
  const nodeOf0 = nodesById.get(idOf0);
  const nodeOf1 = nodesById.get(idOf1);
  const rootNode = {
    l: levelOfRoot,
    0: nodeOf0,
    1: nodeOf1
  };
  return rootNode;
}
function resolveWithSimpleBdd(simpleBdd2, fns, input) {
  let currentNode = simpleBdd2;
  let currentLevel = simpleBdd2.l;
  while (true) {
    const booleanResult = fns[currentLevel](input);
    const branchKey = booleanToBooleanString(booleanResult);
    currentNode = currentNode[branchKey];
    if (typeof currentNode === "number" || typeof currentNode === "string") {
      return currentNode;
    } else {
      currentLevel = currentNode.l;
    }
  }
}
const minimalBddString = "14a1b,c+d2e5f0g/h.i4j*k-l)m(n6oeh6pnm6qen6ril6snh6tin6ubo9vce9wmh9xns9yne9zmi9{cm9|ad9}cp9~aq9ae9bf9bq9cg9ck9cn9nd9np9nq9nf9ng9nm9nk9mr9ms9mt9mj9mk9ml9mn9mc8{8}888mn88m8m4z4w4z44444m4v7yn77~777n777m77m7m7m5m5m55m555m55m5m552|2u2222x222|222222n2n222n2/an/bn/cn///////////,cn,,,,,,,ac0bc00000000000m-m-----------3333(((++++11*m*.";
let simpleBdd;
function getSimpleBdd() {
  if (!simpleBdd) {
    simpleBdd = minimalStringToSimpleBdd(minimalBddString);
  }
  return simpleBdd;
}
const resolveInput = (input) => {
  return resolveWithSimpleBdd(getSimpleBdd(), stateResolveFunctionByIndex, input);
};
function calculateActionName(input) {
  const resolvedActionId = resolveInput(input);
  return orderedActionList[resolvedActionId];
}
function runAction(action, queryParams, changeEvent, previousResults, keyDocumentMap) {
  const fn = actionFunctions[action];
  fn({
    queryParams,
    changeEvent,
    previousResults,
    keyDocumentMap
  });
  return previousResults;
}
var INDEX_MAX = String.fromCharCode(65535);
var INDEX_MIN = Number.MIN_SAFE_INTEGER;
function getQueryPlan(schema, query) {
  var selector = query.selector;
  var indexes = schema.indexes ? schema.indexes.slice(0) : [];
  if (query.index) {
    indexes = [query.index];
  }
  var hasDescSorting = !!query.sort.find((sortField) => Object.values(sortField)[0] === "desc");
  var sortIrrelevevantFields = /* @__PURE__ */ new Set();
  Object.keys(selector).forEach((fieldName) => {
    var schemaPart = getSchemaByObjectPath(schema, fieldName);
    if (schemaPart && schemaPart.type === "boolean" && Object.prototype.hasOwnProperty.call(selector[fieldName], "$eq")) {
      sortIrrelevevantFields.add(fieldName);
    }
  });
  var optimalSortIndex = query.sort.map((sortField) => Object.keys(sortField)[0]);
  var optimalSortIndexCompareString = optimalSortIndex.filter((f2) => !sortIrrelevevantFields.has(f2)).join(",");
  var currentBestQuality = -1;
  var currentBestQueryPlan;
  indexes.forEach((index) => {
    var inclusiveEnd = true;
    var inclusiveStart = true;
    var opts = index.map((indexField) => {
      var matcher = selector[indexField];
      var operators = matcher ? Object.keys(matcher) : [];
      var matcherOpts = {};
      if (!matcher || !operators.length) {
        var startKey = inclusiveStart ? INDEX_MIN : INDEX_MAX;
        matcherOpts = {
          startKey,
          endKey: inclusiveEnd ? INDEX_MAX : INDEX_MIN,
          inclusiveStart: true,
          inclusiveEnd: true
        };
      } else {
        operators.forEach((operator) => {
          if (LOGICAL_OPERATORS.has(operator)) {
            var operatorValue = matcher[operator];
            var partialOpts = getMatcherQueryOpts(operator, operatorValue);
            matcherOpts = Object.assign(matcherOpts, partialOpts);
          }
        });
      }
      if (typeof matcherOpts.startKey === "undefined") {
        matcherOpts.startKey = INDEX_MIN;
      }
      if (typeof matcherOpts.endKey === "undefined") {
        matcherOpts.endKey = INDEX_MAX;
      }
      if (typeof matcherOpts.inclusiveStart === "undefined") {
        matcherOpts.inclusiveStart = true;
      }
      if (typeof matcherOpts.inclusiveEnd === "undefined") {
        matcherOpts.inclusiveEnd = true;
      }
      if (inclusiveStart && !matcherOpts.inclusiveStart) {
        inclusiveStart = false;
      }
      if (inclusiveEnd && !matcherOpts.inclusiveEnd) {
        inclusiveEnd = false;
      }
      return matcherOpts;
    });
    var startKeys = opts.map((opt) => opt.startKey);
    var endKeys = opts.map((opt) => opt.endKey);
    var queryPlan = {
      index,
      startKeys,
      endKeys,
      inclusiveEnd,
      inclusiveStart,
      sortSatisfiedByIndex: !hasDescSorting && optimalSortIndexCompareString === index.filter((f2) => !sortIrrelevevantFields.has(f2)).join(","),
      selectorSatisfiedByIndex: isSelectorSatisfiedByIndex(index, query.selector, startKeys, endKeys)
    };
    var quality = rateQueryPlan(schema, query, queryPlan);
    if (quality >= currentBestQuality || query.index) {
      currentBestQuality = quality;
      currentBestQueryPlan = queryPlan;
    }
  });
  if (!currentBestQueryPlan) {
    throw newRxError("SNH", {
      query
    });
  }
  return currentBestQueryPlan;
}
var LOGICAL_OPERATORS = /* @__PURE__ */ new Set(["$eq", "$gt", "$gte", "$lt", "$lte"]);
var LOWER_BOUND_LOGICAL_OPERATORS = /* @__PURE__ */ new Set(["$eq", "$gt", "$gte"]);
var UPPER_BOUND_LOGICAL_OPERATORS = /* @__PURE__ */ new Set(["$eq", "$lt", "$lte"]);
function isSelectorSatisfiedByIndex(index, selector, startKeys, endKeys) {
  var selectorEntries = Object.entries(selector);
  var hasNonMatchingOperator = selectorEntries.find(([fieldName2, operation2]) => {
    if (!index.includes(fieldName2)) {
      return true;
    }
    var hasNonLogicOperator = Object.entries(operation2).find(([op, _value]) => !LOGICAL_OPERATORS.has(op));
    return hasNonLogicOperator;
  });
  if (hasNonMatchingOperator) {
    return false;
  }
  if (selector.$and || selector.$or) {
    return false;
  }
  var satisfieldLowerBound = [];
  var lowerOperatorFieldNames = /* @__PURE__ */ new Set();
  for (var [fieldName, operation] of Object.entries(selector)) {
    if (!index.includes(fieldName)) {
      return false;
    }
    var lowerLogicOps = Object.keys(operation).filter((key) => LOWER_BOUND_LOGICAL_OPERATORS.has(key));
    if (lowerLogicOps.length > 1) {
      return false;
    }
    var hasLowerLogicOp = lowerLogicOps[0];
    if (hasLowerLogicOp) {
      lowerOperatorFieldNames.add(fieldName);
    }
    if (hasLowerLogicOp !== "$eq") {
      if (satisfieldLowerBound.length > 0) {
        return false;
      } else {
        satisfieldLowerBound.push(hasLowerLogicOp);
      }
    }
  }
  var satisfieldUpperBound = [];
  var upperOperatorFieldNames = /* @__PURE__ */ new Set();
  for (var [_fieldName, _operation] of Object.entries(selector)) {
    if (!index.includes(_fieldName)) {
      return false;
    }
    var upperLogicOps = Object.keys(_operation).filter((key) => UPPER_BOUND_LOGICAL_OPERATORS.has(key));
    if (upperLogicOps.length > 1) {
      return false;
    }
    var hasUperLogicOp = upperLogicOps[0];
    if (hasUperLogicOp) {
      upperOperatorFieldNames.add(_fieldName);
    }
    if (hasUperLogicOp !== "$eq") {
      if (satisfieldUpperBound.length > 0) {
        return false;
      } else {
        satisfieldUpperBound.push(hasUperLogicOp);
      }
    }
  }
  var i = 0;
  for (var _fieldName2 of index) {
    for (var set of [lowerOperatorFieldNames, upperOperatorFieldNames]) {
      if (!set.has(_fieldName2) && set.size > 0) {
        return false;
      }
      set.delete(_fieldName2);
    }
    var startKey = startKeys[i];
    var endKey = endKeys[i];
    if (startKey !== endKey && lowerOperatorFieldNames.size > 0 && upperOperatorFieldNames.size > 0) {
      return false;
    }
    i++;
  }
  return true;
}
function getMatcherQueryOpts(operator, operatorValue) {
  switch (operator) {
    case "$eq":
      return {
        startKey: operatorValue,
        endKey: operatorValue,
        inclusiveEnd: true,
        inclusiveStart: true
      };
    case "$lte":
      return {
        endKey: operatorValue,
        inclusiveEnd: true
      };
    case "$gte":
      return {
        startKey: operatorValue,
        inclusiveStart: true
      };
    case "$lt":
      return {
        endKey: operatorValue,
        inclusiveEnd: false
      };
    case "$gt":
      return {
        startKey: operatorValue,
        inclusiveStart: false
      };
    default:
      throw new Error("SNH");
  }
}
function rateQueryPlan(schema, query, queryPlan) {
  var quality = 0;
  var addQuality = (value) => {
    if (value > 0) {
      quality = quality + value;
    }
  };
  var pointsPerMatchingKey = 10;
  var nonMinKeyCount = countUntilNotMatching(queryPlan.startKeys, (keyValue) => keyValue !== INDEX_MIN && keyValue !== INDEX_MAX);
  addQuality(nonMinKeyCount * pointsPerMatchingKey);
  var nonMaxKeyCount = countUntilNotMatching(queryPlan.startKeys, (keyValue) => keyValue !== INDEX_MAX && keyValue !== INDEX_MIN);
  addQuality(nonMaxKeyCount * pointsPerMatchingKey);
  var equalKeyCount = countUntilNotMatching(queryPlan.startKeys, (keyValue, idx) => {
    if (keyValue === queryPlan.endKeys[idx]) {
      return true;
    } else {
      return false;
    }
  });
  addQuality(equalKeyCount * pointsPerMatchingKey * 1.5);
  var pointsIfNoReSortMustBeDone = queryPlan.sortSatisfiedByIndex ? 5 : 0;
  addQuality(pointsIfNoReSortMustBeDone);
  return quality;
}
const MAX_INT = 2147483647;
const MIN_INT = -2147483648;
const MAX_LONG = Number.MAX_SAFE_INTEGER;
const MIN_LONG = Number.MIN_SAFE_INTEGER;
const MISSING = Symbol("missing");
const CYCLE_FOUND_ERROR = Object.freeze(new Error("mingo: cycle detected while processing object/array"));
const ARRAY_PROTO = Object.getPrototypeOf([]);
const OBJECT_PROTO = Object.getPrototypeOf({});
const OBJECT_TAG = "[object Object]";
const OBJECT_TYPE_RE = /^\[object ([a-zA-Z0-9]+)\]$/;
class Null {
}
class Undefined {
}
const getConstructor = (v2) => {
  if (v2 === null)
    return Null;
  if (v2 === void 0)
    return Undefined;
  return v2.constructor;
};
const DEFAULT_HASH_FUNCTION = (value) => {
  const s = stringify$1(value);
  let hash2 = 0;
  let i = s.length;
  while (i)
    hash2 = (hash2 << 5) - hash2 ^ s.charCodeAt(--i);
  return hash2 >>> 0;
};
const JS_SIMPLE_TYPES = /* @__PURE__ */ new Set([
  "null",
  "undefined",
  "boolean",
  "number",
  "string",
  "date",
  "regexp"
]);
const IMMUTABLE_TYPES_SET = /* @__PURE__ */ new Set([Undefined, Null, Boolean, String, Number]);
const toString = (v2) => v2.toString();
const typedArrayToString = (v2) => `${getConstructor(v2).name}[${v2.toString()}]`;
const STRING_CONVERTERS = /* @__PURE__ */ new Map([
  [Number, toString],
  [Boolean, toString],
  [RegExp, toString],
  [Function, toString],
  [Symbol, toString],
  [Date, (d) => d.toISOString()],
  [String, JSON.stringify],
  [Null, (_2) => "null"],
  [Undefined, (_2) => "undefined"],
  [Int8Array, typedArrayToString],
  [Uint8Array, typedArrayToString],
  [Uint8ClampedArray, typedArrayToString],
  [Int16Array, typedArrayToString],
  [Uint16Array, typedArrayToString],
  [Int32Array, typedArrayToString],
  [Uint32Array, typedArrayToString],
  [Float32Array, typedArrayToString],
  [Float64Array, typedArrayToString]
]);
if (typeof BigInt !== "undefined") {
  STRING_CONVERTERS.set(BigInt, (n2) => "0x" + n2.toString(16));
}
if (typeof BigInt64Array !== "undefined") {
  STRING_CONVERTERS.set(BigInt64Array, typedArrayToString);
}
if (typeof BigUint64Array !== "undefined") {
  STRING_CONVERTERS.set(BigUint64Array, typedArrayToString);
}
const SORT_ORDER_BY_TYPE = {
  null: 0,
  undefined: 0,
  number: 1,
  string: 2,
  object: 3,
  array: 4,
  boolean: 5,
  date: 6,
  regexp: 7,
  function: 8
};
const compare$1 = (a, b2) => {
  if (a === MISSING)
    a = void 0;
  if (b2 === MISSING)
    b2 = void 0;
  const [u2, v2] = [a, b2].map((n2) => SORT_ORDER_BY_TYPE[getType(n2).toLowerCase()]);
  if (u2 !== v2)
    return u2 - v2;
  if (u2 === 1 || u2 === 2 || u2 === 6) {
    if (a < b2)
      return -1;
    if (a > b2)
      return 1;
    return 0;
  }
  if (isEqual(a, b2))
    return 0;
  if (a < b2)
    return -1;
  if (a > b2)
    return 1;
  return 0;
};
function assert(condition, message) {
  if (!condition)
    throw new Error(message);
}
const isTypedArray = (v2) => {
  const proto = Object.getPrototypeOf(getConstructor(v2));
  return proto && proto.name === "TypedArray";
};
const cloneDeep = (obj) => {
  if (IMMUTABLE_TYPES_SET.has(getConstructor(obj)))
    return obj;
  const cycle = /* @__PURE__ */ new Set();
  const clone2 = (val) => {
    if (cycle.has(val))
      throw CYCLE_FOUND_ERROR;
    const ctor = getConstructor(val);
    if (IMMUTABLE_TYPES_SET.has(ctor))
      return val;
    try {
      if (isArray(val)) {
        cycle.add(val);
        return val.map(clone2);
      }
      if (isObject$1(val)) {
        cycle.add(val);
        const res = {};
        for (const k2 in val)
          res[k2] = clone2(val[k2]);
        return res;
      }
    } finally {
      cycle.delete(val);
    }
    if (ctor === Date || ctor === RegExp || isTypedArray(val)) {
      return new ctor(val);
    }
    return val;
  };
  return clone2(obj);
};
const getType = (v2) => OBJECT_TYPE_RE.exec(Object.prototype.toString.call(v2))[1];
const isBoolean = (v2) => typeof v2 === "boolean";
const isString = (v2) => typeof v2 === "string";
const isNumber = (v2) => !isNaN(v2) && typeof v2 === "number";
const isArray = Array.isArray;
const isObject$1 = (v2) => {
  if (!v2)
    return false;
  const proto = Object.getPrototypeOf(v2);
  return (proto === OBJECT_PROTO || proto === null) && OBJECT_TAG === Object.prototype.toString.call(v2);
};
const isObjectLike = (v2) => v2 === Object(v2);
const isDate = (v2) => v2 instanceof Date;
const isRegExp = (v2) => v2 instanceof RegExp;
const isFunction = (v2) => typeof v2 === "function";
const isNil = (v2) => v2 === null || v2 === void 0;
const inArray = (arr, item) => arr.includes(item);
const notInArray = (arr, item) => !inArray(arr, item);
const truthy = (arg, strict = true) => !!arg || strict && arg === "";
const isEmpty = (x2) => isNil(x2) || isString(x2) && !x2 || x2 instanceof Array && x2.length === 0 || isObject$1(x2) && Object.keys(x2).length === 0;
const isMissing = (v2) => v2 === MISSING;
const ensureArray = (x2) => x2 instanceof Array ? x2 : [x2];
const has = (obj, prop) => !!obj && Object.prototype.hasOwnProperty.call(obj, prop);
const mergeable = (left, right) => isObject$1(left) && isObject$1(right) || isArray(left) && isArray(right);
function merge$1(target, obj, options) {
  options = options || { flatten: false };
  if (isMissing(target) || isNil(target))
    return obj;
  if (isMissing(obj) || isNil(obj))
    return target;
  if (!mergeable(target, obj)) {
    if (options.skipValidation)
      return obj || target;
    throw Error("mismatched types. must both be array or object");
  }
  options.skipValidation = true;
  if (isArray(target)) {
    const result = target;
    const input = obj;
    if (options.flatten) {
      let i = 0;
      let j2 = 0;
      while (i < result.length && j2 < input.length) {
        result[i] = merge$1(result[i++], input[j2++], options);
      }
      while (j2 < input.length) {
        result.push(obj[j2++]);
      }
    } else {
      into(result, input);
    }
  } else {
    for (const k2 in obj) {
      target[k2] = merge$1(target[k2], obj[k2], options);
    }
  }
  return target;
}
function buildHashIndex(arr, hashFunction = DEFAULT_HASH_FUNCTION) {
  const map2 = /* @__PURE__ */ new Map();
  arr.forEach((o, i) => {
    const h2 = hashCode(o, hashFunction);
    if (map2.has(h2)) {
      if (!map2.get(h2).some((j2) => isEqual(arr[j2], o))) {
        map2.get(h2).push(i);
      }
    } else {
      map2.set(h2, [i]);
    }
  });
  return map2;
}
function intersection(input, hashFunction = DEFAULT_HASH_FUNCTION) {
  if (input.some((arr) => arr.length == 0))
    return [];
  if (input.length === 1)
    return Array.from(input);
  const sortedIndex = sortBy(input.map((a, i) => [i, a.length]), (a) => a[1]);
  const smallest = input[sortedIndex[0][0]];
  const map2 = buildHashIndex(smallest, hashFunction);
  const rmap = /* @__PURE__ */ new Map();
  const results = new Array();
  map2.forEach((v2, k2) => {
    const lhs = v2.map((j2) => smallest[j2]);
    const res = lhs.map((_2) => 0);
    const stable = lhs.map((_2) => [sortedIndex[0][0], 0]);
    let found = false;
    for (let i = 1; i < input.length; i++) {
      const [currIndex, _2] = sortedIndex[i];
      const arr = input[currIndex];
      if (!rmap.has(i))
        rmap.set(i, buildHashIndex(arr));
      if (rmap.get(i).has(k2)) {
        const rhs = rmap.get(i).get(k2).map((j2) => arr[j2]);
        found = lhs.map((s, n2) => rhs.some((t2, m2) => {
          const p2 = res[n2];
          if (isEqual(s, t2)) {
            res[n2]++;
            if (currIndex < stable[n2][0]) {
              stable[n2] = [currIndex, rmap.get(i).get(k2)[m2]];
            }
          }
          return p2 < res[n2];
        })).some(Boolean);
      }
      if (!found)
        return;
    }
    if (found) {
      into(results, res.map((n2, i) => {
        return n2 === input.length - 1 ? [lhs[i], stable[i]] : MISSING;
      }).filter((n2) => n2 !== MISSING));
    }
  });
  return results.sort((a, b2) => {
    const [_i, [u2, m2]] = a;
    const [_j, [v2, n2]] = b2;
    const r2 = compare$1(u2, v2);
    if (r2 !== 0)
      return r2;
    return compare$1(m2, n2);
  }).map((v2) => v2[0]);
}
function flatten(xs, depth = 0) {
  const arr = new Array();
  function flatten2(ys, n2) {
    for (let i = 0, len = ys.length; i < len; i++) {
      if (isArray(ys[i]) && (n2 > 0 || n2 < 0)) {
        flatten2(ys[i], Math.max(-1, n2 - 1));
      } else {
        arr.push(ys[i]);
      }
    }
  }
  flatten2(xs, depth);
  return arr;
}
const getMembersOf = (value) => {
  let [proto, names] = [
    Object.getPrototypeOf(value),
    Object.getOwnPropertyNames(value)
  ];
  let activeProto = proto;
  while (!names.length && proto !== OBJECT_PROTO && proto !== ARRAY_PROTO) {
    activeProto = proto;
    names = Object.getOwnPropertyNames(proto);
    proto = Object.getPrototypeOf(proto);
  }
  const o = {};
  names.forEach((k2) => o[k2] = value[k2]);
  return [o, activeProto];
};
function isEqual(a, b2) {
  const args2 = [[a, b2]];
  while (args2.length > 0) {
    [a, b2] = args2.pop();
    if (a === b2)
      continue;
    const ctor = getConstructor(a);
    if (ctor !== getConstructor(b2) || isFunction(a))
      return false;
    if (STRING_CONVERTERS.has(ctor)) {
      const str = STRING_CONVERTERS.get(ctor);
      if (str(a) !== str(b2))
        return false;
      continue;
    }
    if (ctor === Array || ctor === Object) {
      const ka2 = Object.keys(a);
      const kb2 = Object.keys(b2);
      if (ka2.length !== kb2.length)
        return false;
      if (new Set(ka2.concat(kb2)).size != ka2.length)
        return false;
      for (const k2 of ka2)
        args2.push([a[k2], b2[k2]]);
      continue;
    }
    return false;
  }
  return !args2.length;
}
function stringify$1(value) {
  const cycle = /* @__PURE__ */ new Set();
  const str = (v2) => {
    const ctor = getConstructor(v2);
    if (STRING_CONVERTERS.has(ctor)) {
      return STRING_CONVERTERS.get(ctor)(v2);
    }
    const tag = ctor === Object ? "" : ctor.name;
    if (isFunction(v2["toJSON"])) {
      return `${tag}(${JSON.stringify(v2)})`;
    }
    if (cycle.has(v2))
      throw CYCLE_FOUND_ERROR;
    cycle.add(v2);
    try {
      if (ctor === Array) {
        return "[" + v2.map(str).join(",") + "]";
      }
      if (ctor !== Object) {
        const [members, _2] = getMembersOf(v2);
        if (isArray(v2)) {
          return `${tag}${str([...v2, members])}`;
        }
        v2 = members;
      }
      const objKeys = Object.keys(v2);
      objKeys.sort();
      return `${tag}{` + objKeys.map((k2) => `${k2}:${str(v2[k2])}`).join(",") + "}";
    } finally {
      cycle.delete(v2);
    }
  };
  return str(value);
}
function hashCode(value, hashFunction) {
  hashFunction = hashFunction || DEFAULT_HASH_FUNCTION;
  if (isNil(value))
    return null;
  return hashFunction(value).toString();
}
function sortBy(collection, keyFn, comparator = compare$1) {
  if (isEmpty(collection))
    return collection;
  const sorted = new Array();
  const result = new Array();
  for (let i = 0; i < collection.length; i++) {
    const obj = collection[i];
    const key = keyFn(obj, i);
    if (isNil(key)) {
      result.push(obj);
    } else {
      sorted.push([key, obj]);
    }
  }
  sorted.sort((a, b2) => comparator(a[0], b2[0]));
  return into(result, sorted.map((o) => o[1]));
}
function groupBy(collection, keyFn, hashFunction = DEFAULT_HASH_FUNCTION) {
  if (collection.length < 1)
    return /* @__PURE__ */ new Map();
  const lookup = /* @__PURE__ */ new Map();
  const result = /* @__PURE__ */ new Map();
  for (let i = 0; i < collection.length; i++) {
    const obj = collection[i];
    const key = keyFn(obj, i);
    const hash2 = hashCode(key, hashFunction);
    if (hash2 === null) {
      if (result.has(null)) {
        result.get(null).push(obj);
      } else {
        result.set(null, [obj]);
      }
    } else {
      const existingKey = lookup.has(hash2) ? lookup.get(hash2).find((k2) => isEqual(k2, key)) : null;
      if (isNil(existingKey)) {
        result.set(key, [obj]);
        if (lookup.has(hash2)) {
          lookup.get(hash2).push(key);
        } else {
          lookup.set(hash2, [key]);
        }
      } else {
        result.get(existingKey).push(obj);
      }
    }
  }
  return result;
}
const MAX_ARRAY_PUSH = 5e4;
function into(target, ...rest) {
  if (target instanceof Array) {
    return rest.reduce((acc, arr) => {
      let i = Math.ceil(arr.length / MAX_ARRAY_PUSH);
      let begin = 0;
      while (i-- > 0) {
        Array.prototype.push.apply(acc, arr.slice(begin, begin + MAX_ARRAY_PUSH));
        begin += MAX_ARRAY_PUSH;
      }
      return acc;
    }, target);
  } else {
    return rest.filter(isObjectLike).reduce((acc, item) => {
      Object.assign(acc, item);
      return acc;
    }, target);
  }
}
function getValue(obj, key) {
  return isObjectLike(obj) ? obj[key] : void 0;
}
function unwrap(arr, depth) {
  if (depth < 1)
    return arr;
  while (depth-- && arr.length === 1)
    arr = arr[0];
  return arr;
}
function resolve(obj, selector, options) {
  let depth = 0;
  function resolve2(o, path) {
    let value = o;
    for (let i = 0; i < path.length; i++) {
      const field = path[i];
      const isText = /^\d+$/.exec(field) === null;
      if (isText && value instanceof Array) {
        if (i === 0 && depth > 0)
          break;
        depth += 1;
        const subpath = path.slice(i);
        value = value.reduce((acc, item) => {
          const v2 = resolve2(item, subpath);
          if (v2 !== void 0)
            acc.push(v2);
          return acc;
        }, []);
        break;
      } else {
        value = getValue(value, field);
      }
      if (value === void 0)
        break;
    }
    return value;
  }
  const result = JS_SIMPLE_TYPES.has(getType(obj).toLowerCase()) ? obj : resolve2(obj, selector.split("."));
  return result instanceof Array && (options === null || options === void 0 ? void 0 : options.unwrapArray) ? unwrap(result, depth) : result;
}
function resolveGraph(obj, selector, options) {
  const names = selector.split(".");
  const key = names[0];
  const next2 = names.slice(1).join(".");
  const isIndex = /^\d+$/.exec(key) !== null;
  const hasNext = names.length > 1;
  let result;
  let value;
  if (obj instanceof Array) {
    if (isIndex) {
      result = getValue(obj, Number(key));
      if (hasNext) {
        result = resolveGraph(result, next2, options);
      }
      result = [result];
    } else {
      result = [];
      for (const item of obj) {
        value = resolveGraph(item, selector, options);
        if (options === null || options === void 0 ? void 0 : options.preserveMissing) {
          if (value === void 0) {
            value = MISSING;
          }
          result.push(value);
        } else if (value !== void 0) {
          result.push(value);
        }
      }
    }
  } else {
    value = getValue(obj, key);
    if (hasNext) {
      value = resolveGraph(value, next2, options);
    }
    if (value === void 0)
      return void 0;
    result = (options === null || options === void 0 ? void 0 : options.preserveKeys) ? Object.assign({}, obj) : {};
    result[key] = value;
  }
  return result;
}
function filterMissing(obj) {
  if (obj instanceof Array) {
    for (let i = obj.length - 1; i >= 0; i--) {
      if (obj[i] === MISSING) {
        obj.splice(i, 1);
      } else {
        filterMissing(obj[i]);
      }
    }
  } else if (isObject$1(obj)) {
    for (const k2 in obj) {
      if (has(obj, k2)) {
        filterMissing(obj[k2]);
      }
    }
  }
}
const NUMBER_RE = /^\d+$/;
function walk(obj, selector, fn, options) {
  const names = selector.split(".");
  const key = names[0];
  const next2 = names.slice(1).join(".");
  if (names.length === 1) {
    if (isObject$1(obj) || isArray(obj) && NUMBER_RE.test(key)) {
      fn(obj, key);
    }
  } else {
    if ((options === null || options === void 0 ? void 0 : options.buildGraph) && isNil(obj[key])) {
      obj[key] = {};
    }
    const item = obj[key];
    if (!item)
      return;
    const isNextArrayIndex = !!(names.length > 1 && NUMBER_RE.test(names[1]));
    if (item instanceof Array && (options === null || options === void 0 ? void 0 : options.descendArray) && !isNextArrayIndex) {
      item.forEach((e2) => walk(e2, next2, fn, options));
    } else {
      walk(item, next2, fn, options);
    }
  }
}
function setValue(obj, selector, value) {
  walk(obj, selector, (item, key) => {
    item[key] = isFunction(value) ? value(item[key]) : value;
  }, { buildGraph: true });
}
function removeValue(obj, selector, options) {
  walk(obj, selector, (item, key) => {
    if (item instanceof Array) {
      if (/^\d+$/.test(key)) {
        item.splice(parseInt(key), 1);
      } else if (options && options.descendArray) {
        for (const elem of item) {
          if (isObject$1(elem)) {
            delete elem[key];
          }
        }
      }
    } else if (isObject$1(item)) {
      delete item[key];
    }
  }, options);
}
const OPERATOR_NAME_PATTERN = /^\$[a-zA-Z0-9_]+$/;
function isOperator(name) {
  return OPERATOR_NAME_PATTERN.test(name);
}
function normalize(expr) {
  if (JS_SIMPLE_TYPES.has(getType(expr).toLowerCase())) {
    return isRegExp(expr) ? { $regex: expr } : { $eq: expr };
  }
  if (isObjectLike(expr)) {
    const exprObj = expr;
    if (!Object.keys(exprObj).some(isOperator)) {
      return { $eq: expr };
    }
    if (has(expr, "$regex")) {
      const newExpr = Object.assign({}, expr);
      newExpr["$regex"] = new RegExp(expr["$regex"], expr["$options"]);
      delete newExpr["$options"];
      return newExpr;
    }
  }
  return expr;
}
var ProcessingMode;
(function(ProcessingMode2) {
  ProcessingMode2["CLONE_ALL"] = "CLONE_ALL";
  ProcessingMode2["CLONE_INPUT"] = "CLONE_INPUT";
  ProcessingMode2["CLONE_OUTPUT"] = "CLONE_OUTPUT";
  ProcessingMode2["CLONE_OFF"] = "CLONE_OFF";
})(ProcessingMode || (ProcessingMode = {}));
class ComputeOptions {
  constructor(_opts, _root2, _local, timestamp2 = Date.now()) {
    this._opts = _opts;
    this._root = _root2;
    this._local = _local;
    this.timestamp = timestamp2;
    this.update(_root2, _local);
  }
  /**
   * Initialize new ComputeOptions.
   *
   * @param options
   * @param root
   * @param local
   * @returns {ComputeOptions}
   */
  static init(options, root, local) {
    return options instanceof ComputeOptions ? new ComputeOptions(options._opts, isNil(options.root) ? root : options.root, Object.assign({}, options.local, local)) : new ComputeOptions(options, root, local);
  }
  /** Updates the internal mutable state. */
  update(root, local) {
    var _a;
    this._root = root;
    this._local = local ? Object.assign({}, local, {
      variables: Object.assign({}, (_a = this._local) === null || _a === void 0 ? void 0 : _a.variables, local === null || local === void 0 ? void 0 : local.variables)
    }) : local;
    return this;
  }
  getOptions() {
    return Object.freeze(Object.assign(Object.assign({}, this._opts), { context: Context$1.from(this._opts.context) }));
  }
  get root() {
    return this._root;
  }
  get local() {
    return this._local;
  }
  get idKey() {
    return this._opts.idKey;
  }
  get collation() {
    var _a;
    return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.collation;
  }
  get processingMode() {
    var _a;
    return ((_a = this._opts) === null || _a === void 0 ? void 0 : _a.processingMode) || ProcessingMode.CLONE_OFF;
  }
  get useStrictMode() {
    var _a;
    return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.useStrictMode;
  }
  get scriptEnabled() {
    var _a;
    return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.scriptEnabled;
  }
  get useGlobalContext() {
    var _a;
    return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.useGlobalContext;
  }
  get hashFunction() {
    var _a;
    return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.hashFunction;
  }
  get collectionResolver() {
    var _a;
    return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.collectionResolver;
  }
  get jsonSchemaValidator() {
    var _a;
    return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.jsonSchemaValidator;
  }
  get variables() {
    var _a;
    return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.variables;
  }
  get context() {
    var _a;
    return (_a = this._opts) === null || _a === void 0 ? void 0 : _a.context;
  }
}
function initOptions(options) {
  return options instanceof ComputeOptions ? options.getOptions() : Object.freeze(Object.assign(Object.assign({ idKey: "_id", scriptEnabled: true, useStrictMode: true, useGlobalContext: true, processingMode: ProcessingMode.CLONE_OFF }, options), { context: (options === null || options === void 0 ? void 0 : options.context) ? Context$1.from(options === null || options === void 0 ? void 0 : options.context) : Context$1.init({}) }));
}
var OperatorType;
(function(OperatorType2) {
  OperatorType2["ACCUMULATOR"] = "accumulator";
  OperatorType2["EXPRESSION"] = "expression";
  OperatorType2["PIPELINE"] = "pipeline";
  OperatorType2["PROJECTION"] = "projection";
  OperatorType2["QUERY"] = "query";
  OperatorType2["WINDOW"] = "window";
})(OperatorType || (OperatorType = {}));
let Context$1 = class Context {
  constructor(ops) {
    this.operators = {
      [OperatorType.ACCUMULATOR]: {},
      [OperatorType.EXPRESSION]: {},
      [OperatorType.PIPELINE]: {},
      [OperatorType.PROJECTION]: {},
      [OperatorType.QUERY]: {},
      [OperatorType.WINDOW]: {}
    };
    for (const [type2, operators] of Object.entries(ops)) {
      this.addOperators(type2, operators);
    }
  }
  static init(ops = {}) {
    return new Context(ops);
  }
  static from(ctx) {
    return new Context(ctx.operators);
  }
  addOperators(type2, ops) {
    for (const [name, fn] of Object.entries(ops)) {
      if (!this.getOperator(type2, name)) {
        this.operators[type2][name] = fn;
      }
    }
    return this;
  }
  // register
  addAccumulatorOps(ops) {
    return this.addOperators(OperatorType.ACCUMULATOR, ops);
  }
  addExpressionOps(ops) {
    return this.addOperators(OperatorType.EXPRESSION, ops);
  }
  addQueryOps(ops) {
    return this.addOperators(OperatorType.QUERY, ops);
  }
  addPipelineOps(ops) {
    return this.addOperators(OperatorType.PIPELINE, ops);
  }
  addProjectionOps(ops) {
    return this.addOperators(OperatorType.PROJECTION, ops);
  }
  addWindowOps(ops) {
    return this.addOperators(OperatorType.WINDOW, ops);
  }
  // getters
  getOperator(type2, name) {
    return type2 in this.operators ? this.operators[type2][name] || null : null;
  }
};
const GLOBAL_CONTEXT = Context$1.init();
function useOperators(type2, operators) {
  for (const [name, fn] of Object.entries(operators)) {
    assert(isFunction(fn) && isOperator(name), `'${name}' is not a valid operator`);
    const currentFn = getOperator(type2, name, null);
    assert(!currentFn || fn === currentFn, `${name} already exists for '${type2}' operators. Cannot change operator function once registered.`);
  }
  switch (type2) {
    case OperatorType.ACCUMULATOR:
      GLOBAL_CONTEXT.addAccumulatorOps(operators);
      break;
    case OperatorType.EXPRESSION:
      GLOBAL_CONTEXT.addExpressionOps(operators);
      break;
    case OperatorType.PIPELINE:
      GLOBAL_CONTEXT.addPipelineOps(operators);
      break;
    case OperatorType.PROJECTION:
      GLOBAL_CONTEXT.addProjectionOps(operators);
      break;
    case OperatorType.QUERY:
      GLOBAL_CONTEXT.addQueryOps(operators);
      break;
    case OperatorType.WINDOW:
      GLOBAL_CONTEXT.addWindowOps(operators);
      break;
  }
}
function getOperator(type2, operator, options) {
  const { context: ctx, useGlobalContext: fallback } = options || {};
  const fn = ctx ? ctx.getOperator(type2, operator) : null;
  return !fn && fallback ? GLOBAL_CONTEXT.getOperator(type2, operator) : fn;
}
const systemVariables = {
  $$ROOT(_obj, _expr, options) {
    return options.root;
  },
  $$CURRENT(obj, _expr, _options) {
    return obj;
  },
  $$REMOVE(_obj, _expr, _options) {
    return void 0;
  },
  $$NOW(_obj, _expr, options) {
    return new Date(options.timestamp);
  }
};
const redactVariables = {
  $$KEEP(obj, _expr, _options) {
    return obj;
  },
  $$PRUNE(_obj, _expr, _options) {
    return void 0;
  },
  $$DESCEND(obj, expr, options) {
    if (!has(expr, "$cond"))
      return obj;
    let result;
    for (const [key, current] of Object.entries(obj)) {
      if (isObjectLike(current)) {
        if (current instanceof Array) {
          const array = [];
          for (let elem of current) {
            if (isObject$1(elem)) {
              elem = redact(elem, expr, options.update(elem));
            }
            if (!isNil(elem)) {
              array.push(elem);
            }
          }
          result = array;
        } else {
          result = redact(current, expr, options.update(current));
        }
        if (isNil(result)) {
          delete obj[key];
        } else {
          obj[key] = result;
        }
      }
    }
    return obj;
  }
};
function computeValue(obj, expr, operator, options) {
  var _a;
  const copts = ComputeOptions.init(options, obj);
  operator = operator || "";
  if (isOperator(operator)) {
    const callExpression = getOperator(OperatorType.EXPRESSION, operator, options);
    if (callExpression)
      return callExpression(obj, expr, copts);
    const callAccumulator = getOperator(OperatorType.ACCUMULATOR, operator, options);
    if (callAccumulator) {
      if (!(obj instanceof Array)) {
        obj = computeValue(obj, expr, null, copts);
        expr = null;
      }
      assert(obj instanceof Array, `'${operator}' target must be an array.`);
      return callAccumulator(
        obj,
        expr,
        // reset the root object for accumulators.
        copts.update(null, copts.local)
      );
    }
    throw new Error(`operator '${operator}' is not registered`);
  }
  if (isString(expr) && expr.length > 0 && expr[0] === "$") {
    if (has(redactVariables, expr)) {
      return expr;
    }
    let context2 = copts.root;
    const arr = expr.split(".");
    if (has(systemVariables, arr[0])) {
      context2 = systemVariables[arr[0]](obj, null, copts);
      expr = expr.slice(arr[0].length + 1);
    } else if (arr[0].slice(0, 2) === "$$") {
      context2 = Object.assign(
        {},
        copts.variables,
        // global vars
        // current item is added before local variables because the binding may be changed.
        { this: obj },
        (_a = copts.local) === null || _a === void 0 ? void 0 : _a.variables
        // local vars
      );
      const prefix2 = arr[0].slice(2);
      assert(has(context2, prefix2), `Use of undefined variable: ${prefix2}`);
      expr = expr.slice(2);
    } else {
      expr = expr.slice(1);
    }
    if (expr === "")
      return context2;
    return resolve(context2, expr);
  }
  if (isArray(expr)) {
    return expr.map((item) => computeValue(obj, item, null, copts));
  } else if (isObject$1(expr)) {
    const result = {};
    for (const [key, val] of Object.entries(expr)) {
      result[key] = computeValue(obj, val, key, copts);
      if ([OperatorType.EXPRESSION, OperatorType.ACCUMULATOR].some((t2) => !!getOperator(t2, key, options))) {
        assert(Object.keys(expr).length === 1, "Invalid aggregation expression '" + JSON.stringify(expr) + "'");
        return result[key];
      }
    }
    return result;
  }
  return expr;
}
function redact(obj, expr, options) {
  const result = computeValue(obj, expr, null, options);
  return has(redactVariables, result) ? redactVariables[result](obj, expr, options) : result;
}
function Lazy(source) {
  return source instanceof Iterator ? source : new Iterator(source);
}
function compose(...iterators) {
  let index = 0;
  return Lazy(() => {
    while (index < iterators.length) {
      const o = iterators[index].next();
      if (!o.done)
        return o;
      index++;
    }
    return { done: true };
  });
}
function isGenerator(o) {
  return !!o && typeof o === "object" && (o === null || o === void 0 ? void 0 : o.next) instanceof Function;
}
function dropItem(array, i) {
  const rest = array.slice(i + 1);
  array.splice(i);
  Array.prototype.push.apply(array, rest);
}
const DONE = new Error();
var Action;
(function(Action2) {
  Action2[Action2["MAP"] = 0] = "MAP";
  Action2[Action2["FILTER"] = 1] = "FILTER";
  Action2[Action2["TAKE"] = 2] = "TAKE";
  Action2[Action2["DROP"] = 3] = "DROP";
})(Action || (Action = {}));
function createCallback(nextFn, iteratees, buffer2) {
  let done = false;
  let index = -1;
  let bufferIndex = 0;
  return function(storeResult) {
    try {
      outer:
        while (!done) {
          let o = nextFn();
          index++;
          let i = -1;
          const size = iteratees.length;
          let innerDone = false;
          while (++i < size) {
            const r2 = iteratees[i];
            switch (r2.action) {
              case Action.MAP:
                o = r2.func(o, index);
                break;
              case Action.FILTER:
                if (!r2.func(o, index))
                  continue outer;
                break;
              case Action.TAKE:
                --r2.count;
                if (!r2.count)
                  innerDone = true;
                break;
              case Action.DROP:
                --r2.count;
                if (!r2.count)
                  dropItem(iteratees, i);
                continue outer;
              default:
                break outer;
            }
          }
          done = innerDone;
          if (storeResult) {
            buffer2[bufferIndex++] = o;
          } else {
            return { value: o, done: false };
          }
        }
    } catch (e2) {
      if (e2 !== DONE)
        throw e2;
    }
    done = true;
    return { done };
  };
}
class Iterator {
  /**
   * @param {*} source An iterable object or function.
   *    Array - return one element per cycle
   *    Object{next:Function} - call next() for the next value (this also handles generator functions)
   *    Function - call to return the next value
   * @param {Function} fn An optional transformation function
   */
  constructor(source) {
    this.iteratees = [];
    this.yieldedValues = [];
    this.isDone = false;
    let nextVal;
    if (source instanceof Function) {
      source = { next: source };
    }
    if (isGenerator(source)) {
      const src = source;
      nextVal = () => {
        const o = src.next();
        if (o.done)
          throw DONE;
        return o.value;
      };
    } else if (source instanceof Array) {
      const data = source;
      const size = data.length;
      let index = 0;
      nextVal = () => {
        if (index < size)
          return data[index++];
        throw DONE;
      };
    } else if (!(source instanceof Function)) {
      throw new Error(`Lazy must be initialized with an array, generator, or function.`);
    }
    this.getNext = createCallback(nextVal, this.iteratees, this.yieldedValues);
  }
  /**
   * Add an iteratee to this lazy sequence
   */
  push(action, value) {
    if (typeof value === "function") {
      this.iteratees.push({ action, func: value });
    } else if (typeof value === "number") {
      this.iteratees.push({ action, count: value });
    }
    return this;
  }
  next() {
    return this.getNext();
  }
  // Iteratees methods
  /**
   * Transform each item in the sequence to a new value
   * @param {Function} f
   */
  map(f2) {
    return this.push(Action.MAP, f2);
  }
  /**
   * Select only items matching the given predicate
   * @param {Function} pred
   */
  filter(predicate) {
    return this.push(Action.FILTER, predicate);
  }
  /**
   * Take given numbe for values from sequence
   * @param {Number} n A number greater than 0
   */
  take(n2) {
    return n2 > 0 ? this.push(Action.TAKE, n2) : this;
  }
  /**
   * Drop a number of values from the sequence
   * @param {Number} n Number of items to drop greater than 0
   */
  drop(n2) {
    return n2 > 0 ? this.push(Action.DROP, n2) : this;
  }
  // Transformations
  /**
   * Returns a new lazy object with results of the transformation
   * The entire sequence is realized.
   *
   * @param {Callback<Source, RawArray>} fn Tranform function of type (Array) => (Any)
   */
  transform(fn) {
    const self2 = this;
    let iter;
    return Lazy(() => {
      if (!iter) {
        iter = Lazy(fn(self2.value()));
      }
      return iter.next();
    });
  }
  // Terminal methods
  /**
   * Returns the fully realized values of the iterators.
   * The return value will be an array unless `lazy.first()` was used.
   * The realized values are cached for subsequent calls.
   */
  value() {
    if (!this.isDone) {
      this.isDone = this.getNext(true).done;
    }
    return this.yieldedValues;
  }
  /**
   * Execute the funcion for each value. Will stop when an execution returns false.
   * @param {Function} f
   * @returns {Boolean} false iff `f` return false for AnyVal execution, otherwise true
   */
  each(f2) {
    for (; ; ) {
      const o = this.next();
      if (o.done)
        break;
      if (f2(o.value) === false)
        return false;
    }
    return true;
  }
  /**
   * Returns the reduction of sequence according the reducing function
   *
   * @param {*} f a reducing function
   * @param {*} initialValue
   */
  reduce(f2, initialValue) {
    let o = this.next();
    if (initialValue === void 0 && !o.done) {
      initialValue = o.value;
      o = this.next();
    }
    while (!o.done) {
      initialValue = f2(initialValue, o.value);
      o = this.next();
    }
    return initialValue;
  }
  /**
   * Returns the number of matched items in the sequence
   */
  size() {
    return this.reduce((acc, _2) => ++acc, 0);
  }
  [Symbol.iterator]() {
    return this;
  }
}
class Aggregator {
  constructor(pipeline, options) {
    this.pipeline = pipeline;
    this.options = initOptions(options);
  }
  /**
   * Returns an `Lazy` iterator for processing results of pipeline
   *
   * @param {*} collection An array or iterator object
   * @returns {Iterator} an iterator object
   */
  stream(collection) {
    let iterator2 = Lazy(collection);
    const mode = this.options.processingMode;
    if (mode == ProcessingMode.CLONE_ALL || mode == ProcessingMode.CLONE_INPUT) {
      iterator2.map(cloneDeep);
    }
    const pipelineOperators = new Array();
    if (!isEmpty(this.pipeline)) {
      for (const operator of this.pipeline) {
        const operatorKeys = Object.keys(operator);
        const opName = operatorKeys[0];
        const call = getOperator(OperatorType.PIPELINE, opName, this.options);
        assert(operatorKeys.length === 1 && !!call, `invalid pipeline operator ${opName}`);
        pipelineOperators.push(opName);
        iterator2 = call(iterator2, operator[opName], this.options);
      }
    }
    if (mode == ProcessingMode.CLONE_OUTPUT || mode == ProcessingMode.CLONE_ALL && !!intersection([["$group", "$unwind"], pipelineOperators]).length) {
      iterator2.map(cloneDeep);
    }
    return iterator2;
  }
  /**
   * Return the results of the aggregation as an array.
   *
   * @param {*} collection
   * @param {*} query
   */
  run(collection) {
    return this.stream(collection).value();
  }
}
class Cursor {
  constructor(source, predicate, projection, options) {
    this.source = source;
    this.predicate = predicate;
    this.projection = projection;
    this.options = options;
    this.operators = [];
    this.result = null;
    this.buffer = [];
  }
  /** Returns the iterator from running the query */
  fetch() {
    if (this.result)
      return this.result;
    if (isObject$1(this.projection)) {
      this.operators.push({ $project: this.projection });
    }
    this.result = Lazy(this.source).filter(this.predicate);
    if (this.operators.length > 0) {
      this.result = new Aggregator(this.operators, this.options).stream(this.result);
    }
    return this.result;
  }
  /** Returns an iterator with the buffered data included */
  fetchAll() {
    const buffered = Lazy([...this.buffer]);
    this.buffer = [];
    return compose(buffered, this.fetch());
  }
  /**
   * Return remaining objects in the cursor as an array. This method exhausts the cursor
   * @returns {Array}
   */
  all() {
    return this.fetchAll().value();
  }
  /**
   * Returns the number of objects return in the cursor. This method exhausts the cursor
   * @returns {Number}
   */
  count() {
    return this.all().length;
  }
  /**
   * Returns a cursor that begins returning results only after passing or skipping a number of documents.
   * @param {Number} n the number of results to skip.
   * @return {Cursor} Returns the cursor, so you can chain this call.
   */
  skip(n2) {
    this.operators.push({ $skip: n2 });
    return this;
  }
  /**
   * Constrains the size of a cursor's result set.
   * @param {Number} n the number of results to limit to.
   * @return {Cursor} Returns the cursor, so you can chain this call.
   */
  limit(n2) {
    this.operators.push({ $limit: n2 });
    return this;
  }
  /**
   * Returns results ordered according to a sort specification.
   * @param {Object} modifier an object of key and values specifying the sort order. 1 for ascending and -1 for descending
   * @return {Cursor} Returns the cursor, so you can chain this call.
   */
  sort(modifier) {
    this.operators.push({ $sort: modifier });
    return this;
  }
  /**
   * Specifies the collation for the cursor returned by the `mingo.Query.find`
   * @param {*} spec
   */
  collation(spec) {
    this.options = Object.assign(Object.assign({}, this.options), { collation: spec });
    return this;
  }
  /**
   * Returns the next document in a cursor.
   * @returns {Object | Boolean}
   */
  next() {
    if (this.buffer.length > 0) {
      return this.buffer.pop();
    }
    const o = this.fetch().next();
    if (o.done)
      return;
    return o.value;
  }
  /**
   * Returns true if the cursor has documents and can be iterated.
   * @returns {boolean}
   */
  hasNext() {
    if (this.buffer.length > 0)
      return true;
    const o = this.fetch().next();
    if (o.done)
      return false;
    this.buffer.push(o.value);
    return true;
  }
  /**
   * Applies a function to each document in a cursor and collects the return values in an array.
   * @param fn
   * @returns {Array}
   */
  map(fn) {
    return this.all().map(fn);
  }
  /**
   * Applies a JavaScript function for every document in a cursor.
   * @param fn
   */
  forEach(fn) {
    this.all().forEach(fn);
  }
  [Symbol.iterator]() {
    return this.fetchAll();
  }
}
class Query {
  constructor(condition, options) {
    this.condition = condition;
    this.options = initOptions(options);
    this.compiled = [];
    this.compile();
  }
  compile() {
    assert(isObject$1(this.condition), `query criteria must be an object: ${JSON.stringify(this.condition)}`);
    const whereOperator = {};
    for (const [field, expr] of Object.entries(this.condition)) {
      if ("$where" === field) {
        Object.assign(whereOperator, { field, expr });
      } else if (inArray(["$and", "$or", "$nor", "$expr", "$jsonSchema"], field)) {
        this.processOperator(field, field, expr);
      } else {
        assert(!isOperator(field), `unknown top level operator: ${field}`);
        for (const [operator, val] of Object.entries(normalize(expr))) {
          this.processOperator(field, operator, val);
        }
      }
      if (whereOperator.field) {
        this.processOperator(whereOperator.field, whereOperator.field, whereOperator.expr);
      }
    }
  }
  processOperator(field, operator, value) {
    const call = getOperator(OperatorType.QUERY, operator, this.options);
    if (!call) {
      throw new Error(`unknown operator ${operator}`);
    }
    const fn = call(field, value, this.options);
    this.compiled.push(fn);
  }
  /**
   * Checks if the object passes the query criteria. Returns true if so, false otherwise.
   *
   * @param obj The object to test
   * @returns {boolean} True or false
   */
  test(obj) {
    for (let i = 0, len = this.compiled.length; i < len; i++) {
      if (!this.compiled[i](obj)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Returns a cursor to select matching documents from the input source.
   *
   * @param source A source providing a sequence of documents
   * @param projection An optional projection criteria
   * @returns {Cursor} A Cursor for iterating over the results
   */
  find(collection, projection) {
    return new Cursor(collection, (x2) => this.test(x2), projection || {}, this.options);
  }
  /**
   * Remove matched documents from the collection returning the remainder
   *
   * @param collection An array of documents
   * @returns {Array} A new array with matching elements removed
   */
  remove(collection) {
    return collection.reduce((acc, obj) => {
      if (!this.test(obj))
        acc.push(obj);
      return acc;
    }, []);
  }
}
const $sort = (collection, sortKeys, options) => {
  if (isEmpty(sortKeys) || !isObject$1(sortKeys))
    return collection;
  let cmp = compare$1;
  const collationSpec = options.collation;
  if (isObject$1(collationSpec) && isString(collationSpec.locale)) {
    cmp = collationComparator(collationSpec);
  }
  return collection.transform((coll) => {
    const modifiers = Object.keys(sortKeys);
    for (const key of modifiers.reverse()) {
      const groups = groupBy(coll, (obj) => resolve(obj, key), options.hashFunction);
      const sortedKeys = Array.from(groups.keys()).sort(cmp);
      if (sortKeys[key] === -1)
        sortedKeys.reverse();
      coll = [];
      sortedKeys.reduce((acc, key2) => into(acc, groups.get(key2)), coll);
    }
    return coll;
  });
};
const COLLATION_STRENGTH = {
  // Only strings that differ in base letters compare as unequal. Examples: a  b, a = , a = A.
  1: "base",
  //  Only strings that differ in base letters or accents and other diacritic marks compare as unequal.
  // Examples: a  b, a  , a = A.
  2: "accent",
  // Strings that differ in base letters, accents and other diacritic marks, or case compare as unequal.
  // Other differences may also be taken into consideration. Examples: a  b, a  , a  A
  3: "variant"
  // case - Only strings that differ in base letters or case compare as unequal. Examples: a  b, a = , a  A.
};
function collationComparator(spec) {
  const localeOpt = {
    sensitivity: COLLATION_STRENGTH[spec.strength || 3],
    caseFirst: spec.caseFirst === "off" ? "false" : spec.caseFirst || "false",
    numeric: spec.numericOrdering || false,
    ignorePunctuation: spec.alternate === "shifted"
  };
  if ((spec.caseLevel || false) === true) {
    if (localeOpt.sensitivity === "base")
      localeOpt.sensitivity = "case";
    if (localeOpt.sensitivity === "accent")
      localeOpt.sensitivity = "variant";
  }
  const collator = new Intl.Collator(spec.locale, localeOpt);
  return (a, b2) => {
    if (!isString(a) || !isString(b2))
      return compare$1(a, b2);
    const i = collator.compare(a, b2);
    if (i < 0)
      return -1;
    if (i > 0)
      return 1;
    return 0;
  };
}
function createQueryOperator(predicate) {
  const f2 = (selector, value, options) => {
    const opts = { unwrapArray: true };
    const depth = Math.max(1, selector.split(".").length - 1);
    return (obj) => {
      const lhs = resolve(obj, selector, opts);
      return predicate(lhs, value, Object.assign(Object.assign({}, options), { depth }));
    };
  };
  f2.op = "query";
  return f2;
}
function $eq$1(a, b2, options) {
  if (isEqual(a, b2))
    return true;
  if (isNil(a) && isNil(b2))
    return true;
  if (a instanceof Array) {
    const eq = isEqual.bind(null, b2);
    return a.some(eq) || flatten(a, options === null || options === void 0 ? void 0 : options.depth).some(eq);
  }
  return false;
}
function $ne$1(a, b2, options) {
  return !$eq$1(a, b2, options);
}
function $in$1(a, b2, options) {
  if (isNil(a))
    return b2.some((v2) => v2 === null);
  return intersection([ensureArray(a), b2], options === null || options === void 0 ? void 0 : options.hashFunction).length > 0;
}
function $nin$1(a, b2, options) {
  return !$in$1(a, b2, options);
}
function $lt$1(a, b2, options) {
  return compare(a, b2, (x2, y2) => compare$1(x2, y2) < 0);
}
function $lte$1(a, b2, options) {
  return compare(a, b2, (x2, y2) => compare$1(x2, y2) <= 0);
}
function $gt$1(a, b2, options) {
  return compare(a, b2, (x2, y2) => compare$1(x2, y2) > 0);
}
function $gte$1(a, b2, options) {
  return compare(a, b2, (x2, y2) => compare$1(x2, y2) >= 0);
}
function $mod$1(a, b2, options) {
  return ensureArray(a).some((x2) => b2.length === 2 && x2 % b2[0] === b2[1]);
}
function $regex$1(a, b2, options) {
  const lhs = ensureArray(a);
  const match2 = (x2) => isString(x2) && truthy(b2.exec(x2), options === null || options === void 0 ? void 0 : options.useStrictMode);
  return lhs.some(match2) || flatten(lhs, 1).some(match2);
}
function $exists$1(a, b2, options) {
  return (b2 === false || b2 === 0) && a === void 0 || (b2 === true || b2 === 1) && a !== void 0;
}
function $all(values, queries, options) {
  if (!isArray(values) || !isArray(queries) || !values.length || !queries.length) {
    return false;
  }
  let matched = true;
  for (const query of queries) {
    if (!matched)
      break;
    if (isObject$1(query) && inArray(Object.keys(query), "$elemMatch")) {
      matched = $elemMatch$1(values, query["$elemMatch"], options);
    } else if (query instanceof RegExp) {
      matched = values.some((s) => typeof s === "string" && query.test(s));
    } else {
      matched = values.some((v2) => isEqual(query, v2));
    }
  }
  return matched;
}
function $size$1(a, b2, options) {
  return Array.isArray(a) && a.length === b2;
}
function isNonBooleanOperator(name) {
  return isOperator(name) && ["$and", "$or", "$nor"].indexOf(name) === -1;
}
function $elemMatch$1(a, b2, options) {
  if (isArray(a) && !isEmpty(a)) {
    let format = (x2) => x2;
    let criteria = b2;
    if (Object.keys(b2).every(isNonBooleanOperator)) {
      criteria = { temp: b2 };
      format = (x2) => ({ temp: x2 });
    }
    const query = new Query(criteria, options);
    for (let i = 0, len = a.length; i < len; i++) {
      if (query.test(format(a[i]))) {
        return true;
      }
    }
  }
  return false;
}
const isNull = (a) => a === null;
const isInt = (a) => isNumber(a) && a >= MIN_INT && a <= MAX_INT && a.toString().indexOf(".") === -1;
const isLong = (a) => isNumber(a) && a >= MIN_LONG && a <= MAX_LONG && a.toString().indexOf(".") === -1;
const compareFuncs = {
  array: isArray,
  bool: isBoolean,
  boolean: isBoolean,
  date: isDate,
  decimal: isNumber,
  double: isNumber,
  int: isInt,
  long: isLong,
  number: isNumber,
  null: isNull,
  object: isObject$1,
  regex: isRegExp,
  regexp: isRegExp,
  string: isString,
  // added for completeness
  undefined: isNil,
  // deprecated
  function: (_2) => {
    throw new Error("unsupported type key `function`.");
  },
  // Mongo identifiers
  1: isNumber,
  //double
  2: isString,
  3: isObject$1,
  4: isArray,
  6: isNil,
  // deprecated
  8: isBoolean,
  9: isDate,
  10: isNull,
  11: isRegExp,
  16: isInt,
  18: isLong,
  19: isNumber
  //decimal
};
function compareType(a, b2, _2) {
  const f2 = compareFuncs[b2];
  return f2 ? f2(a) : false;
}
function $type$1(a, b2, options) {
  return Array.isArray(b2) ? b2.findIndex((t2) => compareType(a, t2)) >= 0 : compareType(a, b2);
}
function compare(a, b2, f2) {
  return ensureArray(a).some((x2) => getType(x2) === getType(b2) && f2(x2, b2));
}
const buildMap = (letters, sign) => {
  const h2 = {};
  letters.split("").forEach((v2, i) => h2[v2] = sign * (i + 1));
  return h2;
};
Object.assign(Object.assign(Object.assign({}, buildMap("ABCDEFGHIKLM", 1)), buildMap("NOPQRSTUVWXY", -1)), { Z: 0 });
const FIXED_POINTS = {
  undefined: null,
  null: null,
  NaN: NaN,
  Infinity: new Error(),
  "-Infinity": new Error()
};
function createTrignometryOperator(f2, fixedPoints = FIXED_POINTS) {
  const fp = Object.assign({}, FIXED_POINTS, fixedPoints);
  const keySet = new Set(Object.keys(fp));
  return (obj, expr, options) => {
    const n2 = computeValue(obj, expr, null, options);
    if (keySet.has(`${n2}`)) {
      const res = fp[`${n2}`];
      if (res instanceof Error) {
        throw new Error(`cannot apply $${f2.name} to -inf, value must in (-inf,inf)`);
      }
      return res;
    }
    return f2(n2);
  };
}
createTrignometryOperator(Math.acos, {
  Infinity: Infinity,
  0: new Error()
});
createTrignometryOperator(Math.acosh, {
  Infinity: Infinity,
  0: new Error()
});
createTrignometryOperator(Math.asin);
createTrignometryOperator(Math.asinh, {
  Infinity: Infinity,
  "-Infinity": -Infinity
});
createTrignometryOperator(Math.atan);
createTrignometryOperator(Math.atanh, {
  1: Infinity,
  "-1": -Infinity
});
createTrignometryOperator(Math.cos);
createTrignometryOperator(Math.cosh, {
  "-Infinity": Infinity,
  Infinity: Infinity
  // [Math.PI]: -1,
});
const RADIANS_FACTOR = Math.PI / 180;
createTrignometryOperator((n2) => n2 * RADIANS_FACTOR, {
  Infinity: Infinity,
  "-Infinity": Infinity
});
const DEGREES_FACTOR = 180 / Math.PI;
createTrignometryOperator((n2) => n2 * DEGREES_FACTOR, {
  Infinity: Infinity,
  "-Infinity": -Infinity
});
createTrignometryOperator(Math.sin);
createTrignometryOperator(Math.sinh, {
  "-Infinity": -Infinity,
  Infinity: Infinity
});
createTrignometryOperator(Math.tan);
const $project = (collection, expr, options) => {
  if (isEmpty(expr))
    return collection;
  let expressionKeys = Object.keys(expr);
  let idOnlyExcluded = false;
  validateExpression(expr, options);
  const ID_KEY = options.idKey;
  if (inArray(expressionKeys, ID_KEY)) {
    const id2 = expr[ID_KEY];
    if (id2 === 0 || id2 === false) {
      expressionKeys = expressionKeys.filter(notInArray.bind(null, [ID_KEY]));
      idOnlyExcluded = expressionKeys.length == 0;
    }
  } else {
    expressionKeys.push(ID_KEY);
  }
  const copts = ComputeOptions.init(options);
  return collection.map((obj) => processObject(obj, expr, copts.update(obj), expressionKeys, idOnlyExcluded));
};
function processObject(obj, expr, options, expressionKeys, idOnlyExcluded) {
  let newObj = {};
  let foundSlice = false;
  let foundExclusion = false;
  const dropKeys = [];
  if (idOnlyExcluded) {
    dropKeys.push(options.idKey);
  }
  for (const key of expressionKeys) {
    let value = void 0;
    const subExpr = expr[key];
    if (key !== options.idKey && inArray([0, false], subExpr)) {
      foundExclusion = true;
    }
    if (key === options.idKey && isEmpty(subExpr)) {
      value = obj[key];
    } else if (isString(subExpr)) {
      value = computeValue(obj, subExpr, key, options);
    } else if (inArray([1, true], subExpr))
      ;
    else if (subExpr instanceof Array) {
      value = subExpr.map((v2) => {
        const r2 = computeValue(obj, v2, null, options);
        if (isNil(r2))
          return null;
        return r2;
      });
    } else if (isObject$1(subExpr)) {
      const subExprObj = subExpr;
      const subExprKeys = Object.keys(subExpr);
      const operator = subExprKeys.length == 1 ? subExprKeys[0] : "";
      const call = getOperator(OperatorType.PROJECTION, operator, options);
      if (call) {
        if (operator === "$slice") {
          if (ensureArray(subExprObj[operator]).every(isNumber)) {
            value = call(obj, subExprObj[operator], key, options);
            foundSlice = true;
          } else {
            value = computeValue(obj, subExprObj, key, options);
          }
        } else {
          value = call(obj, subExprObj[operator], key, options);
        }
      } else if (isOperator(operator)) {
        value = computeValue(obj, subExprObj[operator], operator, options);
      } else if (has(obj, key)) {
        validateExpression(subExprObj, options);
        let target = obj[key];
        if (target instanceof Array) {
          value = target.map((o) => processObject(o, subExprObj, options, subExprKeys, false));
        } else {
          target = isObject$1(target) ? target : obj;
          value = processObject(target, subExprObj, options, subExprKeys, false);
        }
      } else {
        value = computeValue(obj, subExpr, null, options);
      }
    } else {
      dropKeys.push(key);
      continue;
    }
    const objPathGraph = resolveGraph(obj, key, {
      preserveMissing: true
    });
    if (objPathGraph !== void 0) {
      merge$1(newObj, objPathGraph, {
        flatten: true
      });
    }
    if (notInArray([0, 1, false, true], subExpr)) {
      if (value === void 0) {
        removeValue(newObj, key, { descendArray: true });
      } else {
        setValue(newObj, key, value);
      }
    }
  }
  filterMissing(newObj);
  if (foundSlice || foundExclusion || idOnlyExcluded) {
    newObj = into({}, obj, newObj);
    if (dropKeys.length > 0) {
      for (const k2 of dropKeys) {
        removeValue(newObj, k2, { descendArray: true });
      }
    }
  }
  return newObj;
}
function validateExpression(expr, options) {
  const check = [false, false];
  for (const [k2, v2] of Object.entries(expr)) {
    if (k2 === (options === null || options === void 0 ? void 0 : options.idKey))
      return;
    if (v2 === 0 || v2 === false) {
      check[0] = true;
    } else if (v2 === 1 || v2 === true) {
      check[1] = true;
    }
    assert(!(check[0] && check[1]), "Projection cannot have a mix of inclusion and exclusion.");
  }
}
const $and = (_2, rhs, options) => {
  assert(isArray(rhs), "Invalid expression: $and expects value to be an Array.");
  const queries = rhs.map((expr) => new Query(expr, options));
  return (obj) => queries.every((q2) => q2.test(obj));
};
const $or = (_2, rhs, options) => {
  assert(isArray(rhs), "Invalid expression. $or expects value to be an Array");
  const queries = rhs.map((expr) => new Query(expr, options));
  return (obj) => queries.some((q2) => q2.test(obj));
};
const $nor = (_2, rhs, options) => {
  assert(isArray(rhs), "Invalid expression. $nor expects value to be an array.");
  const f2 = $or("$or", rhs, options);
  return (obj) => !f2(obj);
};
const $not = (selector, rhs, options) => {
  const criteria = {};
  criteria[selector] = normalize(rhs);
  const query = new Query(criteria, options);
  return (obj) => !query.test(obj);
};
const $eq = createQueryOperator($eq$1);
const $gt = createQueryOperator($gt$1);
const $gte = createQueryOperator($gte$1);
const $in = createQueryOperator($in$1);
const $lt = createQueryOperator($lt$1);
const $lte = createQueryOperator($lte$1);
const $ne = createQueryOperator($ne$1);
const $nin = createQueryOperator($nin$1);
const $mod = createQueryOperator($mod$1);
const $regex = createQueryOperator($regex$1);
createQueryOperator($all);
const $elemMatch = createQueryOperator($elemMatch$1);
const $size = createQueryOperator($size$1);
const $exists = createQueryOperator($exists$1);
const $type = createQueryOperator($type$1);
var mingoInitDone = false;
function getMingoQuery(selector) {
  if (!mingoInitDone) {
    useOperators(OperatorType.PIPELINE, {
      $sort,
      $project
    });
    useOperators(OperatorType.QUERY, {
      $and,
      $eq,
      $elemMatch,
      $exists,
      $gt,
      $gte,
      $in,
      $lt,
      $lte,
      $ne,
      $nin,
      $mod,
      $nor,
      $not,
      $or,
      $regex,
      $size,
      $type
    });
    mingoInitDone = true;
  }
  return new Query(selector);
}
function normalizeMangoQuery(schema, mangoQuery) {
  var primaryKey = getPrimaryFieldOfPrimaryKey(schema.primaryKey);
  mangoQuery = flatClone(mangoQuery);
  var normalizedMangoQuery = clone(mangoQuery);
  if (typeof normalizedMangoQuery.skip !== "number") {
    normalizedMangoQuery.skip = 0;
  }
  if (!normalizedMangoQuery.selector) {
    normalizedMangoQuery.selector = {};
  } else {
    normalizedMangoQuery.selector = normalizedMangoQuery.selector;
    Object.entries(normalizedMangoQuery.selector).forEach(([field, matcher]) => {
      if (typeof matcher !== "object" || matcher === null) {
        normalizedMangoQuery.selector[field] = {
          $eq: matcher
        };
      }
    });
  }
  if (normalizedMangoQuery.index) {
    var indexAr = toArray$2(normalizedMangoQuery.index);
    if (!indexAr.includes(primaryKey)) {
      indexAr.push(primaryKey);
    }
    normalizedMangoQuery.index = indexAr;
  }
  if (!normalizedMangoQuery.sort) {
    if (normalizedMangoQuery.index) {
      normalizedMangoQuery.sort = normalizedMangoQuery.index.map((field) => {
        return {
          [field]: "asc"
        };
      });
    } else {
      if (schema.indexes) {
        var fieldsWithLogicalOperator = /* @__PURE__ */ new Set();
        Object.entries(normalizedMangoQuery.selector).forEach(([field, matcher]) => {
          var hasLogical = false;
          if (typeof matcher === "object" && matcher !== null) {
            hasLogical = !!Object.keys(matcher).find((operator) => LOGICAL_OPERATORS.has(operator));
          } else {
            hasLogical = true;
          }
          if (hasLogical) {
            fieldsWithLogicalOperator.add(field);
          }
        });
        var currentFieldsAmount = -1;
        var currentBestIndexForSort;
        schema.indexes.forEach((index) => {
          var useIndex = isMaybeReadonlyArray(index) ? index : [index];
          var firstWrongIndex = useIndex.findIndex((indexField) => !fieldsWithLogicalOperator.has(indexField));
          if (firstWrongIndex > 0 && firstWrongIndex > currentFieldsAmount) {
            currentFieldsAmount = firstWrongIndex;
            currentBestIndexForSort = useIndex;
          }
        });
        if (currentBestIndexForSort) {
          normalizedMangoQuery.sort = currentBestIndexForSort.map((field) => {
            return {
              [field]: "asc"
            };
          });
        }
      }
      if (!normalizedMangoQuery.sort) {
        normalizedMangoQuery.sort = [{
          [primaryKey]: "asc"
        }];
      }
    }
  } else {
    var isPrimaryInSort = normalizedMangoQuery.sort.find((p2) => firstPropertyNameOfObject(p2) === primaryKey);
    if (!isPrimaryInSort) {
      normalizedMangoQuery.sort = normalizedMangoQuery.sort.slice(0);
      normalizedMangoQuery.sort.push({
        [primaryKey]: "asc"
      });
    }
  }
  return normalizedMangoQuery;
}
function getSortComparator(schema, query) {
  if (!query.sort) {
    throw newRxError("SNH", {
      query
    });
  }
  var sortParts = [];
  query.sort.forEach((sortBlock) => {
    var key = Object.keys(sortBlock)[0];
    var direction = Object.values(sortBlock)[0];
    sortParts.push({
      key,
      direction,
      getValueFn: objectPathMonad(key)
    });
  });
  var fun = (a, b2) => {
    for (var i = 0; i < sortParts.length; ++i) {
      var sortPart = sortParts[i];
      var valueA = sortPart.getValueFn(a);
      var valueB = sortPart.getValueFn(b2);
      if (valueA !== valueB) {
        var ret = sortPart.direction === "asc" ? compare$1(valueA, valueB) : compare$1(valueB, valueA);
        return ret;
      }
    }
  };
  return fun;
}
function getQueryMatcher(_schema, query) {
  if (!query.sort) {
    throw newRxError("SNH", {
      query
    });
  }
  var mingoQuery = getMingoQuery(query.selector);
  var fun = (doc) => {
    return mingoQuery.test(doc);
  };
  return fun;
}
function getSortFieldsOfQuery(primaryKey, query) {
  if (!query.sort || query.sort.length === 0) {
    return [primaryKey];
  } else {
    return query.sort.map((part) => Object.keys(part)[0]);
  }
}
var RXQUERY_QUERY_PARAMS_CACHE = /* @__PURE__ */ new WeakMap();
function getQueryParams(rxQuery) {
  return getFromMapOrCreate(RXQUERY_QUERY_PARAMS_CACHE, rxQuery, () => {
    var collection = rxQuery.collection;
    var normalizedMangoQuery = normalizeMangoQuery(collection.storageInstance.schema, clone(rxQuery.mangoQuery));
    var primaryKey = collection.schema.primaryPath;
    var sortComparator = getSortComparator(collection.schema.jsonSchema, normalizedMangoQuery);
    var useSortComparator = (docA, docB) => {
      var sortComparatorData = {
        docA,
        docB,
        rxQuery
      };
      return sortComparator(sortComparatorData.docA, sortComparatorData.docB);
    };
    var queryMatcher = getQueryMatcher(collection.schema.jsonSchema, normalizedMangoQuery);
    var useQueryMatcher = (doc) => {
      var queryMatcherData = {
        doc,
        rxQuery
      };
      return queryMatcher(queryMatcherData.doc);
    };
    var ret = {
      primaryKey: rxQuery.collection.schema.primaryPath,
      skip: normalizedMangoQuery.skip,
      limit: normalizedMangoQuery.limit,
      sortFields: getSortFieldsOfQuery(primaryKey, normalizedMangoQuery),
      sortComparator: useSortComparator,
      queryMatcher: useQueryMatcher
    };
    return ret;
  });
}
function calculateNewResults(rxQuery, rxChangeEvents) {
  if (!rxQuery.collection.database.eventReduce) {
    return {
      runFullQueryAgain: true
    };
  }
  var queryParams = getQueryParams(rxQuery);
  var previousResults = ensureNotFalsy(rxQuery._result).docsData.slice(0);
  var previousResultsMap = ensureNotFalsy(rxQuery._result).docsDataMap;
  var changed = false;
  var eventReduceEvents = rxChangeEvents.map((cE) => rxChangeEventToEventReduceChangeEvent(cE)).filter(arrayFilterNotEmpty);
  var foundNonOptimizeable = eventReduceEvents.find((eventReduceEvent) => {
    var stateResolveFunctionInput = {
      queryParams,
      changeEvent: eventReduceEvent,
      previousResults,
      keyDocumentMap: previousResultsMap
    };
    var actionName = calculateActionName(stateResolveFunctionInput);
    if (actionName === "runFullQueryAgain") {
      return true;
    } else if (actionName !== "doNothing") {
      changed = true;
      runAction(actionName, queryParams, eventReduceEvent, previousResults, previousResultsMap);
      return false;
    }
  });
  if (foundNonOptimizeable) {
    return {
      runFullQueryAgain: true
    };
  } else {
    return {
      runFullQueryAgain: false,
      changed,
      newResults: previousResults
    };
  }
}
var QueryCache = /* @__PURE__ */ function() {
  function QueryCache2() {
    this._map = /* @__PURE__ */ new Map();
  }
  var _proto = QueryCache2.prototype;
  _proto.getByQuery = function getByQuery(rxQuery) {
    var stringRep = rxQuery.toString();
    return getFromMapOrCreate(this._map, stringRep, () => rxQuery);
  };
  return QueryCache2;
}();
function createQueryCache() {
  return new QueryCache();
}
function uncacheRxQuery(queryCache, rxQuery) {
  rxQuery.uncached = true;
  var stringRep = rxQuery.toString();
  queryCache._map.delete(stringRep);
}
function countRxQuerySubscribers(rxQuery) {
  return rxQuery.refCount$.observers.length;
}
var DEFAULT_TRY_TO_KEEP_MAX = 100;
var DEFAULT_UNEXECUTED_LIFETIME = 30 * 1e3;
var defaultCacheReplacementPolicyMonad = (tryToKeepMax, unExecutedLifetime) => (_collection, queryCache) => {
  if (queryCache._map.size < tryToKeepMax) {
    return;
  }
  var minUnExecutedLifetime = now$1() - unExecutedLifetime;
  var maybeUncache = [];
  var queriesInCache = Array.from(queryCache._map.values());
  for (var rxQuery of queriesInCache) {
    if (countRxQuerySubscribers(rxQuery) > 0) {
      continue;
    }
    if (rxQuery._lastEnsureEqual === 0 && rxQuery._creationTime < minUnExecutedLifetime) {
      uncacheRxQuery(queryCache, rxQuery);
      continue;
    }
    maybeUncache.push(rxQuery);
  }
  var mustUncache = maybeUncache.length - tryToKeepMax;
  if (mustUncache <= 0) {
    return;
  }
  var sortedByLastUsage = maybeUncache.sort((a, b2) => a._lastEnsureEqual - b2._lastEnsureEqual);
  var toRemove = sortedByLastUsage.slice(0, mustUncache);
  toRemove.forEach((rxQuery2) => uncacheRxQuery(queryCache, rxQuery2));
};
var defaultCacheReplacementPolicy = defaultCacheReplacementPolicyMonad(DEFAULT_TRY_TO_KEEP_MAX, DEFAULT_UNEXECUTED_LIFETIME);
var COLLECTIONS_WITH_RUNNING_CLEANUP = /* @__PURE__ */ new WeakSet();
function triggerCacheReplacement(rxCollection) {
  if (COLLECTIONS_WITH_RUNNING_CLEANUP.has(rxCollection)) {
    return;
  }
  COLLECTIONS_WITH_RUNNING_CLEANUP.add(rxCollection);
  nextTick().then(() => requestIdlePromise(200)).then(() => {
    if (!rxCollection.destroyed) {
      rxCollection.cacheReplacementPolicy(rxCollection, rxCollection._queryCache);
    }
    COLLECTIONS_WITH_RUNNING_CLEANUP.delete(rxCollection);
  });
}
var DocumentCache = /* @__PURE__ */ function() {
  function DocumentCache2(primaryPath, changes$, documentCreator) {
    this.cacheItemByDocId = /* @__PURE__ */ new Map();
    this.registry = typeof FinalizationRegistry === "function" ? new FinalizationRegistry((docMeta) => {
      var docId = docMeta.docId;
      var cacheItem = this.cacheItemByDocId.get(docId);
      if (cacheItem) {
        cacheItem.byRev.delete(docMeta.revisionHeight);
        if (cacheItem.byRev.size === 0) {
          this.cacheItemByDocId.delete(docId);
        }
      }
    }) : void 0;
    this.registerIdleTasks = [];
    this.primaryPath = primaryPath;
    this.changes$ = changes$;
    this.documentCreator = documentCreator;
    changes$.subscribe((changeEvent) => {
      var docId = changeEvent.documentId;
      var cacheItem = this.cacheItemByDocId.get(docId);
      if (cacheItem) {
        var documentData = getDocumentDataOfRxChangeEvent(changeEvent);
        cacheItem.last = documentData;
      }
    });
  }
  var _proto = DocumentCache2.prototype;
  _proto.getLatestDocumentData = function getLatestDocumentData(docId) {
    var cacheItem = getFromMapOrThrow(this.cacheItemByDocId, docId);
    return cacheItem.last;
  };
  _proto.getLatestDocumentDataIfExists = function getLatestDocumentDataIfExists(docId) {
    var cacheItem = this.cacheItemByDocId.get(docId);
    if (cacheItem) {
      return cacheItem.last;
    }
  };
  _createClass(DocumentCache2, [{
    key: "getCachedRxDocument",
    get: function() {
      var fn = getCachedRxDocumentMonad(this);
      return overwriteGetterForCaching(this, "getCachedRxDocument", fn);
    }
  }]);
  return DocumentCache2;
}();
function getCachedRxDocumentMonad(docCache) {
  var primaryPath = docCache.primaryPath;
  var cacheItemByDocId = docCache.cacheItemByDocId;
  var registry = docCache.registry;
  var deepFreezeWhenDevMode2 = overwritable.deepFreezeWhenDevMode;
  var documentCreator = docCache.documentCreator;
  var fn = (docData) => {
    var docId = docData[primaryPath];
    var revisionHeight = getHeightOfRevision(docData._rev);
    var cacheItem = getFromMapOrCreate(cacheItemByDocId, docId, () => getNewCacheItem(docData));
    var byRev = cacheItem.byRev;
    var cachedRxDocumentWeakRef = byRev.get(revisionHeight);
    var cachedRxDocument = cachedRxDocumentWeakRef ? cachedRxDocumentWeakRef.deref() : void 0;
    if (!cachedRxDocument) {
      docData = deepFreezeWhenDevMode2(docData);
      cachedRxDocument = documentCreator(docData);
      byRev.set(revisionHeight, createWeakRefWithFallback(cachedRxDocument));
      if (registry) {
        docCache.registerIdleTasks.push(cachedRxDocument);
        if (!docCache.registerIdlePromise) {
          docCache.registerIdlePromise = requestIdlePromiseNoQueue().then(() => {
            docCache.registerIdlePromise = void 0;
            var tasks = docCache.registerIdleTasks;
            if (tasks.length === 0) {
              return;
            }
            docCache.registerIdleTasks = [];
            tasks.forEach((doc) => {
              registry.register(doc, {
                docId: doc.primary,
                revisionHeight: getHeightOfRevision(doc.revision)
              });
            });
          });
        }
      }
    }
    return cachedRxDocument;
  };
  return fn;
}
function mapDocumentsDataToCacheDocs(docCache, docsData) {
  var getCachedRxDocument = docCache.getCachedRxDocument;
  var documents = [];
  for (var i = 0; i < docsData.length; i++) {
    var _docData = docsData[i];
    var doc = getCachedRxDocument(_docData);
    documents.push(doc);
  }
  return documents;
}
function getNewCacheItem(docData) {
  return {
    byRev: /* @__PURE__ */ new Map(),
    last: docData
  };
}
var HAS_WEAK_REF = typeof WeakRef === "function";
var createWeakRefWithFallback = HAS_WEAK_REF ? createWeakRef : createWeakRefFallback;
function createWeakRef(obj) {
  return new WeakRef(obj);
}
function createWeakRefFallback(obj) {
  return {
    deref() {
      return obj;
    }
  };
}
var RxQuerySingleResult = /* @__PURE__ */ function() {
  function RxQuerySingleResult2(collection, docsDataFromStorageInstance, count2) {
    this.time = now$1();
    this.collection = collection;
    this.count = count2;
    this.documents = mapDocumentsDataToCacheDocs(this.collection._docCache, docsDataFromStorageInstance);
  }
  _createClass(RxQuerySingleResult2, [{
    key: "docsData",
    get: function() {
      return overwriteGetterForCaching(this, "docsData", this.documents.map((d) => d._data));
    }
    // A key->document map, used in the event reduce optimization.
  }, {
    key: "docsDataMap",
    get: function() {
      var map2 = /* @__PURE__ */ new Map();
      this.documents.forEach((d) => {
        map2.set(d.primary, d._data);
      });
      return overwriteGetterForCaching(this, "docsDataMap", map2);
    }
  }, {
    key: "docsMap",
    get: function() {
      var map2 = /* @__PURE__ */ new Map();
      var documents = this.documents;
      for (var i = 0; i < documents.length; i++) {
        var doc = documents[i];
        map2.set(doc.primary, doc);
      }
      return overwriteGetterForCaching(this, "docsMap", map2);
    }
  }]);
  return RxQuerySingleResult2;
}();
var _queryCount = 0;
var newQueryID = function() {
  return ++_queryCount;
};
var RxQueryBase = /* @__PURE__ */ function() {
  function RxQueryBase2(op, mangoQuery, collection, other = {}) {
    this.id = newQueryID();
    this._execOverDatabaseCount = 0;
    this._creationTime = now$1();
    this._lastEnsureEqual = 0;
    this.uncached = false;
    this.refCount$ = new cjs.BehaviorSubject(null);
    this._result = null;
    this._latestChangeEvent = -1;
    this._lastExecStart = 0;
    this._lastExecEnd = 0;
    this._ensureEqualQueue = PROMISE_RESOLVE_FALSE;
    this.op = op;
    this.mangoQuery = mangoQuery;
    this.collection = collection;
    this.other = other;
    if (!mangoQuery) {
      this.mangoQuery = _getDefaultQuery();
    }
    this.isFindOneByIdQuery = isFindOneByIdQuery(this.collection.schema.primaryPath, mangoQuery);
  }
  var _proto = RxQueryBase2.prototype;
  _proto._setResultData = function _setResultData(newResultData) {
    if (typeof newResultData === "number") {
      this._result = new RxQuerySingleResult(this.collection, [], newResultData);
      return;
    } else if (newResultData instanceof Map) {
      newResultData = Array.from(newResultData.values());
    }
    var newQueryResult = new RxQuerySingleResult(this.collection, newResultData, newResultData.length);
    this._result = newQueryResult;
  };
  _proto._execOverDatabase = async function _execOverDatabase() {
    this._execOverDatabaseCount = this._execOverDatabaseCount + 1;
    this._lastExecStart = now$1();
    if (this.op === "count") {
      var preparedQuery = this.getPreparedQuery();
      var result = await this.collection.storageInstance.count(preparedQuery);
      if (result.mode === "slow" && !this.collection.database.allowSlowCount) {
        throw newRxError("QU14", {
          collection: this.collection,
          queryObj: this.mangoQuery
        });
      } else {
        return result.count;
      }
    }
    if (this.op === "findByIds") {
      var ids = ensureNotFalsy(this.mangoQuery.selector)[this.collection.schema.primaryPath].$in;
      var ret = /* @__PURE__ */ new Map();
      var mustBeQueried = [];
      ids.forEach((id2) => {
        var docData = this.collection._docCache.getLatestDocumentDataIfExists(id2);
        if (docData) {
          if (!docData._deleted) {
            var doc = this.collection._docCache.getCachedRxDocument(docData);
            ret.set(id2, doc);
          }
        } else {
          mustBeQueried.push(id2);
        }
      });
      if (mustBeQueried.length > 0) {
        var docs = await this.collection.storageInstance.findDocumentsById(mustBeQueried, false);
        docs.forEach((docData) => {
          var doc = this.collection._docCache.getCachedRxDocument(docData);
          ret.set(doc.primary, doc);
        });
      }
      return ret;
    }
    var docsPromise = queryCollection(this);
    return docsPromise.then((docs2) => {
      this._lastExecEnd = now$1();
      return docs2;
    });
  };
  _proto.exec = function exec(throwIfMissing) {
    if (throwIfMissing && this.op !== "findOne") {
      throw newRxError("QU9", {
        collection: this.collection.name,
        query: this.mangoQuery,
        op: this.op
      });
    }
    return _ensureEqual(this).then(() => cjs.firstValueFrom(this.$)).then((result) => {
      if (!result && throwIfMissing) {
        throw newRxError("QU10", {
          collection: this.collection.name,
          query: this.mangoQuery,
          op: this.op
        });
      } else {
        return result;
      }
    });
  };
  _proto.toString = function toString2() {
    var stringObj = sortObject({
      op: this.op,
      query: this.mangoQuery,
      other: this.other
    }, true);
    var value = JSON.stringify(stringObj);
    this.toString = () => value;
    return value;
  };
  _proto.getPreparedQuery = function getPreparedQuery() {
    var hookInput = {
      rxQuery: this,
      // can be mutated by the hooks so we have to deep clone first.
      mangoQuery: normalizeMangoQuery(this.collection.schema.jsonSchema, this.mangoQuery)
    };
    hookInput.mangoQuery.selector._deleted = {
      $eq: false
    };
    if (hookInput.mangoQuery.index) {
      hookInput.mangoQuery.index.unshift("_deleted");
    }
    runPluginHooks("prePrepareQuery", hookInput);
    var value = prepareQuery(this.collection.schema.jsonSchema, hookInput.mangoQuery);
    this.getPreparedQuery = () => value;
    return value;
  };
  _proto.doesDocumentDataMatch = function doesDocumentDataMatch(docData) {
    if (docData._deleted) {
      return false;
    }
    return this.queryMatcher(docData);
  };
  _proto.remove = function remove() {
    return this.exec().then((docs) => {
      if (Array.isArray(docs)) {
        return Promise.all(docs.map((doc) => doc.remove()));
      } else {
        return docs.remove();
      }
    });
  };
  _proto.update = function update(_updateObj) {
    throw pluginMissing("update");
  };
  _proto.where = function where(_queryObj) {
    throw pluginMissing("query-builder");
  };
  _proto.sort = function sort(_params) {
    throw pluginMissing("query-builder");
  };
  _proto.skip = function skip2(_amount) {
    throw pluginMissing("query-builder");
  };
  _proto.limit = function limit(_amount) {
    throw pluginMissing("query-builder");
  };
  _createClass(RxQueryBase2, [{
    key: "$",
    get: function() {
      if (!this._$) {
        var results$ = this.collection.$.pipe(
          /**
           * Performance shortcut.
           * Changes to local documents are not relevant for the query.
           */
          filter$3((changeEvent) => !changeEvent.isLocal),
          /**
           * Start once to ensure the querying also starts
           * when there where no changes.
           */
          startWith$2(null),
          // ensure query results are up to date.
          mergeMap$2(() => _ensureEqual(this)),
          // use the current result set, written by _ensureEqual().
          map$2(() => this._result),
          // do not run stuff above for each new subscriber, only once.
          shareReplay$2(RXJS_SHARE_REPLAY_DEFAULTS),
          // do not proceed if result set has not changed.
          distinctUntilChanged$2((prev2, curr) => {
            if (prev2 && prev2.time === ensureNotFalsy(curr).time) {
              return true;
            } else {
              return false;
            }
          }),
          filter$3((result) => !!result),
          /**
           * Map the result set to a single RxDocument or an array,
           * depending on query type
           */
          map$2((result) => {
            var useResult = ensureNotFalsy(result);
            if (this.op === "count") {
              return useResult.count;
            } else if (this.op === "findOne") {
              return useResult.documents.length === 0 ? null : useResult.documents[0];
            } else if (this.op === "findByIds") {
              return useResult.docsMap;
            } else {
              return useResult.documents.slice(0);
            }
          })
        );
        this._$ = cjs.merge(
          results$,
          /**
           * Also add the refCount$ to the query observable
           * to allow us to count the amount of subscribers.
           */
          this.refCount$.pipe(filter$3(() => false))
        );
      }
      return this._$;
    }
    // stores the changeEvent-number of the last handled change-event
    // time stamps on when the last full exec over the database has run
    // used to properly handle events that happen while the find-query is running
    /**
     * ensures that the exec-runs
     * are not run in parallel
     */
  }, {
    key: "queryMatcher",
    get: function() {
      var schema = this.collection.schema.jsonSchema;
      var normalizedQuery = normalizeMangoQuery(this.collection.schema.jsonSchema, this.mangoQuery);
      return overwriteGetterForCaching(this, "queryMatcher", getQueryMatcher(schema, normalizedQuery));
    }
  }, {
    key: "asRxQuery",
    get: function() {
      return this;
    }
  }]);
  return RxQueryBase2;
}();
function _getDefaultQuery() {
  return {
    selector: {}
  };
}
function tunnelQueryCache(rxQuery) {
  return rxQuery.collection._queryCache.getByQuery(rxQuery);
}
function createRxQuery(op, queryObj, collection, other) {
  runPluginHooks("preCreateRxQuery", {
    op,
    queryObj,
    collection,
    other
  });
  var ret = new RxQueryBase(op, queryObj, collection, other);
  ret = tunnelQueryCache(ret);
  triggerCacheReplacement(collection);
  return ret;
}
function _isResultsInSync(rxQuery) {
  var currentLatestEventNumber = rxQuery.asRxQuery.collection._changeEventBuffer.counter;
  if (rxQuery._latestChangeEvent >= currentLatestEventNumber) {
    return true;
  } else {
    return false;
  }
}
function _ensureEqual(rxQuery) {
  if (rxQuery.collection.database.destroyed || _isResultsInSync(rxQuery)) {
    return PROMISE_RESOLVE_FALSE;
  }
  rxQuery._ensureEqualQueue = rxQuery._ensureEqualQueue.then(() => __ensureEqual(rxQuery));
  return rxQuery._ensureEqualQueue;
}
function __ensureEqual(rxQuery) {
  rxQuery._lastEnsureEqual = now$1();
  if (
    // db is closed
    rxQuery.collection.database.destroyed || // nothing happened since last run
    _isResultsInSync(rxQuery)
  ) {
    return PROMISE_RESOLVE_FALSE;
  }
  var ret = false;
  var mustReExec = false;
  if (rxQuery._latestChangeEvent === -1) {
    mustReExec = true;
  }
  if (!mustReExec) {
    var missedChangeEvents = rxQuery.asRxQuery.collection._changeEventBuffer.getFrom(rxQuery._latestChangeEvent + 1);
    if (missedChangeEvents === null) {
      mustReExec = true;
    } else {
      rxQuery._latestChangeEvent = rxQuery.asRxQuery.collection._changeEventBuffer.counter;
      var runChangeEvents = rxQuery.asRxQuery.collection._changeEventBuffer.reduceByLastOfDoc(missedChangeEvents);
      if (rxQuery.op === "count") {
        var previousCount = ensureNotFalsy(rxQuery._result).count;
        var newCount = previousCount;
        runChangeEvents.forEach((cE) => {
          var didMatchBefore = cE.previousDocumentData && rxQuery.doesDocumentDataMatch(cE.previousDocumentData);
          var doesMatchNow2 = rxQuery.doesDocumentDataMatch(cE.documentData);
          if (!didMatchBefore && doesMatchNow2) {
            newCount++;
          }
          if (didMatchBefore && !doesMatchNow2) {
            newCount--;
          }
        });
        if (newCount !== previousCount) {
          ret = true;
          rxQuery._setResultData(newCount);
        }
      } else {
        var eventReduceResult = calculateNewResults(rxQuery, runChangeEvents);
        if (eventReduceResult.runFullQueryAgain) {
          mustReExec = true;
        } else if (eventReduceResult.changed) {
          ret = true;
          rxQuery._setResultData(eventReduceResult.newResults);
        }
      }
    }
  }
  if (mustReExec) {
    return rxQuery._execOverDatabase().then((newResultData) => {
      rxQuery._latestChangeEvent = rxQuery.collection._changeEventBuffer.counter;
      if (typeof newResultData === "number") {
        if (!rxQuery._result || newResultData !== rxQuery._result.count) {
          ret = true;
          rxQuery._setResultData(newResultData);
        }
        return ret;
      }
      if (!rxQuery._result || !areRxDocumentArraysEqual(rxQuery.collection.schema.primaryPath, newResultData, rxQuery._result.docsData)) {
        ret = true;
        rxQuery._setResultData(newResultData);
      }
      return ret;
    });
  }
  return Promise.resolve(ret);
}
function prepareQuery(schema, mutateableQuery) {
  if (!mutateableQuery.sort) {
    throw newRxError("SNH", {
      query: mutateableQuery
    });
  }
  var queryPlan = getQueryPlan(schema, mutateableQuery);
  return {
    query: mutateableQuery,
    queryPlan
  };
}
async function queryCollection(rxQuery) {
  var docs = [];
  var collection = rxQuery.collection;
  if (rxQuery.isFindOneByIdQuery) {
    if (Array.isArray(rxQuery.isFindOneByIdQuery)) {
      var docIds = rxQuery.isFindOneByIdQuery;
      docIds = docIds.filter((docId2) => {
        var docData2 = rxQuery.collection._docCache.getLatestDocumentDataIfExists(docId2);
        if (docData2) {
          if (!docData2._deleted) {
            docs.push(docData2);
          }
          return false;
        } else {
          return true;
        }
      });
      if (docIds.length > 0) {
        var docsFromStorage = await collection.storageInstance.findDocumentsById(docIds, false);
        appendToArray(docs, docsFromStorage);
      }
    } else {
      var docId = rxQuery.isFindOneByIdQuery;
      var docData = rxQuery.collection._docCache.getLatestDocumentDataIfExists(docId);
      if (!docData) {
        var fromStorageList = await collection.storageInstance.findDocumentsById([docId], false);
        if (fromStorageList[0]) {
          docData = fromStorageList[0];
        }
      }
      if (docData && !docData._deleted) {
        docs.push(docData);
      }
    }
  } else {
    var preparedQuery = rxQuery.getPreparedQuery();
    var queryResult = await collection.storageInstance.query(preparedQuery);
    docs = queryResult.documents;
  }
  return docs;
}
function isFindOneByIdQuery(primaryPath, query) {
  if (!query.skip && query.selector && Object.keys(query.selector).length === 1 && query.selector[primaryPath]) {
    var value = query.selector[primaryPath];
    if (typeof value === "string") {
      return value;
    } else if (Object.keys(value).length === 1 && typeof value.$eq === "string") {
      return value.$eq;
    }
    if (Object.keys(value).length === 1 && Array.isArray(value.$eq) && // must only contain strings
    !value.$eq.find((r2) => typeof r2 !== "string")) {
      return value.$eq;
    }
  }
  return false;
}
var INTERNAL_STORAGE_NAME = "_rxdb_internal";
async function getSingleDocument(storageInstance, documentId) {
  var results = await storageInstance.findDocumentsById([documentId], false);
  var doc = results[0];
  if (doc) {
    return doc;
  } else {
    return void 0;
  }
}
function storageChangeEventToRxChangeEvent(isLocal, rxStorageChangeEvent, rxCollection) {
  var documentData = rxStorageChangeEvent.documentData;
  var previousDocumentData = rxStorageChangeEvent.previousDocumentData;
  var ret = {
    documentId: rxStorageChangeEvent.documentId,
    collectionName: rxCollection ? rxCollection.name : void 0,
    isLocal,
    operation: rxStorageChangeEvent.operation,
    documentData: overwritable.deepFreezeWhenDevMode(documentData),
    previousDocumentData: overwritable.deepFreezeWhenDevMode(previousDocumentData)
  };
  return ret;
}
function throwIfIsStorageWriteError(collection, documentId, writeData, error) {
  if (error) {
    if (error.status === 409) {
      throw newRxError("CONFLICT", {
        collection: collection.name,
        id: documentId,
        writeError: error,
        data: writeData
      });
    } else if (error.status === 422) {
      throw newRxError("VD2", {
        collection: collection.name,
        id: documentId,
        writeError: error,
        data: writeData
      });
    } else {
      throw error;
    }
  }
}
function categorizeBulkWriteRows(storageInstance, primaryPath, docsInDb, bulkWriteRows, context2, onInsert, onUpdate) {
  var hasAttachments = !!storageInstance.schema.attachments;
  var bulkInsertDocs = [];
  var bulkUpdateDocs = [];
  var errors = [];
  var eventBulkId = randomCouchString(10);
  var eventBulk = {
    id: eventBulkId,
    events: [],
    checkpoint: null,
    context: context2,
    startTime: now$1(),
    endTime: 0
  };
  var eventBulkEvents = eventBulk.events;
  var attachmentsAdd = [];
  var attachmentsRemove = [];
  var attachmentsUpdate = [];
  var hasDocsInDb = docsInDb.size > 0;
  var newestRow;
  var rowAmount = bulkWriteRows.length;
  var _loop = function() {
    var writeRow = bulkWriteRows[rowId];
    var document2 = writeRow.document;
    var previous = writeRow.previous;
    var docId = document2[primaryPath];
    var documentDeleted = document2._deleted;
    var previousDeleted = previous && previous._deleted;
    var documentInDb = void 0;
    if (hasDocsInDb) {
      documentInDb = docsInDb.get(docId);
    }
    var attachmentError;
    if (!documentInDb) {
      var insertedIsDeleted = documentDeleted ? true : false;
      if (hasAttachments) {
        Object.entries(document2._attachments).forEach(([attachmentId, attachmentData]) => {
          if (!attachmentData.data) {
            attachmentError = {
              documentId: docId,
              isError: true,
              status: 510,
              writeRow,
              attachmentId
            };
            errors.push(attachmentError);
          } else {
            attachmentsAdd.push({
              documentId: docId,
              attachmentId,
              attachmentData,
              digest: attachmentData.digest
            });
          }
        });
      }
      if (!attachmentError) {
        if (hasAttachments) {
          bulkInsertDocs.push(stripAttachmentsDataFromRow(writeRow));
          if (onInsert) {
            onInsert(document2);
          }
        } else {
          bulkInsertDocs.push(writeRow);
          if (onInsert) {
            onInsert(document2);
          }
        }
        newestRow = writeRow;
      }
      if (!insertedIsDeleted) {
        var event = {
          documentId: docId,
          operation: "INSERT",
          documentData: hasAttachments ? stripAttachmentsDataFromDocument(document2) : document2,
          previousDocumentData: hasAttachments && previous ? stripAttachmentsDataFromDocument(previous) : previous
        };
        eventBulkEvents.push(event);
      }
    } else {
      var revInDb = documentInDb._rev;
      if (!previous || !!previous && revInDb !== previous._rev) {
        var err = {
          isError: true,
          status: 409,
          documentId: docId,
          writeRow,
          documentInDb
        };
        errors.push(err);
        return 1;
      }
      var updatedRow = hasAttachments ? stripAttachmentsDataFromRow(writeRow) : writeRow;
      if (hasAttachments) {
        if (documentDeleted) {
          if (previous) {
            Object.keys(previous._attachments).forEach((attachmentId) => {
              attachmentsRemove.push({
                documentId: docId,
                attachmentId,
                digest: ensureNotFalsy(previous)._attachments[attachmentId].digest
              });
            });
          }
        } else {
          Object.entries(document2._attachments).find(([attachmentId, attachmentData]) => {
            var previousAttachmentData = previous ? previous._attachments[attachmentId] : void 0;
            if (!previousAttachmentData && !attachmentData.data) {
              attachmentError = {
                documentId: docId,
                documentInDb,
                isError: true,
                status: 510,
                writeRow,
                attachmentId
              };
            }
            return true;
          });
          if (!attachmentError) {
            Object.entries(document2._attachments).forEach(([attachmentId, attachmentData]) => {
              var previousAttachmentData = previous ? previous._attachments[attachmentId] : void 0;
              if (!previousAttachmentData) {
                attachmentsAdd.push({
                  documentId: docId,
                  attachmentId,
                  attachmentData,
                  digest: attachmentData.digest
                });
              } else {
                var newDigest = updatedRow.document._attachments[attachmentId].digest;
                if (attachmentData.data && /**
                 * Performance shortcut,
                 * do not update the attachment data if it did not change.
                 */
                previousAttachmentData.digest !== newDigest) {
                  attachmentsUpdate.push({
                    documentId: docId,
                    attachmentId,
                    attachmentData,
                    digest: attachmentData.digest
                  });
                }
              }
            });
          }
        }
      }
      if (attachmentError) {
        errors.push(attachmentError);
      } else {
        if (hasAttachments) {
          bulkUpdateDocs.push(stripAttachmentsDataFromRow(updatedRow));
          if (onUpdate) {
            onUpdate(document2);
          }
        } else {
          bulkUpdateDocs.push(updatedRow);
          if (onUpdate) {
            onUpdate(document2);
          }
        }
        newestRow = updatedRow;
      }
      var eventDocumentData = null;
      var previousEventDocumentData = null;
      var operation = null;
      if (previousDeleted && !documentDeleted) {
        operation = "INSERT";
        eventDocumentData = hasAttachments ? stripAttachmentsDataFromDocument(document2) : document2;
      } else if (previous && !previousDeleted && !documentDeleted) {
        operation = "UPDATE";
        eventDocumentData = hasAttachments ? stripAttachmentsDataFromDocument(document2) : document2;
        previousEventDocumentData = previous;
      } else if (documentDeleted) {
        operation = "DELETE";
        eventDocumentData = ensureNotFalsy(document2);
        previousEventDocumentData = previous;
      } else {
        throw newRxError("SNH", {
          args: {
            writeRow
          }
        });
      }
      var _event = {
        documentId: docId,
        documentData: eventDocumentData,
        previousDocumentData: previousEventDocumentData,
        operation
      };
      eventBulkEvents.push(_event);
    }
  };
  for (var rowId = 0; rowId < rowAmount; rowId++) {
    if (_loop())
      continue;
  }
  return {
    bulkInsertDocs,
    bulkUpdateDocs,
    newestRow,
    errors,
    eventBulk,
    attachmentsAdd,
    attachmentsRemove,
    attachmentsUpdate
  };
}
function stripAttachmentsDataFromRow(writeRow) {
  return {
    previous: writeRow.previous,
    document: stripAttachmentsDataFromDocument(writeRow.document)
  };
}
function getAttachmentSize(attachmentBase64String) {
  return atob(attachmentBase64String).length;
}
function attachmentWriteDataToNormalData(writeData) {
  var data = writeData.data;
  if (!data) {
    return writeData;
  }
  var ret = {
    length: getAttachmentSize(data),
    digest: writeData.digest,
    type: writeData.type
  };
  return ret;
}
function stripAttachmentsDataFromDocument(doc) {
  if (!doc._attachments || Object.keys(doc._attachments).length === 0) {
    return doc;
  }
  var useDoc = flatClone(doc);
  useDoc._attachments = {};
  Object.entries(doc._attachments).forEach(([attachmentId, attachmentData]) => {
    useDoc._attachments[attachmentId] = attachmentWriteDataToNormalData(attachmentData);
  });
  return useDoc;
}
function flatCloneDocWithMeta(doc) {
  var ret = flatClone(doc);
  ret._meta = flatClone(doc._meta);
  return ret;
}
function getWrappedStorageInstance(database, storageInstance, rxJsonSchema) {
  overwritable.deepFreezeWhenDevMode(rxJsonSchema);
  var primaryPath = getPrimaryFieldOfPrimaryKey(rxJsonSchema.primaryKey);
  function transformDocumentDataFromRxDBToRxStorage(writeRow) {
    var data = flatClone(writeRow.document);
    data._meta = flatClone(data._meta);
    if (overwritable.isDevMode()) {
      data = fillPrimaryKey(primaryPath, rxJsonSchema, data);
      try {
        if (typeof structuredClone === "function") {
          structuredClone(writeRow);
        } else {
          JSON.parse(JSON.stringify(writeRow));
        }
      } catch (err) {
        throw newRxError("DOC24", {
          collection: storageInstance.collectionName,
          document: writeRow.document
        });
      }
      if (writeRow.previous)
        ;
      if (writeRow.previous) {
        Object.keys(writeRow.previous._meta).forEach((metaFieldName) => {
          if (!Object.prototype.hasOwnProperty.call(writeRow.document._meta, metaFieldName)) {
            throw newRxError("SNH", {
              dataBefore: writeRow.previous,
              dataAfter: writeRow.document
            });
          }
        });
      }
    }
    data._meta.lwt = now$1();
    data._rev = createRevision(database.token, writeRow.previous);
    return {
      document: data,
      previous: writeRow.previous
    };
  }
  var ret = {
    originalStorageInstance: storageInstance,
    schema: storageInstance.schema,
    internals: storageInstance.internals,
    collectionName: storageInstance.collectionName,
    databaseName: storageInstance.databaseName,
    options: storageInstance.options,
    bulkWrite(rows, context2) {
      var toStorageWriteRows = rows.map((row) => transformDocumentDataFromRxDBToRxStorage(row));
      return database.lockedRun(() => storageInstance.bulkWrite(toStorageWriteRows, context2)).then((writeResult) => {
        var useWriteResult = {
          error: [],
          success: writeResult.success.slice(0)
        };
        var reInsertErrors = writeResult.error.filter((error) => {
          if (error.status === 409 && !error.writeRow.previous && !error.writeRow.document._deleted && ensureNotFalsy(error.documentInDb)._deleted) {
            return true;
          }
          useWriteResult.error.push(error);
          return false;
        });
        if (reInsertErrors.length > 0) {
          var reInserts = reInsertErrors.map((error) => {
            return {
              previous: error.documentInDb,
              document: Object.assign({}, error.writeRow.document, {
                _rev: createRevision(database.token, error.documentInDb)
              })
            };
          });
          return database.lockedRun(() => storageInstance.bulkWrite(reInserts, context2)).then((subResult) => {
            appendToArray(useWriteResult.error, subResult.error);
            appendToArray(useWriteResult.success, subResult.success);
            return useWriteResult;
          });
        }
        return writeResult;
      });
    },
    query(preparedQuery) {
      return database.lockedRun(() => storageInstance.query(preparedQuery));
    },
    count(preparedQuery) {
      return database.lockedRun(() => storageInstance.count(preparedQuery));
    },
    findDocumentsById(ids, deleted) {
      return database.lockedRun(() => storageInstance.findDocumentsById(ids, deleted));
    },
    getAttachmentData(documentId, attachmentId, digest) {
      return database.lockedRun(() => storageInstance.getAttachmentData(documentId, attachmentId, digest));
    },
    getChangedDocumentsSince: !storageInstance.getChangedDocumentsSince ? void 0 : (limit, checkpoint) => {
      return database.lockedRun(() => storageInstance.getChangedDocumentsSince(ensureNotFalsy(limit), checkpoint));
    },
    cleanup(minDeletedTime) {
      return database.lockedRun(() => storageInstance.cleanup(minDeletedTime));
    },
    remove() {
      database.storageInstances.delete(ret);
      return database.lockedRun(() => storageInstance.remove());
    },
    close() {
      database.storageInstances.delete(ret);
      return database.lockedRun(() => storageInstance.close());
    },
    changeStream() {
      return storageInstance.changeStream();
    },
    conflictResultionTasks() {
      return storageInstance.conflictResultionTasks();
    },
    resolveConflictResultionTask(taskSolution) {
      if (taskSolution.output.isEqual) {
        return storageInstance.resolveConflictResultionTask(taskSolution);
      }
      var doc = Object.assign({}, taskSolution.output.documentData, {
        _meta: getDefaultRxDocumentMeta(),
        _rev: getDefaultRevision(),
        _attachments: {}
      });
      var documentData = flatClone(doc);
      delete documentData._meta;
      delete documentData._rev;
      delete documentData._attachments;
      return storageInstance.resolveConflictResultionTask({
        id: taskSolution.id,
        output: {
          isEqual: false,
          documentData
        }
      });
    }
  };
  database.storageInstances.add(ret);
  return ret;
}
function ensureRxStorageInstanceParamsAreCorrect(params) {
  if (params.schema.keyCompression) {
    throw newRxError("UT5", {
      args: {
        params
      }
    });
  }
  if (hasEncryption(params.schema)) {
    throw newRxError("UT6", {
      args: {
        params
      }
    });
  }
  if (params.schema.attachments && params.schema.attachments.compression) {
    throw newRxError("UT7", {
      args: {
        params
      }
    });
  }
}
function hasEncryption(jsonSchema) {
  if (!!jsonSchema.encrypted && jsonSchema.encrypted.length > 0 || jsonSchema.attachments && jsonSchema.attachments.encrypted) {
    return true;
  } else {
    return false;
  }
}
var IncrementalWriteQueue = /* @__PURE__ */ function() {
  function IncrementalWriteQueue2(storageInstance, primaryPath, preWrite, postWrite) {
    this.queueByDocId = /* @__PURE__ */ new Map();
    this.isRunning = false;
    this.storageInstance = storageInstance;
    this.primaryPath = primaryPath;
    this.preWrite = preWrite;
    this.postWrite = postWrite;
  }
  var _proto = IncrementalWriteQueue2.prototype;
  _proto.addWrite = function addWrite(lastKnownDocumentState, modifier) {
    var docId = lastKnownDocumentState[this.primaryPath];
    var ar = getFromMapOrCreate(this.queueByDocId, docId, () => []);
    var ret = new Promise((resolve2, reject) => {
      var item = {
        lastKnownDocumentState,
        modifier,
        resolve: resolve2,
        reject
      };
      ensureNotFalsy(ar).push(item);
      this.triggerRun();
    });
    return ret;
  };
  _proto.triggerRun = async function triggerRun() {
    if (this.isRunning === true || this.queueByDocId.size === 0) {
      return;
    }
    this.isRunning = true;
    var writeRows = [];
    var itemsById = this.queueByDocId;
    this.queueByDocId = /* @__PURE__ */ new Map();
    await Promise.all(Array.from(itemsById.entries()).map(async ([_docId, items]) => {
      var oldData = findNewestOfDocumentStates(items.map((i) => i.lastKnownDocumentState));
      var newData = oldData;
      for (var item of items) {
        try {
          newData = await item.modifier(
            /**
             * We have to clone() each time because the modifier
             * might throw while it already changed some properties
             * of the document.
             */
            clone(newData)
          );
        } catch (err) {
          item.reject(err);
          item.reject = () => {
          };
          item.resolve = () => {
          };
        }
      }
      try {
        await this.preWrite(newData, oldData);
      } catch (err) {
        items.forEach((item2) => item2.reject(err));
        return;
      }
      writeRows.push({
        previous: oldData,
        document: newData
      });
    }));
    var writeResult = writeRows.length > 0 ? await this.storageInstance.bulkWrite(writeRows, "incremental-write") : {
      error: [],
      success: []
    };
    await Promise.all(writeResult.success.map((result) => {
      var docId = result[this.primaryPath];
      this.postWrite(result);
      var items = getFromMapOrThrow(itemsById, docId);
      items.forEach((item) => item.resolve(result));
    }));
    writeResult.error.forEach((error) => {
      var docId = error.documentId;
      var items = getFromMapOrThrow(itemsById, docId);
      var isConflict = isBulkWriteConflictError(error);
      if (isConflict) {
        var ar = getFromMapOrCreate(this.queueByDocId, docId, () => []);
        items.reverse().forEach((item) => {
          item.lastKnownDocumentState = ensureNotFalsy(isConflict.documentInDb);
          ensureNotFalsy(ar).unshift(item);
        });
      } else {
        var rxError = rxStorageWriteErrorToRxError(error);
        items.forEach((item) => item.reject(rxError));
      }
    });
    this.isRunning = false;
    return this.triggerRun();
  };
  return IncrementalWriteQueue2;
}();
function modifierFromPublicToInternal(publicModifier) {
  var ret = async (docData) => {
    var withoutMeta = stripMetaDataFromDocument(docData);
    withoutMeta._deleted = docData._deleted;
    var modified = await publicModifier(withoutMeta);
    var reattachedMeta = Object.assign({}, modified, {
      _meta: docData._meta,
      _attachments: docData._attachments,
      _rev: docData._rev,
      _deleted: typeof modified._deleted !== "undefined" ? modified._deleted : docData._deleted
    });
    if (typeof reattachedMeta._deleted === "undefined") {
      reattachedMeta._deleted = false;
    }
    return reattachedMeta;
  };
  return ret;
}
function findNewestOfDocumentStates(docs) {
  var newest = docs[0];
  var newestRevisionHeight = parseRevision(newest._rev).height;
  docs.forEach((doc) => {
    var height = parseRevision(doc._rev).height;
    if (height > newestRevisionHeight) {
      newest = doc;
      newestRevisionHeight = height;
    }
  });
  return newest;
}
var basePrototype = {
  get primaryPath() {
    var _this = this;
    if (!_this.isInstanceOfRxDocument) {
      return void 0;
    }
    return _this.collection.schema.primaryPath;
  },
  get primary() {
    var _this = this;
    if (!_this.isInstanceOfRxDocument) {
      return void 0;
    }
    return _this._data[_this.primaryPath];
  },
  get revision() {
    var _this = this;
    if (!_this.isInstanceOfRxDocument) {
      return void 0;
    }
    return _this._data._rev;
  },
  get deleted$() {
    var _this = this;
    if (!_this.isInstanceOfRxDocument) {
      return void 0;
    }
    return _this.$.pipe(map$2((d) => d._data._deleted));
  },
  get deleted() {
    var _this = this;
    if (!_this.isInstanceOfRxDocument) {
      return void 0;
    }
    return _this._data._deleted;
  },
  getLatest() {
    var latestDocData = this.collection._docCache.getLatestDocumentData(this.primary);
    return this.collection._docCache.getCachedRxDocument(latestDocData);
  },
  /**
   * returns the observable which emits the plain-data of this document
   */
  get $() {
    var _this = this;
    return _this.collection.$.pipe(filter$3((changeEvent) => !changeEvent.isLocal), filter$3((changeEvent) => changeEvent.documentId === this.primary), map$2((changeEvent) => getDocumentDataOfRxChangeEvent(changeEvent)), startWith$2(_this.collection._docCache.getLatestDocumentData(this.primary)), distinctUntilChanged$2((prev2, curr) => prev2._rev === curr._rev), map$2((docData) => this.collection._docCache.getCachedRxDocument(docData)), shareReplay$2(RXJS_SHARE_REPLAY_DEFAULTS));
  },
  /**
   * returns observable of the value of the given path
   */
  get$(path) {
    if (overwritable.isDevMode()) {
      if (path.includes(".item.")) {
        throw newRxError("DOC1", {
          path
        });
      }
      if (path === this.primaryPath) {
        throw newRxError("DOC2");
      }
      if (this.collection.schema.finalFields.includes(path)) {
        throw newRxError("DOC3", {
          path
        });
      }
      var schemaObj = getSchemaByObjectPath(this.collection.schema.jsonSchema, path);
      if (!schemaObj) {
        throw newRxError("DOC4", {
          path
        });
      }
    }
    return this.$.pipe(map$2((data) => getProperty$1(data, path)), distinctUntilChanged$2());
  },
  /**
   * populate the given path
   */
  populate(path) {
    var schemaObj = getSchemaByObjectPath(this.collection.schema.jsonSchema, path);
    var value = this.get(path);
    if (!value) {
      return PROMISE_RESOLVE_NULL;
    }
    if (!schemaObj) {
      throw newRxError("DOC5", {
        path
      });
    }
    if (!schemaObj.ref) {
      throw newRxError("DOC6", {
        path,
        schemaObj
      });
    }
    var refCollection = this.collection.database.collections[schemaObj.ref];
    if (!refCollection) {
      throw newRxError("DOC7", {
        ref: schemaObj.ref,
        path,
        schemaObj
      });
    }
    if (schemaObj.type === "array") {
      return refCollection.findByIds(value).exec().then((res) => {
        var valuesIterator = res.values();
        return Array.from(valuesIterator);
      });
    } else {
      return refCollection.findOne(value).exec();
    }
  },
  /**
   * get data by objectPath
   * @hotPath Performance here is really important,
   * run some tests before changing anything.
   */
  get(objPath) {
    return getFromMapOrCreate(this._propertyCache, objPath, () => {
      var valueObj = getProperty$1(this._data, objPath);
      if (typeof valueObj !== "object" || valueObj === null || Array.isArray(valueObj)) {
        return overwritable.deepFreezeWhenDevMode(valueObj);
      }
      var _this = this;
      var proxy = new Proxy(
        /**
         * In dev-mode, the _data is deep-frozen
         * so we have to flat clone here so that
         * the proxy can work.
         */
        flatClone(valueObj),
        {
          get(target, property) {
            if (typeof property !== "string") {
              return target[property];
            }
            var lastChar = property.charAt(property.length - 1);
            if (lastChar === "$") {
              var key = property.slice(0, -1);
              return _this.get$(trimDots(objPath + "." + key));
            } else if (lastChar === "_") {
              var _key = property.slice(0, -1);
              return _this.populate(trimDots(objPath + "." + _key));
            } else {
              return _this.get(trimDots(objPath + "." + property));
            }
          }
        }
      );
      return proxy;
    });
  },
  toJSON(withMetaFields = false) {
    if (!withMetaFields) {
      var data = flatClone(this._data);
      delete data._rev;
      delete data._attachments;
      delete data._deleted;
      delete data._meta;
      return overwritable.deepFreezeWhenDevMode(data);
    } else {
      return overwritable.deepFreezeWhenDevMode(this._data);
    }
  },
  toMutableJSON(withMetaFields = false) {
    return clone(this.toJSON(withMetaFields));
  },
  /**
   * updates document
   * @overwritten by plugin (optional)
   * @param updateObj mongodb-like syntax
   */
  update(_updateObj) {
    throw pluginMissing("update");
  },
  incrementalUpdate(_updateObj) {
    throw pluginMissing("update");
  },
  updateCRDT(_updateObj) {
    throw pluginMissing("crdt");
  },
  putAttachment() {
    throw pluginMissing("attachments");
  },
  getAttachment() {
    throw pluginMissing("attachments");
  },
  allAttachments() {
    throw pluginMissing("attachments");
  },
  get allAttachments$() {
    throw pluginMissing("attachments");
  },
  async modify(mutationFunction, _context) {
    var oldData = this._data;
    var newData = await modifierFromPublicToInternal(mutationFunction)(oldData);
    return this._saveData(newData, oldData);
  },
  /**
   * runs an incremental update over the document
   * @param function that takes the document-data and returns a new data-object
   */
  incrementalModify(mutationFunction, _context) {
    return this.collection.incrementalWriteQueue.addWrite(this._data, modifierFromPublicToInternal(mutationFunction)).then((result) => this.collection._docCache.getCachedRxDocument(result));
  },
  patch(patch) {
    var oldData = this._data;
    var newData = clone(oldData);
    Object.entries(patch).forEach(([k2, v2]) => {
      newData[k2] = v2;
    });
    return this._saveData(newData, oldData);
  },
  /**
   * patches the given properties
   */
  incrementalPatch(patch) {
    return this.incrementalModify((docData) => {
      Object.entries(patch).forEach(([k2, v2]) => {
        docData[k2] = v2;
      });
      return docData;
    });
  },
  /**
   * saves the new document-data
   * and handles the events
   */
  async _saveData(newData, oldData) {
    newData = flatClone(newData);
    if (this._data._deleted) {
      throw newRxError("DOC11", {
        id: this.primary,
        document: this
      });
    }
    await beforeDocumentUpdateWrite(this.collection, newData, oldData);
    var writeResult = await this.collection.storageInstance.bulkWrite([{
      previous: oldData,
      document: newData
    }], "rx-document-save-data");
    var isError = writeResult.error[0];
    throwIfIsStorageWriteError(this.collection, this.primary, newData, isError);
    await this.collection._runHooks("post", "save", newData, this);
    return this.collection._docCache.getCachedRxDocument(writeResult.success[0]);
  },
  /**
   * Remove the document.
   * Notice that there is no hard delete,
   * instead deleted documents get flagged with _deleted=true.
   */
  remove() {
    var collection = this.collection;
    if (this.deleted) {
      return Promise.reject(newRxError("DOC13", {
        document: this,
        id: this.primary
      }));
    }
    var deletedData = flatClone(this._data);
    var removedDocData;
    return collection._runHooks("pre", "remove", deletedData, this).then(async () => {
      deletedData._deleted = true;
      var writeResult = await collection.storageInstance.bulkWrite([{
        previous: this._data,
        document: deletedData
      }], "rx-document-remove");
      var isError = writeResult.error[0];
      throwIfIsStorageWriteError(collection, this.primary, deletedData, isError);
      return writeResult.success[0];
    }).then((removed) => {
      removedDocData = removed;
      return this.collection._runHooks("post", "remove", deletedData, this);
    }).then(() => {
      return this.collection._docCache.getCachedRxDocument(removedDocData);
    });
  },
  incrementalRemove() {
    return this.incrementalModify(async (docData) => {
      await this.collection._runHooks("pre", "remove", docData, this);
      docData._deleted = true;
      return docData;
    }).then(async (newDoc) => {
      await this.collection._runHooks("post", "remove", newDoc._data, newDoc);
      return newDoc;
    });
  },
  destroy() {
    throw newRxError("DOC14");
  }
};
function createRxDocumentConstructor(proto = basePrototype) {
  var constructor = function RxDocumentConstructor(collection, docData) {
    this.collection = collection;
    this._data = docData;
    this._propertyCache = /* @__PURE__ */ new Map();
    this.isInstanceOfRxDocument = true;
  };
  constructor.prototype = proto;
  return constructor;
}
function createWithConstructor(constructor, collection, jsonData) {
  var doc = new constructor(collection, jsonData);
  runPluginHooks("createRxDocument", doc);
  return doc;
}
function beforeDocumentUpdateWrite(collection, newData, oldData) {
  newData._meta = Object.assign({}, oldData._meta, newData._meta);
  if (overwritable.isDevMode()) {
    collection.schema.validateChange(oldData, newData);
  }
  return collection._runHooks("pre", "save", newData, oldData);
}
var INTERNAL_CONTEXT_COLLECTION = "collection";
var INTERNAL_CONTEXT_STORAGE_TOKEN = "storage-token";
var INTERNAL_CONTEXT_MIGRATION_STATUS = "rx-migration-status";
var INTERNAL_STORE_SCHEMA_TITLE = "RxInternalDocument";
var INTERNAL_STORE_SCHEMA = fillWithDefaultSettings({
  version: 0,
  title: INTERNAL_STORE_SCHEMA_TITLE,
  primaryKey: {
    key: "id",
    fields: ["context", "key"],
    separator: "|"
  },
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 200
    },
    key: {
      type: "string"
    },
    context: {
      type: "string",
      enum: [INTERNAL_CONTEXT_COLLECTION, INTERNAL_CONTEXT_STORAGE_TOKEN, INTERNAL_CONTEXT_MIGRATION_STATUS, "OTHER"]
    },
    data: {
      type: "object",
      additionalProperties: true
    }
  },
  indexes: [],
  required: ["key", "context", "data"],
  additionalProperties: false,
  /**
   * If the sharding plugin is used,
   * it must not shard on the internal RxStorageInstance
   * because that one anyway has only a small amount of documents
   * and also its creation is in the hot path of the initial page load,
   * so we should spend less time creating multiple RxStorageInstances.
   */
  sharding: {
    shards: 1,
    mode: "collection"
  }
});
function getPrimaryKeyOfInternalDocument(key, context2) {
  return getComposedPrimaryKeyOfDocumentData(INTERNAL_STORE_SCHEMA, {
    key,
    context: context2
  });
}
async function getAllCollectionDocuments(storageInstance) {
  var getAllQueryPrepared = prepareQuery(storageInstance.schema, {
    selector: {
      context: INTERNAL_CONTEXT_COLLECTION,
      _deleted: {
        $eq: false
      }
    },
    sort: [{
      id: "asc"
    }],
    skip: 0
  });
  var queryResult = await storageInstance.query(getAllQueryPrepared);
  var allDocs = queryResult.documents;
  return allDocs;
}
var STORAGE_TOKEN_DOCUMENT_KEY = "storageToken";
var STORAGE_TOKEN_DOCUMENT_ID = getPrimaryKeyOfInternalDocument(STORAGE_TOKEN_DOCUMENT_KEY, INTERNAL_CONTEXT_STORAGE_TOKEN);
async function ensureStorageTokenDocumentExists(rxDatabase) {
  var storageToken = randomCouchString(10);
  var passwordHash = rxDatabase.password ? await rxDatabase.hashFunction(JSON.stringify(rxDatabase.password)) : void 0;
  var docData = {
    id: STORAGE_TOKEN_DOCUMENT_ID,
    context: INTERNAL_CONTEXT_STORAGE_TOKEN,
    key: STORAGE_TOKEN_DOCUMENT_KEY,
    data: {
      rxdbVersion: rxDatabase.rxdbVersion,
      token: storageToken,
      /**
       * We add the instance token here
       * to be able to detect if a given RxDatabase instance
       * is the first instance that was ever created
       * or if databases have existed earlier on that storage
       * with the same database name.
       */
      instanceToken: rxDatabase.token,
      passwordHash
    },
    _deleted: false,
    _meta: getDefaultRxDocumentMeta(),
    _rev: getDefaultRevision(),
    _attachments: {}
  };
  var writeResult = await rxDatabase.internalStore.bulkWrite([{
    document: docData
  }], "internal-add-storage-token");
  if (writeResult.success[0]) {
    return writeResult.success[0];
  }
  var error = ensureNotFalsy(writeResult.error[0]);
  if (error.isError && isBulkWriteConflictError(error)) {
    var conflictError = error;
    if (!isDatabaseStateVersionCompatibleWithDatabaseCode(conflictError.documentInDb.data.rxdbVersion, rxDatabase.rxdbVersion)) {
      throw newRxError("DM5", {
        args: {
          database: rxDatabase.name,
          databaseStateVersion: conflictError.documentInDb.data.rxdbVersion,
          codeVersion: rxDatabase.rxdbVersion
        }
      });
    }
    if (passwordHash && passwordHash !== conflictError.documentInDb.data.passwordHash) {
      throw newRxError("DB1", {
        passwordHash,
        existingPasswordHash: conflictError.documentInDb.data.passwordHash
      });
    }
    var storageTokenDocInDb = conflictError.documentInDb;
    return ensureNotFalsy(storageTokenDocInDb);
  }
  throw error;
}
function isDatabaseStateVersionCompatibleWithDatabaseCode(databaseStateVersion, codeVersion) {
  if (!databaseStateVersion) {
    return false;
  }
  if (codeVersion.includes("beta") && codeVersion !== databaseStateVersion) {
    return false;
  }
  var stateMajor = databaseStateVersion.split(".")[0];
  var codeMajor = codeVersion.split(".")[0];
  if (stateMajor !== codeMajor) {
    return false;
  }
  return true;
}
function _collectionNamePrimary(name, schema) {
  return name + "-" + schema.version;
}
function fillObjectDataBeforeInsert(schema, data) {
  data = flatClone(data);
  data = fillObjectWithDefaults(schema, data);
  data = fillPrimaryKey(schema.primaryPath, schema.jsonSchema, data);
  data._meta = getDefaultRxDocumentMeta();
  if (!Object.prototype.hasOwnProperty.call(data, "_deleted")) {
    data._deleted = false;
  }
  if (!Object.prototype.hasOwnProperty.call(data, "_attachments")) {
    data._attachments = {};
  }
  if (!Object.prototype.hasOwnProperty.call(data, "_rev")) {
    data._rev = getDefaultRevision();
  }
  return data;
}
async function createRxCollectionStorageInstance(rxDatabase, storageInstanceCreationParams) {
  storageInstanceCreationParams.multiInstance = rxDatabase.multiInstance;
  var storageInstance = await rxDatabase.storage.createStorageInstance(storageInstanceCreationParams);
  return storageInstance;
}
async function removeCollectionStorages(storage, databaseInternalStorage, databaseInstanceToken, databaseName, collectionName, password, hashFunction) {
  var allCollectionMetaDocs = await getAllCollectionDocuments(databaseInternalStorage);
  var relevantCollectionMetaDocs = allCollectionMetaDocs.filter((metaDoc) => metaDoc.data.name === collectionName);
  var removeStorages = [];
  relevantCollectionMetaDocs.forEach((metaDoc) => {
    removeStorages.push({
      collectionName: metaDoc.data.name,
      schema: metaDoc.data.schema,
      isCollection: true
    });
    metaDoc.data.connectedStorages.forEach((row) => removeStorages.push({
      collectionName: row.collectionName,
      isCollection: false,
      schema: row.schema
    }));
  });
  var alreadyAdded = /* @__PURE__ */ new Set();
  removeStorages = removeStorages.filter((row) => {
    var key = row.collectionName + "||" + row.schema.version;
    if (alreadyAdded.has(key)) {
      return false;
    } else {
      alreadyAdded.add(key);
      return true;
    }
  });
  await Promise.all(removeStorages.map(async (row) => {
    var storageInstance = await storage.createStorageInstance({
      collectionName: row.collectionName,
      databaseInstanceToken,
      databaseName,
      multiInstance: false,
      options: {},
      schema: row.schema,
      password,
      devMode: overwritable.isDevMode()
    });
    await storageInstance.remove();
    if (row.isCollection) {
      await runAsyncPluginHooks("postRemoveRxCollection", {
        storage,
        databaseName,
        collectionName
      });
    }
  }));
  if (hashFunction) {
    var writeRows = relevantCollectionMetaDocs.map((doc) => {
      var writeDoc = flatCloneDocWithMeta(doc);
      writeDoc._deleted = true;
      writeDoc._meta.lwt = now$1();
      writeDoc._rev = createRevision(databaseInstanceToken, doc);
      return {
        previous: doc,
        document: writeDoc
      };
    });
    await databaseInternalStorage.bulkWrite(writeRows, "rx-database-remove-collection-all");
  }
}
var ChangeEventBuffer = /* @__PURE__ */ function() {
  function ChangeEventBuffer2(collection) {
    this.subs = [];
    this.limit = 100;
    this.counter = 0;
    this.eventCounterMap = /* @__PURE__ */ new WeakMap();
    this.buffer = [];
    this.collection = collection;
    this.subs.push(this.collection.$.pipe(filter$3((cE) => !cE.isLocal)).subscribe((cE) => this._handleChangeEvent(cE)));
  }
  var _proto = ChangeEventBuffer2.prototype;
  _proto._handleChangeEvent = function _handleChangeEvent(changeEvent) {
    this.counter++;
    this.buffer.push(changeEvent);
    this.eventCounterMap.set(changeEvent, this.counter);
    while (this.buffer.length > this.limit) {
      this.buffer.shift();
    }
  };
  _proto.getArrayIndexByPointer = function getArrayIndexByPointer(pointer) {
    var oldestEvent = this.buffer[0];
    var oldestCounter = this.eventCounterMap.get(oldestEvent);
    if (pointer < oldestCounter)
      return null;
    var rest = pointer - oldestCounter;
    return rest;
  };
  _proto.getFrom = function getFrom(pointer) {
    var ret = [];
    var currentIndex = this.getArrayIndexByPointer(pointer);
    if (currentIndex === null)
      return null;
    while (true) {
      var nextEvent = this.buffer[currentIndex];
      currentIndex++;
      if (!nextEvent) {
        return ret;
      } else {
        ret.push(nextEvent);
      }
    }
  };
  _proto.runFrom = function runFrom(pointer, fn) {
    var ret = this.getFrom(pointer);
    if (ret === null) {
      throw new Error("out of bounds");
    } else {
      ret.forEach((cE) => fn(cE));
    }
  };
  _proto.reduceByLastOfDoc = function reduceByLastOfDoc(changeEvents) {
    return changeEvents.slice(0);
  };
  _proto.destroy = function destroy() {
    this.subs.forEach((sub) => sub.unsubscribe());
  };
  return ChangeEventBuffer2;
}();
function createChangeEventBuffer(collection) {
  return new ChangeEventBuffer(collection);
}
var constructorForCollection = /* @__PURE__ */ new WeakMap();
function getDocumentPrototype(rxCollection) {
  var schemaProto = rxCollection.schema.getDocumentPrototype();
  var ormProto = getDocumentOrmPrototype(rxCollection);
  var baseProto = basePrototype;
  var proto = {};
  [schemaProto, ormProto, baseProto].forEach((obj) => {
    var props = Object.getOwnPropertyNames(obj);
    props.forEach((key) => {
      var desc = Object.getOwnPropertyDescriptor(obj, key);
      var enumerable = true;
      if (key.startsWith("_") || key.endsWith("_") || key.startsWith("$") || key.endsWith("$"))
        enumerable = false;
      if (typeof desc.value === "function") {
        Object.defineProperty(proto, key, {
          get() {
            return desc.value.bind(this);
          },
          enumerable,
          configurable: false
        });
      } else {
        desc.enumerable = enumerable;
        desc.configurable = false;
        if (desc.writable)
          desc.writable = false;
        Object.defineProperty(proto, key, desc);
      }
    });
  });
  return proto;
}
function getRxDocumentConstructor(rxCollection) {
  return getFromMapOrCreate(constructorForCollection, rxCollection, () => createRxDocumentConstructor(getDocumentPrototype(rxCollection)));
}
function createNewRxDocument(rxCollection, docData) {
  var doc = createWithConstructor(getRxDocumentConstructor(rxCollection), rxCollection, overwritable.deepFreezeWhenDevMode(docData));
  rxCollection._runHooksSync("post", "create", docData, doc);
  runPluginHooks("postCreateRxDocument", doc);
  return doc;
}
function getDocumentOrmPrototype(rxCollection) {
  var proto = {};
  Object.entries(rxCollection.methods).forEach(([k2, v2]) => {
    proto[k2] = v2;
  });
  return proto;
}
var defaultConflictHandler = function(i, _context) {
  var newDocumentState = stripAttachmentsDataFromDocument(i.newDocumentState);
  var realMasterState = stripAttachmentsDataFromDocument(i.realMasterState);
  if (deepEqual(newDocumentState, realMasterState)) {
    return Promise.resolve({
      isEqual: true
    });
  }
  return Promise.resolve({
    isEqual: false,
    documentData: i.realMasterState
  });
};
var HOOKS_WHEN = ["pre", "post"];
var HOOKS_KEYS = ["insert", "save", "remove", "create"];
var hooksApplied = false;
var RxCollectionBase = /* @__PURE__ */ function() {
  function RxCollectionBase2(database, name, schema, internalStorageInstance, instanceCreationOptions = {}, migrationStrategies = {}, methods = {}, attachments = {}, options = {}, cacheReplacementPolicy = defaultCacheReplacementPolicy, statics = {}, conflictHandler = defaultConflictHandler) {
    this.storageInstance = {};
    this.timeouts = /* @__PURE__ */ new Set();
    this.incrementalWriteQueue = {};
    this._incrementalUpsertQueues = /* @__PURE__ */ new Map();
    this.synced = false;
    this.hooks = {};
    this._subs = [];
    this._docCache = {};
    this._queryCache = createQueryCache();
    this.$ = {};
    this.checkpoint$ = {};
    this._changeEventBuffer = {};
    this.onDestroy = [];
    this.destroyed = false;
    this.database = database;
    this.name = name;
    this.schema = schema;
    this.internalStorageInstance = internalStorageInstance;
    this.instanceCreationOptions = instanceCreationOptions;
    this.migrationStrategies = migrationStrategies;
    this.methods = methods;
    this.attachments = attachments;
    this.options = options;
    this.cacheReplacementPolicy = cacheReplacementPolicy;
    this.statics = statics;
    this.conflictHandler = conflictHandler;
    _applyHookFunctions(this.asRxCollection);
  }
  var _proto = RxCollectionBase2.prototype;
  _proto.prepare = async function prepare() {
    this.storageInstance = getWrappedStorageInstance(this.database, this.internalStorageInstance, this.schema.jsonSchema);
    this.incrementalWriteQueue = new IncrementalWriteQueue(this.storageInstance, this.schema.primaryPath, (newData, oldData) => beforeDocumentUpdateWrite(this, newData, oldData), (result) => this._runHooks("post", "save", result));
    var collectionEventBulks$ = this.database.eventBulks$.pipe(cjs.filter((changeEventBulk) => changeEventBulk.collectionName === this.name));
    this.$ = collectionEventBulks$.pipe(cjs.mergeMap((changeEventBulk) => changeEventBulk.events));
    this.checkpoint$ = collectionEventBulks$.pipe(cjs.map((changeEventBulk) => changeEventBulk.checkpoint));
    this._changeEventBuffer = createChangeEventBuffer(this.asRxCollection);
    this._docCache = new DocumentCache(this.schema.primaryPath, this.$.pipe(cjs.filter((cE) => !cE.isLocal)), (docData) => createNewRxDocument(this.asRxCollection, docData));
    var databaseStorageToken = await this.database.storageToken;
    var subDocs = this.storageInstance.changeStream().subscribe((eventBulk) => {
      var changeEventBulk = {
        id: eventBulk.id,
        internal: false,
        collectionName: this.name,
        storageToken: databaseStorageToken,
        events: eventBulk.events.map((ev) => storageChangeEventToRxChangeEvent(false, ev, this)),
        databaseToken: this.database.token,
        checkpoint: eventBulk.checkpoint,
        context: eventBulk.context,
        endTime: eventBulk.endTime,
        startTime: eventBulk.startTime
      };
      this.database.$emit(changeEventBulk);
    });
    this._subs.push(subDocs);
    this._subs.push(this.storageInstance.conflictResultionTasks().subscribe((task) => {
      this.conflictHandler(task.input, task.context).then((output) => {
        this.storageInstance.resolveConflictResultionTask({
          id: task.id,
          output
        });
      });
    }));
    return PROMISE_RESOLVE_VOID;
  };
  _proto.cleanup = function cleanup(_minimumDeletedTime) {
    throw pluginMissing("cleanup");
  };
  _proto.migrationNeeded = function migrationNeeded() {
    throw pluginMissing("migration-schema");
  };
  _proto.getMigrationState = function getMigrationState() {
    throw pluginMissing("migration-schema");
  };
  _proto.startMigration = function startMigration(batchSize = 10) {
    return this.getMigrationState().startMigration(batchSize);
  };
  _proto.migratePromise = function migratePromise(batchSize = 10) {
    return this.getMigrationState().migratePromise(batchSize);
  };
  _proto.insert = async function insert(json) {
    var writeResult = await this.bulkInsert([json]);
    var isError = writeResult.error[0];
    throwIfIsStorageWriteError(this, json[this.schema.primaryPath], json, isError);
    var insertResult = ensureNotFalsy(writeResult.success[0]);
    return insertResult;
  };
  _proto.bulkInsert = async function bulkInsert(docsData) {
    if (docsData.length === 0) {
      return {
        success: [],
        error: []
      };
    }
    var primaryPath = this.schema.primaryPath;
    var useDocs = docsData.map((docData) => {
      var useDocData = fillObjectDataBeforeInsert(this.schema, docData);
      return useDocData;
    });
    var docs = this.hasHooks("pre", "insert") ? await Promise.all(useDocs.map((doc) => {
      return this._runHooks("pre", "insert", doc).then(() => {
        return doc;
      });
    })) : useDocs;
    var insertRows = docs.map((doc) => {
      var row = {
        document: doc
      };
      return row;
    });
    var results = await this.storageInstance.bulkWrite(insertRows, "rx-collection-bulk-insert");
    var rxDocuments = mapDocumentsDataToCacheDocs(this._docCache, results.success);
    if (this.hasHooks("post", "insert")) {
      var docsMap = /* @__PURE__ */ new Map();
      docs.forEach((doc) => {
        docsMap.set(doc[primaryPath], doc);
      });
      await Promise.all(rxDocuments.map((doc) => {
        return this._runHooks("post", "insert", docsMap.get(doc.primary), doc);
      }));
    }
    return {
      success: rxDocuments,
      error: results.error
    };
  };
  _proto.bulkRemove = async function bulkRemove(ids) {
    var primaryPath = this.schema.primaryPath;
    if (ids.length === 0) {
      return {
        success: [],
        error: []
      };
    }
    var rxDocumentMap = await this.findByIds(ids).exec();
    var docsData = [];
    var docsMap = /* @__PURE__ */ new Map();
    Array.from(rxDocumentMap.values()).forEach((rxDocument) => {
      var data = rxDocument.toMutableJSON(true);
      docsData.push(data);
      docsMap.set(rxDocument.primary, data);
    });
    await Promise.all(docsData.map((doc) => {
      var primary = doc[this.schema.primaryPath];
      return this._runHooks("pre", "remove", doc, rxDocumentMap.get(primary));
    }));
    var removeDocs = docsData.map((doc) => {
      var writeDoc = flatClone(doc);
      writeDoc._deleted = true;
      return {
        previous: doc,
        document: writeDoc
      };
    });
    var results = await this.storageInstance.bulkWrite(removeDocs, "rx-collection-bulk-remove");
    var successIds = results.success.map((d) => d[primaryPath]);
    await Promise.all(successIds.map((id2) => {
      return this._runHooks("post", "remove", docsMap.get(id2), rxDocumentMap.get(id2));
    }));
    var rxDocuments = successIds.map((id2) => getFromMapOrThrow(rxDocumentMap, id2));
    return {
      success: rxDocuments,
      error: results.error
    };
  };
  _proto.bulkUpsert = async function bulkUpsert(docsData) {
    var insertData = [];
    var useJsonByDocId = /* @__PURE__ */ new Map();
    docsData.forEach((docData) => {
      var useJson = fillObjectDataBeforeInsert(this.schema, docData);
      var primary = useJson[this.schema.primaryPath];
      if (!primary) {
        throw newRxError("COL3", {
          primaryPath: this.schema.primaryPath,
          data: useJson,
          schema: this.schema.jsonSchema
        });
      }
      useJsonByDocId.set(primary, useJson);
      insertData.push(useJson);
    });
    var insertResult = await this.bulkInsert(insertData);
    var success = insertResult.success.slice(0);
    var error = [];
    await Promise.all(insertResult.error.map(async (err) => {
      if (err.status !== 409) {
        error.push(err);
      } else {
        var id2 = err.documentId;
        var writeData = getFromMapOrThrow(useJsonByDocId, id2);
        var docDataInDb = ensureNotFalsy(err.documentInDb);
        var doc = this._docCache.getCachedRxDocument(docDataInDb);
        var newDoc = await doc.incrementalModify(() => writeData);
        success.push(newDoc);
      }
    }));
    return {
      error,
      success
    };
  };
  _proto.upsert = async function upsert(json) {
    var bulkResult = await this.bulkUpsert([json]);
    throwIfIsStorageWriteError(this.asRxCollection, json[this.schema.primaryPath], json, bulkResult.error[0]);
    return bulkResult.success[0];
  };
  _proto.incrementalUpsert = function incrementalUpsert(json) {
    var useJson = fillObjectDataBeforeInsert(this.schema, json);
    var primary = useJson[this.schema.primaryPath];
    if (!primary) {
      throw newRxError("COL4", {
        data: json
      });
    }
    var queue2 = this._incrementalUpsertQueues.get(primary);
    if (!queue2) {
      queue2 = PROMISE_RESOLVE_VOID;
    }
    queue2 = queue2.then(() => _incrementalUpsertEnsureRxDocumentExists(this, primary, useJson)).then((wasInserted) => {
      if (!wasInserted.inserted) {
        return _incrementalUpsertUpdate(wasInserted.doc, useJson);
      } else {
        return wasInserted.doc;
      }
    });
    this._incrementalUpsertQueues.set(primary, queue2);
    return queue2;
  };
  _proto.find = function find2(queryObj) {
    if (typeof queryObj === "string") {
      throw newRxError("COL5", {
        queryObj
      });
    }
    if (!queryObj) {
      queryObj = _getDefaultQuery();
    }
    var query = createRxQuery("find", queryObj, this);
    return query;
  };
  _proto.findOne = function findOne(queryObj) {
    if (typeof queryObj === "number" || Array.isArray(queryObj)) {
      throw newRxTypeError("COL6", {
        queryObj
      });
    }
    var query;
    if (typeof queryObj === "string") {
      query = createRxQuery("findOne", {
        selector: {
          [this.schema.primaryPath]: queryObj
        },
        limit: 1
      }, this);
    } else {
      if (!queryObj) {
        queryObj = _getDefaultQuery();
      }
      if (queryObj.limit) {
        throw newRxError("QU6");
      }
      queryObj = flatClone(queryObj);
      queryObj.limit = 1;
      query = createRxQuery("findOne", queryObj, this);
    }
    return query;
  };
  _proto.count = function count2(queryObj) {
    if (!queryObj) {
      queryObj = _getDefaultQuery();
    }
    var query = createRxQuery("count", queryObj, this);
    return query;
  };
  _proto.findByIds = function findByIds(ids) {
    var mangoQuery = {
      selector: {
        [this.schema.primaryPath]: {
          $in: ids.slice(0)
        }
      }
    };
    var query = createRxQuery("findByIds", mangoQuery, this);
    return query;
  };
  _proto.exportJSON = function exportJSON() {
    throw pluginMissing("json-dump");
  };
  _proto.importJSON = function importJSON(_exportedJSON) {
    throw pluginMissing("json-dump");
  };
  _proto.insertCRDT = function insertCRDT(_updateObj) {
    throw pluginMissing("crdt");
  };
  _proto.addHook = function addHook(when, key, fun, parallel = false) {
    if (typeof fun !== "function") {
      throw newRxTypeError("COL7", {
        key,
        when
      });
    }
    if (!HOOKS_WHEN.includes(when)) {
      throw newRxTypeError("COL8", {
        key,
        when
      });
    }
    if (!HOOKS_KEYS.includes(key)) {
      throw newRxError("COL9", {
        key
      });
    }
    if (when === "post" && key === "create" && parallel === true) {
      throw newRxError("COL10", {
        when,
        key,
        parallel
      });
    }
    var boundFun = fun.bind(this);
    var runName = parallel ? "parallel" : "series";
    this.hooks[key] = this.hooks[key] || {};
    this.hooks[key][when] = this.hooks[key][when] || {
      series: [],
      parallel: []
    };
    this.hooks[key][when][runName].push(boundFun);
  };
  _proto.getHooks = function getHooks(when, key) {
    if (!this.hooks[key] || !this.hooks[key][when]) {
      return {
        series: [],
        parallel: []
      };
    }
    return this.hooks[key][when];
  };
  _proto.hasHooks = function hasHooks(when, key) {
    var hooks = this.getHooks(when, key);
    if (!hooks) {
      return false;
    }
    return hooks.series.length > 0 || hooks.parallel.length > 0;
  };
  _proto._runHooks = function _runHooks(when, key, data, instance) {
    var hooks = this.getHooks(when, key);
    if (!hooks) {
      return PROMISE_RESOLVE_VOID;
    }
    var tasks = hooks.series.map((hook) => () => hook(data, instance));
    return promiseSeries(tasks).then(() => Promise.all(hooks.parallel.map((hook) => hook(data, instance))));
  };
  _proto._runHooksSync = function _runHooksSync(when, key, data, instance) {
    var hooks = this.getHooks(when, key);
    if (!hooks)
      return;
    hooks.series.forEach((hook) => hook(data, instance));
  };
  _proto.promiseWait = function promiseWait2(time) {
    var ret = new Promise((res) => {
      var timeout2 = setTimeout(() => {
        this.timeouts.delete(timeout2);
        res();
      }, time);
      this.timeouts.add(timeout2);
    });
    return ret;
  };
  _proto.destroy = function destroy() {
    if (this.destroyed) {
      return PROMISE_RESOLVE_FALSE;
    }
    this.destroyed = true;
    Array.from(this.timeouts).forEach((timeout2) => clearTimeout(timeout2));
    if (this._changeEventBuffer) {
      this._changeEventBuffer.destroy();
    }
    return this.database.requestIdlePromise().then(() => Promise.all(this.onDestroy.map((fn) => fn()))).then(() => this.storageInstance.close()).then(() => {
      this._subs.forEach((sub) => sub.unsubscribe());
      delete this.database.collections[this.name];
      return runAsyncPluginHooks("postDestroyRxCollection", this).then(() => true);
    });
  };
  _proto.remove = async function remove() {
    await this.destroy();
    await removeCollectionStorages(this.database.storage, this.database.internalStore, this.database.token, this.database.name, this.name, this.database.password, this.database.hashFunction);
  };
  _createClass(RxCollectionBase2, [{
    key: "insert$",
    get: function() {
      return this.$.pipe(cjs.filter((cE) => cE.operation === "INSERT"));
    }
  }, {
    key: "update$",
    get: function() {
      return this.$.pipe(cjs.filter((cE) => cE.operation === "UPDATE"));
    }
  }, {
    key: "remove$",
    get: function() {
      return this.$.pipe(cjs.filter((cE) => cE.operation === "DELETE"));
    }
    // defaults
    /**
     * When the collection is destroyed,
     * these functions will be called an awaited.
     * Used to automatically clean up stuff that
     * belongs to this collection.
     */
  }, {
    key: "asRxCollection",
    get: function() {
      return this;
    }
  }]);
  return RxCollectionBase2;
}();
function _applyHookFunctions(collection) {
  if (hooksApplied)
    return;
  hooksApplied = true;
  var colProto = Object.getPrototypeOf(collection);
  HOOKS_KEYS.forEach((key) => {
    HOOKS_WHEN.map((when) => {
      var fnName = when + ucfirst(key);
      colProto[fnName] = function(fun, parallel) {
        return this.addHook(when, key, fun, parallel);
      };
    });
  });
}
function _incrementalUpsertUpdate(doc, json) {
  return doc.incrementalModify((_innerDoc) => {
    return json;
  });
}
function _incrementalUpsertEnsureRxDocumentExists(rxCollection, primary, json) {
  var docDataFromCache = rxCollection._docCache.getLatestDocumentDataIfExists(primary);
  if (docDataFromCache) {
    return Promise.resolve({
      doc: rxCollection._docCache.getCachedRxDocument(docDataFromCache),
      inserted: false
    });
  }
  return rxCollection.findOne(primary).exec().then((doc) => {
    if (!doc) {
      return rxCollection.insert(json).then((newDoc) => ({
        doc: newDoc,
        inserted: true
      }));
    } else {
      return {
        doc,
        inserted: false
      };
    }
  });
}
function createRxCollection({
  database,
  name,
  schema,
  instanceCreationOptions = {},
  migrationStrategies = {},
  autoMigrate = true,
  statics = {},
  methods = {},
  attachments = {},
  options = {},
  localDocuments = false,
  cacheReplacementPolicy = defaultCacheReplacementPolicy,
  conflictHandler = defaultConflictHandler
}) {
  var storageInstanceCreationParams = {
    databaseInstanceToken: database.token,
    databaseName: database.name,
    collectionName: name,
    schema: schema.jsonSchema,
    options: instanceCreationOptions,
    multiInstance: database.multiInstance,
    password: database.password,
    devMode: overwritable.isDevMode()
  };
  runPluginHooks("preCreateRxStorageInstance", storageInstanceCreationParams);
  return createRxCollectionStorageInstance(database, storageInstanceCreationParams).then((storageInstance) => {
    var collection = new RxCollectionBase(database, name, schema, storageInstance, instanceCreationOptions, migrationStrategies, methods, attachments, options, cacheReplacementPolicy, statics, conflictHandler);
    return collection.prepare().then(() => {
      Object.entries(statics).forEach(([funName, fun]) => {
        Object.defineProperty(collection, funName, {
          get: () => fun.bind(collection)
        });
      });
      var ret = PROMISE_RESOLVE_VOID;
      if (autoMigrate && collection.schema.version !== 0) {
        ret = collection.migratePromise();
      }
      return ret;
    }).then(() => {
      runPluginHooks("createRxCollection", {
        collection,
        creator: {
          name,
          schema,
          storageInstance,
          instanceCreationOptions,
          migrationStrategies,
          methods,
          attachments,
          options,
          cacheReplacementPolicy,
          localDocuments,
          statics
        }
      });
      return collection;
    }).catch((err) => {
      return storageInstance.close().then(() => Promise.reject(err));
    });
  });
}
var IdleQueue = function IdleQueue2() {
  var parallels = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
  this._parallels = parallels || 1;
  this._qC = 0;
  this._iC = /* @__PURE__ */ new Set();
  this._lHN = 0;
  this._hPM = /* @__PURE__ */ new Map();
  this._pHM = /* @__PURE__ */ new Map();
};
IdleQueue.prototype = {
  isIdle: function isIdle() {
    return this._qC < this._parallels;
  },
  /**
   * creates a lock in the queue
   * and returns an unlock-function to remove the lock from the queue
   * @return {function} unlock function than must be called afterwards
   */
  lock: function lock() {
    this._qC++;
  },
  unlock: function unlock() {
    this._qC--;
    _tryIdleCall(this);
  },
  /**
   * wraps a function with lock/unlock and runs it
   * @param  {function}  fun
   * @return {Promise<any>}
   */
  wrapCall: function wrapCall(fun) {
    var _this = this;
    this.lock();
    var maybePromise;
    try {
      maybePromise = fun();
    } catch (err) {
      this.unlock();
      throw err;
    }
    if (!maybePromise.then || typeof maybePromise.then !== "function") {
      this.unlock();
      return maybePromise;
    } else {
      return maybePromise.then(function(ret) {
        _this.unlock();
        return ret;
      })["catch"](function(err) {
        _this.unlock();
        throw err;
      });
    }
  },
  /**
   * does the same as requestIdleCallback() but uses promises instead of the callback
   * @param {{timeout?: number}} options like timeout
   * @return {Promise<void>} promise that resolves when the database is in idle-mode
   */
  requestIdlePromise: function requestIdlePromise2(options) {
    var _this2 = this;
    options = options || {};
    var resolve2;
    var prom = new Promise(function(res) {
      return resolve2 = res;
    });
    var resolveFromOutside = function resolveFromOutside2() {
      _removeIdlePromise(_this2, prom);
      resolve2();
    };
    prom._manRes = resolveFromOutside;
    if (options.timeout) {
      var timeoutObj = setTimeout(function() {
        prom._manRes();
      }, options.timeout);
      prom._timeoutObj = timeoutObj;
    }
    this._iC.add(prom);
    _tryIdleCall(this);
    return prom;
  },
  /**
   * remove the promise so it will never be resolved
   * @param  {Promise} promise from requestIdlePromise()
   * @return {void}
   */
  cancelIdlePromise: function cancelIdlePromise(promise) {
    _removeIdlePromise(this, promise);
  },
  /**
   * api equal to
   * @link https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback
   * @param  {Function} callback
   * @param  {options}   options  [description]
   * @return {number} handle which can be used with cancelIdleCallback()
   */
  requestIdleCallback: function requestIdleCallback2(callback, options) {
    var handle = this._lHN++;
    var promise = this.requestIdlePromise(options);
    this._hPM.set(handle, promise);
    this._pHM.set(promise, handle);
    promise.then(function() {
      return callback();
    });
    return handle;
  },
  /**
   * API equal to
   * @link https://developer.mozilla.org/en-US/docs/Web/API/Window/cancelIdleCallback
   * @param  {number} handle returned from requestIdleCallback()
   * @return {void}
   */
  cancelIdleCallback: function cancelIdleCallback(handle) {
    var promise = this._hPM.get(handle);
    this.cancelIdlePromise(promise);
  },
  /**
   * clears and resets everything
   * @return {void}
   */
  clear: function clear() {
    var _this3 = this;
    this._iC.forEach(function(promise) {
      return _removeIdlePromise(_this3, promise);
    });
    this._qC = 0;
    this._iC.clear();
    this._hPM = /* @__PURE__ */ new Map();
    this._pHM = /* @__PURE__ */ new Map();
  }
};
function _resolveOneIdleCall(idleQueue) {
  if (idleQueue._iC.size === 0)
    return;
  var iterator2 = idleQueue._iC.values();
  var oldestPromise = iterator2.next().value;
  oldestPromise._manRes();
  setTimeout(function() {
    return _tryIdleCall(idleQueue);
  }, 0);
}
function _removeIdlePromise(idleQueue, promise) {
  if (!promise)
    return;
  if (promise._timeoutObj)
    clearTimeout(promise._timeoutObj);
  if (idleQueue._pHM.has(promise)) {
    var handle = idleQueue._pHM.get(promise);
    idleQueue._hPM["delete"](handle);
    idleQueue._pHM["delete"](promise);
  }
  idleQueue._iC["delete"](promise);
}
function _tryIdleCall(idleQueue) {
  if (idleQueue._tryIR || idleQueue._iC.size === 0)
    return;
  idleQueue._tryIR = true;
  setTimeout(function() {
    if (!idleQueue.isIdle()) {
      idleQueue._tryIR = false;
      return;
    }
    setTimeout(function() {
      if (!idleQueue.isIdle()) {
        idleQueue._tryIR = false;
        return;
      }
      _resolveOneIdleCall(idleQueue);
      idleQueue._tryIR = false;
    }, 0);
  }, 0);
}
class ObliviousSet {
  constructor(ttl) {
    __publicField(this, "ttl");
    __publicField(this, "map", /* @__PURE__ */ new Map());
    /**
     * Creating calls to setTimeout() is expensive,
     * so we only do that if there is not timeout already open.
     */
    __publicField(this, "_to", false);
    this.ttl = ttl;
  }
  has(value) {
    return this.map.has(value);
  }
  add(value) {
    this.map.set(value, now());
    if (!this._to) {
      this._to = true;
      setTimeout(() => {
        this._to = false;
        removeTooOldValues(this);
      }, 0);
    }
  }
  clear() {
    this.map.clear();
  }
}
function removeTooOldValues(obliviousSet) {
  const olderThen = now() - obliviousSet.ttl;
  const iterator2 = obliviousSet.map[Symbol.iterator]();
  while (true) {
    const next2 = iterator2.next().value;
    if (!next2) {
      return;
    }
    const value = next2[0];
    const time = next2[1];
    if (time < olderThen) {
      obliviousSet.map.delete(value);
    } else {
      return;
    }
  }
}
function now() {
  return Date.now();
}
var USED_DATABASE_NAMES = /* @__PURE__ */ new Set();
var RxDatabaseBase = /* @__PURE__ */ function() {
  function RxDatabaseBase2(name, token2, storage, instanceCreationOptions, password, multiInstance, eventReduce = false, options = {}, internalStore, hashFunction, cleanupPolicy, allowSlowCount) {
    this.idleQueue = new IdleQueue();
    this.rxdbVersion = RXDB_VERSION;
    this.storageInstances = /* @__PURE__ */ new Set();
    this._subs = [];
    this.startupErrors = [];
    this.onDestroy = [];
    this.destroyed = false;
    this.collections = {};
    this.eventBulks$ = new cjs.Subject();
    this.observable$ = this.eventBulks$.pipe(mergeMap$2((changeEventBulk) => changeEventBulk.events));
    this.storageToken = PROMISE_RESOLVE_FALSE;
    this.storageTokenDocument = PROMISE_RESOLVE_FALSE;
    this.emittedEventBulkIds = new ObliviousSet(60 * 1e3);
    this.name = name;
    this.token = token2;
    this.storage = storage;
    this.instanceCreationOptions = instanceCreationOptions;
    this.password = password;
    this.multiInstance = multiInstance;
    this.eventReduce = eventReduce;
    this.options = options;
    this.internalStore = internalStore;
    this.hashFunction = hashFunction;
    this.cleanupPolicy = cleanupPolicy;
    this.allowSlowCount = allowSlowCount;
    if (this.name !== "pseudoInstance") {
      this.internalStore = getWrappedStorageInstance(this.asRxDatabase, internalStore, INTERNAL_STORE_SCHEMA);
      this.storageTokenDocument = ensureStorageTokenDocumentExists(this.asRxDatabase).catch((err) => this.startupErrors.push(err));
      this.storageToken = this.storageTokenDocument.then((doc) => doc.data.token).catch((err) => this.startupErrors.push(err));
    }
  }
  var _proto = RxDatabaseBase2.prototype;
  _proto.$emit = function $emit(changeEventBulk) {
    if (this.emittedEventBulkIds.has(changeEventBulk.id)) {
      return;
    }
    this.emittedEventBulkIds.add(changeEventBulk.id);
    this.eventBulks$.next(changeEventBulk);
  };
  _proto.removeCollectionDoc = async function removeCollectionDoc(name, schema) {
    var doc = await getSingleDocument(this.internalStore, getPrimaryKeyOfInternalDocument(_collectionNamePrimary(name, schema), INTERNAL_CONTEXT_COLLECTION));
    if (!doc) {
      throw newRxError("SNH", {
        name,
        schema
      });
    }
    var writeDoc = flatCloneDocWithMeta(doc);
    writeDoc._deleted = true;
    await this.internalStore.bulkWrite([{
      document: writeDoc,
      previous: doc
    }], "rx-database-remove-collection");
  };
  _proto.addCollections = async function addCollections(collectionCreators) {
    var jsonSchemas = {};
    var schemas = {};
    var bulkPutDocs = [];
    var useArgsByCollectionName = {};
    await Promise.all(Object.entries(collectionCreators).map(async ([name, args2]) => {
      var collectionName = name;
      var rxJsonSchema = args2.schema;
      jsonSchemas[collectionName] = rxJsonSchema;
      var schema = createRxSchema(rxJsonSchema, this.hashFunction);
      schemas[collectionName] = schema;
      if (this.collections[name]) {
        throw newRxError("DB3", {
          name
        });
      }
      var collectionNameWithVersion = _collectionNamePrimary(name, rxJsonSchema);
      var collectionDocData = {
        id: getPrimaryKeyOfInternalDocument(collectionNameWithVersion, INTERNAL_CONTEXT_COLLECTION),
        key: collectionNameWithVersion,
        context: INTERNAL_CONTEXT_COLLECTION,
        data: {
          name: collectionName,
          schemaHash: await schema.hash,
          schema: schema.jsonSchema,
          version: schema.version,
          connectedStorages: []
        },
        _deleted: false,
        _meta: getDefaultRxDocumentMeta(),
        _rev: getDefaultRevision(),
        _attachments: {}
      };
      bulkPutDocs.push({
        document: collectionDocData
      });
      var useArgs = Object.assign({}, args2, {
        name: collectionName,
        schema,
        database: this
      });
      var hookData = flatClone(args2);
      hookData.database = this;
      hookData.name = name;
      runPluginHooks("preCreateRxCollection", hookData);
      useArgs.conflictHandler = hookData.conflictHandler;
      useArgsByCollectionName[collectionName] = useArgs;
    }));
    var putDocsResult = await this.internalStore.bulkWrite(bulkPutDocs, "rx-database-add-collection");
    await ensureNoStartupErrors(this);
    await Promise.all(putDocsResult.error.map(async (error) => {
      if (error.status !== 409) {
        throw newRxError("DB12", {
          database: this.name,
          writeError: error
        });
      }
      var docInDb = ensureNotFalsy(error.documentInDb);
      var collectionName = docInDb.data.name;
      var schema = schemas[collectionName];
      if (docInDb.data.schemaHash !== await schema.hash) {
        throw newRxError("DB6", {
          database: this.name,
          collection: collectionName,
          previousSchemaHash: docInDb.data.schemaHash,
          schemaHash: await schema.hash,
          previousSchema: docInDb.data.schema,
          schema: ensureNotFalsy(jsonSchemas[collectionName])
        });
      }
    }));
    var ret = {};
    await Promise.all(Object.keys(collectionCreators).map(async (collectionName) => {
      var useArgs = useArgsByCollectionName[collectionName];
      var collection = await createRxCollection(useArgs);
      ret[collectionName] = collection;
      this.collections[collectionName] = collection;
      if (!this[collectionName]) {
        Object.defineProperty(this, collectionName, {
          get: () => this.collections[collectionName]
        });
      }
    }));
    return ret;
  };
  _proto.lockedRun = function lockedRun(fn) {
    return this.idleQueue.wrapCall(fn);
  };
  _proto.requestIdlePromise = function requestIdlePromise3() {
    return this.idleQueue.requestIdlePromise();
  };
  _proto.exportJSON = function exportJSON(_collections) {
    throw pluginMissing("json-dump");
  };
  _proto.importJSON = function importJSON(_exportedJSON) {
    throw pluginMissing("json-dump");
  };
  _proto.backup = function backup(_options) {
    throw pluginMissing("backup");
  };
  _proto.leaderElector = function leaderElector() {
    throw pluginMissing("leader-election");
  };
  _proto.isLeader = function isLeader() {
    throw pluginMissing("leader-election");
  };
  _proto.waitForLeadership = function waitForLeadership() {
    throw pluginMissing("leader-election");
  };
  _proto.migrationStates = function migrationStates() {
    throw pluginMissing("migration-schema");
  };
  _proto.destroy = async function destroy() {
    if (this.destroyed) {
      return PROMISE_RESOLVE_FALSE;
    }
    this.destroyed = true;
    await runAsyncPluginHooks("preDestroyRxDatabase", this);
    this.eventBulks$.complete();
    this._subs.map((sub) => sub.unsubscribe());
    if (this.name === "pseudoInstance") {
      return PROMISE_RESOLVE_FALSE;
    }
    return this.requestIdlePromise().then(() => Promise.all(this.onDestroy.map((fn) => fn()))).then(() => Promise.all(Object.keys(this.collections).map((key) => this.collections[key]).map((col) => col.destroy()))).then(() => this.internalStore.close()).then(() => USED_DATABASE_NAMES.delete(this.name)).then(() => true);
  };
  _proto.remove = function remove() {
    return this.destroy().then(() => removeRxDatabase(this.name, this.storage, this.password));
  };
  _createClass(RxDatabaseBase2, [{
    key: "$",
    get: function() {
      return this.observable$;
    }
    /**
     * Because having unhandled exceptions would fail,
     * we have to store the async errors of the constructor here
     * so we can throw them later.
     */
    /**
     * When the database is destroyed,
     * these functions will be called an awaited.
     * Used to automatically clean up stuff that
     * belongs to this collection.
     */
    /**
     * Unique token that is stored with the data.
     * Used to detect if the dataset has been deleted
     * and if two RxDatabase instances work on the same dataset or not.
     *
     * Because reading and writing the storageToken runs in the hot path
     * of database creation, we do not await the storageWrites but instead
     * work with the promise when we need the value.
     */
    /**
     * Stores the whole state of the internal storage token document.
     * We need this in some plugins.
     */
    /**
     * Contains the ids of all event bulks that have been emitted
     * by the database.
     * Used to detect duplicates that come in again via BroadcastChannel
     * or other streams.
     * TODO instead of having this here, we should add a test to ensure each RxStorage
     * behaves equal and does never emit duplicate eventBulks.
     */
  }, {
    key: "asRxDatabase",
    get: function() {
      return this;
    }
  }]);
  return RxDatabaseBase2;
}();
function throwIfDatabaseNameUsed(name) {
  if (!USED_DATABASE_NAMES.has(name)) {
    return;
  } else {
    throw newRxError("DB8", {
      name,
      link: "https://pubkey.github.io/rxdb/rx-database.html#ignoreduplicate"
    });
  }
}
async function createRxDatabaseStorageInstance(databaseInstanceToken, storage, databaseName, options, multiInstance, password) {
  var internalStore = await storage.createStorageInstance({
    databaseInstanceToken,
    databaseName,
    collectionName: INTERNAL_STORAGE_NAME,
    schema: INTERNAL_STORE_SCHEMA,
    options,
    multiInstance,
    password,
    devMode: overwritable.isDevMode()
  });
  return internalStore;
}
function createRxDatabase({
  storage,
  instanceCreationOptions,
  name,
  password,
  multiInstance = true,
  eventReduce = true,
  ignoreDuplicate = false,
  options = {},
  cleanupPolicy,
  allowSlowCount = false,
  localDocuments = false,
  hashFunction = defaultHashSha256
}) {
  runPluginHooks("preCreateRxDatabase", {
    storage,
    instanceCreationOptions,
    name,
    password,
    multiInstance,
    eventReduce,
    ignoreDuplicate,
    options,
    localDocuments
  });
  if (!ignoreDuplicate) {
    throwIfDatabaseNameUsed(name);
  }
  USED_DATABASE_NAMES.add(name);
  var databaseInstanceToken = randomCouchString(10);
  return createRxDatabaseStorageInstance(databaseInstanceToken, storage, name, instanceCreationOptions, multiInstance, password).catch((err) => {
    USED_DATABASE_NAMES.delete(name);
    throw err;
  }).then((storageInstance) => {
    var rxDatabase = new RxDatabaseBase(name, databaseInstanceToken, storage, instanceCreationOptions, password, multiInstance, eventReduce, options, storageInstance, hashFunction, cleanupPolicy, allowSlowCount);
    return runAsyncPluginHooks("createRxDatabase", {
      database: rxDatabase,
      creator: {
        storage,
        instanceCreationOptions,
        name,
        password,
        multiInstance,
        eventReduce,
        ignoreDuplicate,
        options,
        localDocuments
      }
    }).then(() => rxDatabase);
  });
}
async function removeRxDatabase(databaseName, storage, password) {
  var databaseInstanceToken = randomCouchString(10);
  var dbInternalsStorageInstance = await createRxDatabaseStorageInstance(databaseInstanceToken, storage, databaseName, {}, false, password);
  var collectionDocs = await getAllCollectionDocuments(dbInternalsStorageInstance);
  var collectionNames = /* @__PURE__ */ new Set();
  collectionDocs.forEach((doc) => collectionNames.add(doc.data.name));
  var removedCollectionNames = Array.from(collectionNames);
  await Promise.all(removedCollectionNames.map((collectionName) => removeCollectionStorages(storage, dbInternalsStorageInstance, databaseInstanceToken, databaseName, collectionName, password)));
  await runAsyncPluginHooks("postRemoveRxDatabase", {
    databaseName,
    storage
  });
  await dbInternalsStorageInstance.remove();
  return removedCollectionNames;
}
async function ensureNoStartupErrors(rxDatabase) {
  await rxDatabase.storageToken;
  if (rxDatabase.startupErrors[0]) {
    throw rxDatabase.startupErrors[0];
  }
}
var PROTOTYPES = {
  RxSchema: RxSchema.prototype,
  RxDocument: basePrototype,
  RxQuery: RxQueryBase.prototype,
  RxCollection: RxCollectionBase.prototype,
  RxDatabase: RxDatabaseBase.prototype
};
var ADDED_PLUGINS = /* @__PURE__ */ new Set();
var ADDED_PLUGIN_NAMES = /* @__PURE__ */ new Set();
function addRxPlugin(plugin) {
  runPluginHooks("preAddRxPlugin", {
    plugin,
    plugins: ADDED_PLUGINS
  });
  if (ADDED_PLUGINS.has(plugin)) {
    return;
  } else {
    if (ADDED_PLUGIN_NAMES.has(plugin.name)) {
      throw newRxError("PL3", {
        name: plugin.name,
        plugin
      });
    }
    ADDED_PLUGINS.add(plugin);
    ADDED_PLUGIN_NAMES.add(plugin.name);
  }
  if (!plugin.rxdb) {
    throw newRxTypeError("PL1", {
      plugin
    });
  }
  if (plugin.init) {
    plugin.init();
  }
  if (plugin.prototypes) {
    Object.entries(plugin.prototypes).forEach(([name, fun]) => {
      return fun(PROTOTYPES[name]);
    });
  }
  if (plugin.overwritable) {
    Object.assign(overwritable, plugin.overwritable);
  }
  if (plugin.hooks) {
    Object.entries(plugin.hooks).forEach(([name, hooksObj]) => {
      if (hooksObj.after) {
        HOOKS[name].push(hooksObj.after);
      }
      if (hooksObj.before) {
        HOOKS[name].unshift(hooksObj.before);
      }
    });
  }
}
function isPromise(obj) {
  return obj && typeof obj.then === "function";
}
Promise.resolve(false);
Promise.resolve(true);
var PROMISE_RESOLVED_VOID = Promise.resolve();
function sleep(time, resolveWith) {
  if (!time)
    time = 0;
  return new Promise(function(res) {
    return setTimeout(function() {
      return res(resolveWith);
    }, time);
  });
}
function randomInt(min2, max2) {
  return Math.floor(Math.random() * (max2 - min2 + 1) + min2);
}
function randomToken() {
  return Math.random().toString(36).substring(2);
}
var lastMs = 0;
function microSeconds$4() {
  var ret = Date.now() * 1e3;
  if (ret <= lastMs) {
    ret = lastMs + 1;
  }
  lastMs = ret;
  return ret;
}
var microSeconds$3 = microSeconds$4;
var type$3 = "native";
function create$6(channelName) {
  var state = {
    time: microSeconds$4(),
    messagesCallback: null,
    bc: new BroadcastChannel(channelName),
    subFns: []
    // subscriberFunctions
  };
  state.bc.onmessage = function(msgEvent) {
    if (state.messagesCallback) {
      state.messagesCallback(msgEvent.data);
    }
  };
  return state;
}
function close$3(channelState) {
  channelState.bc.close();
  channelState.subFns = [];
}
function postMessage$3(channelState, messageJson) {
  try {
    channelState.bc.postMessage(messageJson, false);
    return PROMISE_RESOLVED_VOID;
  } catch (err) {
    return Promise.reject(err);
  }
}
function onMessage$3(channelState, fn) {
  channelState.messagesCallback = fn;
}
function canBeUsed$3() {
  if (typeof globalThis !== "undefined" && globalThis.Deno && globalThis.Deno.args) {
    return true;
  }
  if ((typeof window !== "undefined" || typeof self !== "undefined") && typeof BroadcastChannel === "function") {
    if (BroadcastChannel._pubkey) {
      throw new Error("BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill");
    }
    return true;
  } else {
    return false;
  }
}
function averageResponseTime$3() {
  return 150;
}
var NativeMethod = {
  create: create$6,
  close: close$3,
  onMessage: onMessage$3,
  postMessage: postMessage$3,
  canBeUsed: canBeUsed$3,
  type: type$3,
  averageResponseTime: averageResponseTime$3,
  microSeconds: microSeconds$3
};
function fillOptionsWithDefaults() {
  var originalOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var options = JSON.parse(JSON.stringify(originalOptions));
  if (typeof options.webWorkerSupport === "undefined")
    options.webWorkerSupport = true;
  if (!options.idb)
    options.idb = {};
  if (!options.idb.ttl)
    options.idb.ttl = 1e3 * 45;
  if (!options.idb.fallbackInterval)
    options.idb.fallbackInterval = 150;
  if (originalOptions.idb && typeof originalOptions.idb.onclose === "function")
    options.idb.onclose = originalOptions.idb.onclose;
  if (!options.localstorage)
    options.localstorage = {};
  if (!options.localstorage.removeTimeout)
    options.localstorage.removeTimeout = 1e3 * 60;
  if (originalOptions.methods)
    options.methods = originalOptions.methods;
  if (!options.node)
    options.node = {};
  if (!options.node.ttl)
    options.node.ttl = 1e3 * 60 * 2;
  if (!options.node.maxParallelWrites)
    options.node.maxParallelWrites = 2048;
  if (typeof options.node.useFastPath === "undefined")
    options.node.useFastPath = true;
  return options;
}
var microSeconds$2 = microSeconds$4;
var DB_PREFIX = "pubkey.broadcast-channel-0-";
var OBJECT_STORE_ID = "messages";
var TRANSACTION_SETTINGS = {
  durability: "relaxed"
};
var type$2 = "idb";
function getIdb() {
  if (typeof indexedDB !== "undefined")
    return indexedDB;
  if (typeof window !== "undefined") {
    if (typeof window.mozIndexedDB !== "undefined")
      return window.mozIndexedDB;
    if (typeof window.webkitIndexedDB !== "undefined")
      return window.webkitIndexedDB;
    if (typeof window.msIndexedDB !== "undefined")
      return window.msIndexedDB;
  }
  return false;
}
function commitIndexedDBTransaction(tx) {
  if (tx.commit) {
    tx.commit();
  }
}
function createDatabase(channelName) {
  var IndexedDB = getIdb();
  var dbName = DB_PREFIX + channelName;
  var openRequest = IndexedDB.open(dbName);
  openRequest.onupgradeneeded = function(ev) {
    var db2 = ev.target.result;
    db2.createObjectStore(OBJECT_STORE_ID, {
      keyPath: "id",
      autoIncrement: true
    });
  };
  return new Promise(function(res, rej) {
    openRequest.onerror = function(ev) {
      return rej(ev);
    };
    openRequest.onsuccess = function() {
      res(openRequest.result);
    };
  });
}
function writeMessage(db2, readerUuid, messageJson) {
  var time = Date.now();
  var writeObject = {
    uuid: readerUuid,
    time,
    data: messageJson
  };
  var tx = db2.transaction([OBJECT_STORE_ID], "readwrite", TRANSACTION_SETTINGS);
  return new Promise(function(res, rej) {
    tx.oncomplete = function() {
      return res();
    };
    tx.onerror = function(ev) {
      return rej(ev);
    };
    var objectStore = tx.objectStore(OBJECT_STORE_ID);
    objectStore.add(writeObject);
    commitIndexedDBTransaction(tx);
  });
}
function getMessagesHigherThan(db2, lastCursorId) {
  var tx = db2.transaction(OBJECT_STORE_ID, "readonly", TRANSACTION_SETTINGS);
  var objectStore = tx.objectStore(OBJECT_STORE_ID);
  var ret = [];
  var keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);
  if (objectStore.getAll) {
    var getAllRequest = objectStore.getAll(keyRangeValue);
    return new Promise(function(res, rej) {
      getAllRequest.onerror = function(err) {
        return rej(err);
      };
      getAllRequest.onsuccess = function(e2) {
        res(e2.target.result);
      };
    });
  }
  function openCursor() {
    try {
      keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);
      return objectStore.openCursor(keyRangeValue);
    } catch (e2) {
      return objectStore.openCursor();
    }
  }
  return new Promise(function(res, rej) {
    var openCursorRequest = openCursor();
    openCursorRequest.onerror = function(err) {
      return rej(err);
    };
    openCursorRequest.onsuccess = function(ev) {
      var cursor = ev.target.result;
      if (cursor) {
        if (cursor.value.id < lastCursorId + 1) {
          cursor["continue"](lastCursorId + 1);
        } else {
          ret.push(cursor.value);
          cursor["continue"]();
        }
      } else {
        commitIndexedDBTransaction(tx);
        res(ret);
      }
    };
  });
}
function removeMessagesById(channelState, ids) {
  if (channelState.closed) {
    return Promise.resolve([]);
  }
  var tx = channelState.db.transaction(OBJECT_STORE_ID, "readwrite", TRANSACTION_SETTINGS);
  var objectStore = tx.objectStore(OBJECT_STORE_ID);
  return Promise.all(ids.map(function(id2) {
    var deleteRequest = objectStore["delete"](id2);
    return new Promise(function(res) {
      deleteRequest.onsuccess = function() {
        return res();
      };
    });
  }));
}
function getOldMessages(db2, ttl) {
  var olderThen = Date.now() - ttl;
  var tx = db2.transaction(OBJECT_STORE_ID, "readonly", TRANSACTION_SETTINGS);
  var objectStore = tx.objectStore(OBJECT_STORE_ID);
  var ret = [];
  return new Promise(function(res) {
    objectStore.openCursor().onsuccess = function(ev) {
      var cursor = ev.target.result;
      if (cursor) {
        var msgObk = cursor.value;
        if (msgObk.time < olderThen) {
          ret.push(msgObk);
          cursor["continue"]();
        } else {
          commitIndexedDBTransaction(tx);
          res(ret);
        }
      } else {
        res(ret);
      }
    };
  });
}
function cleanOldMessages(channelState) {
  return getOldMessages(channelState.db, channelState.options.idb.ttl).then(function(tooOld) {
    return removeMessagesById(channelState, tooOld.map(function(msg) {
      return msg.id;
    }));
  });
}
function create$5(channelName, options) {
  options = fillOptionsWithDefaults(options);
  return createDatabase(channelName).then(function(db2) {
    var state = {
      closed: false,
      lastCursorId: 0,
      channelName,
      options,
      uuid: randomToken(),
      /**
       * emittedMessagesIds
       * contains all messages that have been emitted before
       * @type {ObliviousSet}
       */
      eMIs: new ObliviousSet(options.idb.ttl * 2),
      // ensures we do not read messages in parallel
      writeBlockPromise: PROMISE_RESOLVED_VOID,
      messagesCallback: null,
      readQueuePromises: [],
      db: db2
    };
    db2.onclose = function() {
      state.closed = true;
      if (options.idb.onclose)
        options.idb.onclose();
    };
    _readLoop(state);
    return state;
  });
}
function _readLoop(state) {
  if (state.closed)
    return;
  readNewMessages(state).then(function() {
    return sleep(state.options.idb.fallbackInterval);
  }).then(function() {
    return _readLoop(state);
  });
}
function _filterMessage(msgObj, state) {
  if (msgObj.uuid === state.uuid)
    return false;
  if (state.eMIs.has(msgObj.id))
    return false;
  if (msgObj.data.time < state.messagesCallbackTime)
    return false;
  return true;
}
function readNewMessages(state) {
  if (state.closed)
    return PROMISE_RESOLVED_VOID;
  if (!state.messagesCallback)
    return PROMISE_RESOLVED_VOID;
  return getMessagesHigherThan(state.db, state.lastCursorId).then(function(newerMessages) {
    var useMessages = newerMessages.filter(function(msgObj) {
      return !!msgObj;
    }).map(function(msgObj) {
      if (msgObj.id > state.lastCursorId) {
        state.lastCursorId = msgObj.id;
      }
      return msgObj;
    }).filter(function(msgObj) {
      return _filterMessage(msgObj, state);
    }).sort(function(msgObjA, msgObjB) {
      return msgObjA.time - msgObjB.time;
    });
    useMessages.forEach(function(msgObj) {
      if (state.messagesCallback) {
        state.eMIs.add(msgObj.id);
        state.messagesCallback(msgObj.data);
      }
    });
    return PROMISE_RESOLVED_VOID;
  });
}
function close$2(channelState) {
  channelState.closed = true;
  channelState.db.close();
}
function postMessage$2(channelState, messageJson) {
  channelState.writeBlockPromise = channelState.writeBlockPromise.then(function() {
    return writeMessage(channelState.db, channelState.uuid, messageJson);
  }).then(function() {
    if (randomInt(0, 10) === 0) {
      cleanOldMessages(channelState);
    }
  });
  return channelState.writeBlockPromise;
}
function onMessage$2(channelState, fn, time) {
  channelState.messagesCallbackTime = time;
  channelState.messagesCallback = fn;
  readNewMessages(channelState);
}
function canBeUsed$2() {
  return !!getIdb();
}
function averageResponseTime$2(options) {
  return options.idb.fallbackInterval * 2;
}
var IndexedDBMethod = {
  create: create$5,
  close: close$2,
  onMessage: onMessage$2,
  postMessage: postMessage$2,
  canBeUsed: canBeUsed$2,
  type: type$2,
  averageResponseTime: averageResponseTime$2,
  microSeconds: microSeconds$2
};
var microSeconds$1 = microSeconds$4;
var KEY_PREFIX = "pubkey.broadcastChannel-";
var type$1 = "localstorage";
function getLocalStorage() {
  var localStorage2;
  if (typeof window === "undefined")
    return null;
  try {
    localStorage2 = window.localStorage;
    localStorage2 = window["ie8-eventlistener/storage"] || window.localStorage;
  } catch (e2) {
  }
  return localStorage2;
}
function storageKey(channelName) {
  return KEY_PREFIX + channelName;
}
function postMessage$1(channelState, messageJson) {
  return new Promise(function(res) {
    sleep().then(function() {
      var key = storageKey(channelState.channelName);
      var writeObj = {
        token: randomToken(),
        time: Date.now(),
        data: messageJson,
        uuid: channelState.uuid
      };
      var value = JSON.stringify(writeObj);
      getLocalStorage().setItem(key, value);
      var ev = document.createEvent("Event");
      ev.initEvent("storage", true, true);
      ev.key = key;
      ev.newValue = value;
      window.dispatchEvent(ev);
      res();
    });
  });
}
function addStorageEventListener(channelName, fn) {
  var key = storageKey(channelName);
  var listener2 = function listener3(ev) {
    if (ev.key === key) {
      fn(JSON.parse(ev.newValue));
    }
  };
  window.addEventListener("storage", listener2);
  return listener2;
}
function removeStorageEventListener(listener2) {
  window.removeEventListener("storage", listener2);
}
function create$4(channelName, options) {
  options = fillOptionsWithDefaults(options);
  if (!canBeUsed$1()) {
    throw new Error("BroadcastChannel: localstorage cannot be used");
  }
  var uuid = randomToken();
  var eMIs = new ObliviousSet(options.localstorage.removeTimeout);
  var state = {
    channelName,
    uuid,
    eMIs
    // emittedMessagesIds
  };
  state.listener = addStorageEventListener(channelName, function(msgObj) {
    if (!state.messagesCallback)
      return;
    if (msgObj.uuid === uuid)
      return;
    if (!msgObj.token || eMIs.has(msgObj.token))
      return;
    if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime)
      return;
    eMIs.add(msgObj.token);
    state.messagesCallback(msgObj.data);
  });
  return state;
}
function close$1(channelState) {
  removeStorageEventListener(channelState.listener);
}
function onMessage$1(channelState, fn, time) {
  channelState.messagesCallbackTime = time;
  channelState.messagesCallback = fn;
}
function canBeUsed$1() {
  var ls = getLocalStorage();
  if (!ls)
    return false;
  try {
    var key = "__broadcastchannel_check";
    ls.setItem(key, "works");
    ls.removeItem(key);
  } catch (e2) {
    return false;
  }
  return true;
}
function averageResponseTime$1() {
  var defaultTime = 120;
  var userAgent = navigator.userAgent.toLowerCase();
  if (userAgent.includes("safari") && !userAgent.includes("chrome")) {
    return defaultTime * 2;
  }
  return defaultTime;
}
var LocalstorageMethod = {
  create: create$4,
  close: close$1,
  onMessage: onMessage$1,
  postMessage: postMessage$1,
  canBeUsed: canBeUsed$1,
  type: type$1,
  averageResponseTime: averageResponseTime$1,
  microSeconds: microSeconds$1
};
var microSeconds = microSeconds$4;
var type = "simulate";
var SIMULATE_CHANNELS = /* @__PURE__ */ new Set();
function create$3(channelName) {
  var state = {
    time: microSeconds(),
    name: channelName,
    messagesCallback: null
  };
  SIMULATE_CHANNELS.add(state);
  return state;
}
function close(channelState) {
  SIMULATE_CHANNELS["delete"](channelState);
}
var SIMULATE_DELAY_TIME = 5;
function postMessage(channelState, messageJson) {
  return new Promise(function(res) {
    return setTimeout(function() {
      var channelArray = Array.from(SIMULATE_CHANNELS);
      channelArray.forEach(function(channel) {
        if (channel.name === channelState.name && // has same name
        channel !== channelState && // not own channel
        !!channel.messagesCallback && // has subscribers
        channel.time < messageJson.time) {
          channel.messagesCallback(messageJson);
        }
      });
      res();
    }, SIMULATE_DELAY_TIME);
  });
}
function onMessage(channelState, fn) {
  channelState.messagesCallback = fn;
}
function canBeUsed() {
  return true;
}
function averageResponseTime() {
  return SIMULATE_DELAY_TIME;
}
var SimulateMethod = {
  create: create$3,
  close,
  onMessage,
  postMessage,
  canBeUsed,
  type,
  averageResponseTime,
  microSeconds
};
var METHODS = [
  NativeMethod,
  // fastest
  IndexedDBMethod,
  LocalstorageMethod
];
function chooseMethod(options) {
  var chooseMethods = [].concat(options.methods, METHODS).filter(Boolean);
  if (options.type) {
    if (options.type === "simulate") {
      return SimulateMethod;
    }
    var ret = chooseMethods.find(function(m2) {
      return m2.type === options.type;
    });
    if (!ret)
      throw new Error("method-type " + options.type + " not found");
    else
      return ret;
  }
  if (!options.webWorkerSupport) {
    chooseMethods = chooseMethods.filter(function(m2) {
      return m2.type !== "idb";
    });
  }
  var useMethod = chooseMethods.find(function(method) {
    return method.canBeUsed();
  });
  if (!useMethod) {
    throw new Error("No usable method found in " + JSON.stringify(METHODS.map(function(m2) {
      return m2.type;
    })));
  } else {
    return useMethod;
  }
}
var OPEN_BROADCAST_CHANNELS = /* @__PURE__ */ new Set();
var lastId = 0;
var BroadcastChannel$1 = function BroadcastChannel2(name, options) {
  this.id = lastId++;
  OPEN_BROADCAST_CHANNELS.add(this);
  this.name = name;
  if (ENFORCED_OPTIONS) {
    options = ENFORCED_OPTIONS;
  }
  this.options = fillOptionsWithDefaults(options);
  this.method = chooseMethod(this.options);
  this._iL = false;
  this._onML = null;
  this._addEL = {
    message: [],
    internal: []
  };
  this._uMP = /* @__PURE__ */ new Set();
  this._befC = [];
  this._prepP = null;
  _prepareChannel(this);
};
BroadcastChannel$1._pubkey = true;
var ENFORCED_OPTIONS;
BroadcastChannel$1.prototype = {
  postMessage: function postMessage2(msg) {
    if (this.closed) {
      throw new Error("BroadcastChannel.postMessage(): Cannot post message after channel has closed " + /**
       * In the past when this error appeared, it was really hard to debug.
       * So now we log the msg together with the error so it at least
       * gives some clue about where in your application this happens.
       */
      JSON.stringify(msg));
    }
    return _post(this, "message", msg);
  },
  postInternal: function postInternal(msg) {
    return _post(this, "internal", msg);
  },
  set onmessage(fn) {
    var time = this.method.microSeconds();
    var listenObj = {
      time,
      fn
    };
    _removeListenerObject(this, "message", this._onML);
    if (fn && typeof fn === "function") {
      this._onML = listenObj;
      _addListenerObject(this, "message", listenObj);
    } else {
      this._onML = null;
    }
  },
  addEventListener: function addEventListener2(type2, fn) {
    var time = this.method.microSeconds();
    var listenObj = {
      time,
      fn
    };
    _addListenerObject(this, type2, listenObj);
  },
  removeEventListener: function removeEventListener(type2, fn) {
    var obj = this._addEL[type2].find(function(obj2) {
      return obj2.fn === fn;
    });
    _removeListenerObject(this, type2, obj);
  },
  close: function close2() {
    var _this = this;
    if (this.closed) {
      return;
    }
    OPEN_BROADCAST_CHANNELS["delete"](this);
    this.closed = true;
    var awaitPrepare = this._prepP ? this._prepP : PROMISE_RESOLVED_VOID;
    this._onML = null;
    this._addEL.message = [];
    return awaitPrepare.then(function() {
      return Promise.all(Array.from(_this._uMP));
    }).then(function() {
      return Promise.all(_this._befC.map(function(fn) {
        return fn();
      }));
    }).then(function() {
      return _this.method.close(_this._state);
    });
  },
  get type() {
    return this.method.type;
  },
  get isClosed() {
    return this.closed;
  }
};
function _post(broadcastChannel, type2, msg) {
  var time = broadcastChannel.method.microSeconds();
  var msgObj = {
    time,
    type: type2,
    data: msg
  };
  var awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : PROMISE_RESOLVED_VOID;
  return awaitPrepare.then(function() {
    var sendPromise = broadcastChannel.method.postMessage(broadcastChannel._state, msgObj);
    broadcastChannel._uMP.add(sendPromise);
    sendPromise["catch"]().then(function() {
      return broadcastChannel._uMP["delete"](sendPromise);
    });
    return sendPromise;
  });
}
function _prepareChannel(channel) {
  var maybePromise = channel.method.create(channel.name, channel.options);
  if (isPromise(maybePromise)) {
    channel._prepP = maybePromise;
    maybePromise.then(function(s) {
      channel._state = s;
    });
  } else {
    channel._state = maybePromise;
  }
}
function _hasMessageListeners(channel) {
  if (channel._addEL.message.length > 0)
    return true;
  if (channel._addEL.internal.length > 0)
    return true;
  return false;
}
function _addListenerObject(channel, type2, obj) {
  channel._addEL[type2].push(obj);
  _startListening(channel);
}
function _removeListenerObject(channel, type2, obj) {
  channel._addEL[type2] = channel._addEL[type2].filter(function(o) {
    return o !== obj;
  });
  _stopListening(channel);
}
function _startListening(channel) {
  if (!channel._iL && _hasMessageListeners(channel)) {
    var listenerFn = function listenerFn2(msgObj) {
      channel._addEL[msgObj.type].forEach(function(listenerObject) {
        if (msgObj.time >= listenerObject.time) {
          listenerObject.fn(msgObj.data);
        }
      });
    };
    var time = channel.method.microSeconds();
    if (channel._prepP) {
      channel._prepP.then(function() {
        channel._iL = true;
        channel.method.onMessage(channel._state, listenerFn, time);
      });
    } else {
      channel._iL = true;
      channel.method.onMessage(channel._state, listenerFn, time);
    }
  }
}
function _stopListening(channel) {
  if (channel._iL && !_hasMessageListeners(channel)) {
    channel._iL = false;
    var time = channel.method.microSeconds();
    channel.method.onMessage(channel._state, null, time);
  }
}
var BROADCAST_CHANNEL_BY_TOKEN = /* @__PURE__ */ new Map();
function getBroadcastChannelReference(storageName, databaseInstanceToken, databaseName, refObject) {
  var state = BROADCAST_CHANNEL_BY_TOKEN.get(databaseInstanceToken);
  if (!state) {
    state = {
      /**
       * We have to use the databaseName instead of the databaseInstanceToken
       * in the BroadcastChannel name because different instances must end with the same
       * channel name to be able to broadcast messages between each other.
       */
      bc: new BroadcastChannel$1(["RxDB:", storageName, databaseName].join("|")),
      refs: /* @__PURE__ */ new Set()
    };
    BROADCAST_CHANNEL_BY_TOKEN.set(databaseInstanceToken, state);
  }
  state.refs.add(refObject);
  return state.bc;
}
function removeBroadcastChannelReference(databaseInstanceToken, refObject) {
  var state = BROADCAST_CHANNEL_BY_TOKEN.get(databaseInstanceToken);
  if (!state) {
    return;
  }
  state.refs.delete(refObject);
  if (state.refs.size === 0) {
    BROADCAST_CHANNEL_BY_TOKEN.delete(databaseInstanceToken);
    return state.bc.close();
  }
}
function addRxStorageMultiInstanceSupport(storageName, instanceCreationParams, instance, providedBroadcastChannel) {
  if (!instanceCreationParams.multiInstance) {
    return;
  }
  var broadcastChannel = providedBroadcastChannel ? providedBroadcastChannel : getBroadcastChannelReference(storageName, instanceCreationParams.databaseInstanceToken, instance.databaseName, instance);
  var changesFromOtherInstances$ = new cjs.Subject();
  var eventListener = (msg) => {
    if (msg.storageName === storageName && msg.databaseName === instanceCreationParams.databaseName && msg.collectionName === instanceCreationParams.collectionName && msg.version === instanceCreationParams.schema.version) {
      changesFromOtherInstances$.next(msg.eventBulk);
    }
  };
  broadcastChannel.addEventListener("message", eventListener);
  var oldChangestream$ = instance.changeStream();
  var closed = false;
  var sub = oldChangestream$.subscribe((eventBulk) => {
    if (closed) {
      return;
    }
    broadcastChannel.postMessage({
      storageName,
      databaseName: instanceCreationParams.databaseName,
      collectionName: instanceCreationParams.collectionName,
      version: instanceCreationParams.schema.version,
      eventBulk
    });
  });
  instance.changeStream = function() {
    return changesFromOtherInstances$.asObservable().pipe(mergeWith$2(oldChangestream$));
  };
  var oldClose = instance.close.bind(instance);
  instance.close = async function() {
    closed = true;
    sub.unsubscribe();
    broadcastChannel.removeEventListener("message", eventListener);
    if (!providedBroadcastChannel) {
      await removeBroadcastChannelReference(instanceCreationParams.databaseInstanceToken, instance);
    }
    return oldClose();
  };
  var oldRemove = instance.remove.bind(instance);
  instance.remove = async function() {
    closed = true;
    sub.unsubscribe();
    broadcastChannel.removeEventListener("message", eventListener);
    if (!providedBroadcastChannel) {
      await removeBroadcastChannelReference(instanceCreationParams.databaseInstanceToken, instance);
    }
    return oldRemove();
  };
}
var dexie_min = { exports: {} };
(function(module, exports) {
  (function(e2, t2) {
    module.exports = t2();
  })(commonjsGlobal, function() {
    var s = function(e3, t3) {
      return (s = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e4, t4) {
        e4.__proto__ = t4;
      } || function(e4, t4) {
        for (var n3 in t4)
          Object.prototype.hasOwnProperty.call(t4, n3) && (e4[n3] = t4[n3]);
      })(e3, t3);
    };
    var _2 = function() {
      return (_2 = Object.assign || function(e3) {
        for (var t3, n3 = 1, r3 = arguments.length; n3 < r3; n3++)
          for (var i2 in t3 = arguments[n3])
            Object.prototype.hasOwnProperty.call(t3, i2) && (e3[i2] = t3[i2]);
        return e3;
      }).apply(this, arguments);
    };
    function i(e3, t3, n3) {
      if (n3 || 2 === arguments.length)
        for (var r3, i2 = 0, o2 = t3.length; i2 < o2; i2++)
          !r3 && i2 in t3 || ((r3 = r3 || Array.prototype.slice.call(t3, 0, i2))[i2] = t3[i2]);
      return e3.concat(r3 || Array.prototype.slice.call(t3));
    }
    var f2 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : commonjsGlobal, k2 = Object.keys, g2 = Array.isArray;
    function a(t3, n3) {
      return "object" != typeof n3 || k2(n3).forEach(function(e3) {
        t3[e3] = n3[e3];
      }), t3;
    }
    "undefined" == typeof Promise || f2.Promise || (f2.Promise = Promise);
    var c = Object.getPrototypeOf, n2 = {}.hasOwnProperty;
    function m2(e3, t3) {
      return n2.call(e3, t3);
    }
    function r2(t3, n3) {
      "function" == typeof n3 && (n3 = n3(c(t3))), ("undefined" == typeof Reflect ? k2 : Reflect.ownKeys)(n3).forEach(function(e3) {
        l2(t3, e3, n3[e3]);
      });
    }
    var u2 = Object.defineProperty;
    function l2(e3, t3, n3, r3) {
      u2(e3, t3, a(n3 && m2(n3, "get") && "function" == typeof n3.get ? { get: n3.get, set: n3.set, configurable: true } : { value: n3, configurable: true, writable: true }, r3));
    }
    function o(t3) {
      return { from: function(e3) {
        return t3.prototype = Object.create(e3.prototype), l2(t3.prototype, "constructor", t3), { extend: r2.bind(null, t3.prototype) };
      } };
    }
    var h2 = Object.getOwnPropertyDescriptor;
    function d(e3, t3) {
      return h2(e3, t3) || (e3 = c(e3)) && d(e3, t3);
    }
    var p2 = [].slice;
    function y2(e3, t3, n3) {
      return p2.call(e3, t3, n3);
    }
    function v2(e3, t3) {
      return t3(e3);
    }
    function b2(e3) {
      if (!e3)
        throw new Error("Assertion Failed");
    }
    function w2(e3) {
      f2.setImmediate ? setImmediate(e3) : setTimeout(e3, 0);
    }
    function x2(e3, t3) {
      if ("string" == typeof t3 && m2(e3, t3))
        return e3[t3];
      if (!t3)
        return e3;
      if ("string" != typeof t3) {
        for (var n3 = [], r3 = 0, i2 = t3.length; r3 < i2; ++r3) {
          var o2 = x2(e3, t3[r3]);
          n3.push(o2);
        }
        return n3;
      }
      var a2 = t3.indexOf(".");
      if (-1 !== a2) {
        var u3 = e3[t3.substr(0, a2)];
        return void 0 === u3 ? void 0 : x2(u3, t3.substr(a2 + 1));
      }
    }
    function O2(e3, t3, n3) {
      if (e3 && void 0 !== t3 && !("isFrozen" in Object && Object.isFrozen(e3)))
        if ("string" != typeof t3 && "length" in t3) {
          b2("string" != typeof n3 && "length" in n3);
          for (var r3 = 0, i2 = t3.length; r3 < i2; ++r3)
            O2(e3, t3[r3], n3[r3]);
        } else {
          var o2, a2, u3 = t3.indexOf(".");
          -1 !== u3 ? (o2 = t3.substr(0, u3), "" === (a2 = t3.substr(u3 + 1)) ? void 0 === n3 ? g2(e3) && !isNaN(parseInt(o2)) ? e3.splice(o2, 1) : delete e3[o2] : e3[o2] = n3 : O2(u3 = !(u3 = e3[o2]) || !m2(e3, o2) ? e3[o2] = {} : u3, a2, n3)) : void 0 === n3 ? g2(e3) && !isNaN(parseInt(t3)) ? e3.splice(t3, 1) : delete e3[t3] : e3[t3] = n3;
        }
    }
    function P2(e3) {
      var t3, n3 = {};
      for (t3 in e3)
        m2(e3, t3) && (n3[t3] = e3[t3]);
      return n3;
    }
    var t2 = [].concat;
    function E2(e3) {
      return t2.apply([], e3);
    }
    var e2 = "Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(E2([8, 16, 32, 64].map(function(t3) {
      return ["Int", "Uint", "Float"].map(function(e3) {
        return e3 + t3 + "Array";
      });
    }))).filter(function(e3) {
      return f2[e3];
    }), K2 = new Set(e2.map(function(e3) {
      return f2[e3];
    }));
    var S2 = null;
    function j2(e3) {
      S2 = /* @__PURE__ */ new WeakMap();
      e3 = function e4(t3) {
        if (!t3 || "object" != typeof t3)
          return t3;
        var n3 = S2.get(t3);
        if (n3)
          return n3;
        if (g2(t3)) {
          n3 = [], S2.set(t3, n3);
          for (var r3 = 0, i2 = t3.length; r3 < i2; ++r3)
            n3.push(e4(t3[r3]));
        } else if (K2.has(t3.constructor))
          n3 = t3;
        else {
          var o2, a2 = c(t3);
          for (o2 in n3 = a2 === Object.prototype ? {} : Object.create(a2), S2.set(t3, n3), t3)
            m2(t3, o2) && (n3[o2] = e4(t3[o2]));
        }
        return n3;
      }(e3);
      return S2 = null, e3;
    }
    var A2 = {}.toString;
    function C2(e3) {
      return A2.call(e3).slice(8, -1);
    }
    var q2 = "undefined" != typeof Symbol ? Symbol.iterator : "@@iterator", D2 = "symbol" == typeof q2 ? function(e3) {
      var t3;
      return null != e3 && (t3 = e3[q2]) && t3.apply(e3);
    } : function() {
      return null;
    };
    function T2(e3, t3) {
      t3 = e3.indexOf(t3);
      return 0 <= t3 && e3.splice(t3, 1), 0 <= t3;
    }
    var I2 = {};
    function R2(e3) {
      var t3, n3, r3, i2;
      if (1 === arguments.length) {
        if (g2(e3))
          return e3.slice();
        if (this === I2 && "string" == typeof e3)
          return [e3];
        if (i2 = D2(e3)) {
          for (n3 = []; !(r3 = i2.next()).done; )
            n3.push(r3.value);
          return n3;
        }
        if (null == e3)
          return [e3];
        if ("number" != typeof (t3 = e3.length))
          return [e3];
        for (n3 = new Array(t3); t3--; )
          n3[t3] = e3[t3];
        return n3;
      }
      for (t3 = arguments.length, n3 = new Array(t3); t3--; )
        n3[t3] = arguments[t3];
      return n3;
    }
    var B2 = "undefined" != typeof Symbol ? function(e3) {
      return "AsyncFunction" === e3[Symbol.toStringTag];
    } : function() {
      return false;
    }, F2 = "undefined" != typeof location && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
    function M2(e3, t3) {
      F2 = e3, N2 = t3;
    }
    var N2 = function() {
      return true;
    }, L2 = !new Error("").stack;
    function U2() {
      if (L2)
        try {
          throw new Error();
        } catch (e3) {
          return e3;
        }
      return new Error();
    }
    function z2(e3, t3) {
      var n3 = e3.stack;
      return n3 ? (t3 = t3 || 0, 0 === n3.indexOf(e3.name) && (t3 += (e3.name + e3.message).split("\n").length), n3.split("\n").slice(t3).filter(N2).map(function(e4) {
        return "\n" + e4;
      }).join("")) : "";
    }
    var V2 = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], W2 = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(V2), Y2 = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
    function Q2(e3, t3) {
      this._e = U2(), this.name = e3, this.message = t3;
    }
    function G2(e3, t3) {
      return e3 + ". Errors: " + Object.keys(t3).map(function(e4) {
        return t3[e4].toString();
      }).filter(function(e4, t4, n3) {
        return n3.indexOf(e4) === t4;
      }).join("\n");
    }
    function H2(e3, t3, n3, r3) {
      this._e = U2(), this.failures = t3, this.failedKeys = r3, this.successCount = n3, this.message = G2(e3, t3);
    }
    function X2(e3, t3) {
      this._e = U2(), this.name = "BulkError", this.failures = Object.keys(t3).map(function(e4) {
        return t3[e4];
      }), this.failuresByPos = t3, this.message = G2(e3, this.failures);
    }
    o(Q2).from(Error).extend({ stack: { get: function() {
      return this._stack || (this._stack = this.name + ": " + this.message + z2(this._e, 2));
    } }, toString: function() {
      return this.name + ": " + this.message;
    } }), o(H2).from(Q2), o(X2).from(Q2);
    var J2 = W2.reduce(function(e3, t3) {
      return e3[t3] = t3 + "Error", e3;
    }, {}), $2 = Q2, Z2 = W2.reduce(function(e3, n3) {
      var r3 = n3 + "Error";
      function t3(e4, t4) {
        this._e = U2(), this.name = r3, e4 ? "string" == typeof e4 ? (this.message = "".concat(e4).concat(t4 ? "\n " + t4 : ""), this.inner = t4 || null) : "object" == typeof e4 && (this.message = "".concat(e4.name, " ").concat(e4.message), this.inner = e4) : (this.message = Y2[n3] || r3, this.inner = null);
      }
      return o(t3).from($2), e3[n3] = t3, e3;
    }, {});
    Z2.Syntax = SyntaxError, Z2.Type = TypeError, Z2.Range = RangeError;
    var ee2 = V2.reduce(function(e3, t3) {
      return e3[t3 + "Error"] = Z2[t3], e3;
    }, {});
    var te2 = W2.reduce(function(e3, t3) {
      return -1 === ["Syntax", "Type", "Range"].indexOf(t3) && (e3[t3 + "Error"] = Z2[t3]), e3;
    }, {});
    function ne2() {
    }
    function re2(e3) {
      return e3;
    }
    function ie2(t3, n3) {
      return null == t3 || t3 === re2 ? n3 : function(e3) {
        return n3(t3(e3));
      };
    }
    function oe2(e3, t3) {
      return function() {
        e3.apply(this, arguments), t3.apply(this, arguments);
      };
    }
    function ae2(i2, o2) {
      return i2 === ne2 ? o2 : function() {
        var e3 = i2.apply(this, arguments);
        void 0 !== e3 && (arguments[0] = e3);
        var t3 = this.onsuccess, n3 = this.onerror;
        this.onsuccess = null, this.onerror = null;
        var r3 = o2.apply(this, arguments);
        return t3 && (this.onsuccess = this.onsuccess ? oe2(t3, this.onsuccess) : t3), n3 && (this.onerror = this.onerror ? oe2(n3, this.onerror) : n3), void 0 !== r3 ? r3 : e3;
      };
    }
    function ue2(n3, r3) {
      return n3 === ne2 ? r3 : function() {
        n3.apply(this, arguments);
        var e3 = this.onsuccess, t3 = this.onerror;
        this.onsuccess = this.onerror = null, r3.apply(this, arguments), e3 && (this.onsuccess = this.onsuccess ? oe2(e3, this.onsuccess) : e3), t3 && (this.onerror = this.onerror ? oe2(t3, this.onerror) : t3);
      };
    }
    function se2(i2, o2) {
      return i2 === ne2 ? o2 : function(e3) {
        var t3 = i2.apply(this, arguments);
        a(e3, t3);
        var n3 = this.onsuccess, r3 = this.onerror;
        this.onsuccess = null, this.onerror = null;
        e3 = o2.apply(this, arguments);
        return n3 && (this.onsuccess = this.onsuccess ? oe2(n3, this.onsuccess) : n3), r3 && (this.onerror = this.onerror ? oe2(r3, this.onerror) : r3), void 0 === t3 ? void 0 === e3 ? void 0 : e3 : a(t3, e3);
      };
    }
    function ce2(e3, t3) {
      return e3 === ne2 ? t3 : function() {
        return false !== t3.apply(this, arguments) && e3.apply(this, arguments);
      };
    }
    function le2(i2, o2) {
      return i2 === ne2 ? o2 : function() {
        var e3 = i2.apply(this, arguments);
        if (e3 && "function" == typeof e3.then) {
          for (var t3 = this, n3 = arguments.length, r3 = new Array(n3); n3--; )
            r3[n3] = arguments[n3];
          return e3.then(function() {
            return o2.apply(t3, r3);
          });
        }
        return o2.apply(this, arguments);
      };
    }
    te2.ModifyError = H2, te2.DexieError = Q2, te2.BulkError = X2;
    var fe2 = {}, he2 = 100, de2 = 100, e2 = "undefined" == typeof Promise ? [] : function() {
      var e3 = Promise.resolve();
      if ("undefined" == typeof crypto || !crypto.subtle)
        return [e3, c(e3), e3];
      var t3 = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
      return [t3, c(t3), e3];
    }(), V2 = e2[0], W2 = e2[1], e2 = e2[2], W2 = W2 && W2.then, pe2 = V2 && V2.constructor, ye2 = !!e2, ve2 = false;
    var me2 = function(e3, t3) {
      Ee2.push([e3, t3]), ge2 && (queueMicrotask(Be2), ge2 = false);
    }, be2 = true, ge2 = true, we2 = [], _e2 = [], ke2 = null, xe2 = re2, Oe2 = { id: "global", global: true, ref: 0, unhandleds: [], onunhandled: ne2, pgp: false, env: {}, finalize: ne2 }, Pe2 = Oe2, Ee2 = [], Ke2 = 0, Se2 = [];
    function je2(e3) {
      if ("object" != typeof this)
        throw new TypeError("Promises must be constructed via new");
      this._listeners = [], this._lib = false;
      var t3 = this._PSD = Pe2;
      if (F2 && (this._stackHolder = U2(), this._prev = null, this._numPrev = 0), "function" != typeof e3) {
        if (e3 !== fe2)
          throw new TypeError("Not a function");
        return this._state = arguments[1], this._value = arguments[2], void (false === this._state && qe2(this, this._value));
      }
      this._state = null, this._value = null, ++t3.ref, function t4(r3, e4) {
        try {
          e4(function(n3) {
            if (null === r3._state) {
              if (n3 === r3)
                throw new TypeError("A promise cannot be resolved with itself.");
              var e5 = r3._lib && Fe2();
              n3 && "function" == typeof n3.then ? t4(r3, function(e6, t5) {
                n3 instanceof je2 ? n3._then(e6, t5) : n3.then(e6, t5);
              }) : (r3._state = true, r3._value = n3, De2(r3)), e5 && Me2();
            }
          }, qe2.bind(null, r3));
        } catch (e5) {
          qe2(r3, e5);
        }
      }(this, e3);
    }
    var Ae2 = { get: function() {
      var u3 = Pe2, t3 = Qe2;
      function e3(n3, r3) {
        var i2 = this, o2 = !u3.global && (u3 !== Pe2 || t3 !== Qe2), a2 = o2 && !Je2(), e4 = new je2(function(e5, t4) {
          Te2(i2, new Ce2(rt2(n3, u3, o2, a2), rt2(r3, u3, o2, a2), e5, t4, u3));
        });
        return F2 && Re2(e4, this), e4;
      }
      return e3.prototype = fe2, e3;
    }, set: function(e3) {
      l2(this, "then", e3 && e3.prototype === fe2 ? Ae2 : { get: function() {
        return e3;
      }, set: Ae2.set });
    } };
    function Ce2(e3, t3, n3, r3, i2) {
      this.onFulfilled = "function" == typeof e3 ? e3 : null, this.onRejected = "function" == typeof t3 ? t3 : null, this.resolve = n3, this.reject = r3, this.psd = i2;
    }
    function qe2(t3, n3) {
      var e3, r3;
      _e2.push(n3), null === t3._state && (e3 = t3._lib && Fe2(), n3 = xe2(n3), t3._state = false, t3._value = n3, F2 && null !== n3 && "object" == typeof n3 && !n3._promise && function(e4, t4, n4) {
        try {
          e4.apply(null, n4);
        } catch (e5) {
          t4 && t4(e5);
        }
      }(function() {
        var e4 = d(n3, "stack");
        n3._promise = t3, l2(n3, "stack", { get: function() {
          return ve2 ? e4 && (e4.get ? e4.get.apply(n3) : e4.value) : t3.stack;
        } });
      }), r3 = t3, we2.some(function(e4) {
        return e4._value === r3._value;
      }) || we2.push(r3), De2(t3), e3 && Me2());
    }
    function De2(e3) {
      var t3 = e3._listeners;
      e3._listeners = [];
      for (var n3 = 0, r3 = t3.length; n3 < r3; ++n3)
        Te2(e3, t3[n3]);
      var i2 = e3._PSD;
      --i2.ref || i2.finalize(), 0 === Ke2 && (++Ke2, me2(function() {
        0 == --Ke2 && Ne2();
      }, []));
    }
    function Te2(e3, t3) {
      if (null !== e3._state) {
        var n3 = e3._state ? t3.onFulfilled : t3.onRejected;
        if (null === n3)
          return (e3._state ? t3.resolve : t3.reject)(e3._value);
        ++t3.psd.ref, ++Ke2, me2(Ie2, [n3, e3, t3]);
      } else
        e3._listeners.push(t3);
    }
    function Ie2(e3, t3, n3) {
      try {
        var r3, i2 = (ke2 = t3)._value;
        t3._state ? r3 = e3(i2) : (_e2.length && (_e2 = []), r3 = e3(i2), -1 === _e2.indexOf(i2) && function(e4) {
          var t4 = we2.length;
          for (; t4; )
            if (we2[--t4]._value === e4._value)
              return we2.splice(t4, 1);
        }(t3)), n3.resolve(r3);
      } catch (e4) {
        n3.reject(e4);
      } finally {
        ke2 = null, 0 == --Ke2 && Ne2(), --n3.psd.ref || n3.psd.finalize();
      }
    }
    function Re2(e3, t3) {
      var n3 = t3 ? t3._numPrev + 1 : 0;
      n3 < he2 && (e3._prev = t3, e3._numPrev = n3);
    }
    function Be2() {
      nt2(Oe2, function() {
        Fe2() && Me2();
      });
    }
    function Fe2() {
      var e3 = be2;
      return ge2 = be2 = false, e3;
    }
    function Me2() {
      var e3, t3, n3;
      do {
        for (; 0 < Ee2.length; )
          for (e3 = Ee2, Ee2 = [], n3 = e3.length, t3 = 0; t3 < n3; ++t3) {
            var r3 = e3[t3];
            r3[0].apply(null, r3[1]);
          }
      } while (0 < Ee2.length);
      ge2 = be2 = true;
    }
    function Ne2() {
      var e3 = we2;
      we2 = [], e3.forEach(function(e4) {
        e4._PSD.onunhandled.call(null, e4._value, e4);
      });
      for (var t3 = Se2.slice(0), n3 = t3.length; n3; )
        t3[--n3]();
    }
    function Le2(e3) {
      return new je2(fe2, false, e3);
    }
    function Ue2(n3, r3) {
      var i2 = Pe2;
      return function() {
        var e3 = Fe2(), t3 = Pe2;
        try {
          return et(i2, true), n3.apply(this, arguments);
        } catch (e4) {
          r3 && r3(e4);
        } finally {
          et(t3, false), e3 && Me2();
        }
      };
    }
    r2(je2.prototype, { then: Ae2, _then: function(e3, t3) {
      Te2(this, new Ce2(null, null, e3, t3, Pe2));
    }, catch: function(e3) {
      if (1 === arguments.length)
        return this.then(null, e3);
      var t3 = e3, n3 = arguments[1];
      return "function" == typeof t3 ? this.then(null, function(e4) {
        return (e4 instanceof t3 ? n3 : Le2)(e4);
      }) : this.then(null, function(e4) {
        return (e4 && e4.name === t3 ? n3 : Le2)(e4);
      });
    }, finally: function(t3) {
      return this.then(function(e3) {
        return je2.resolve(t3()).then(function() {
          return e3;
        });
      }, function(e3) {
        return je2.resolve(t3()).then(function() {
          return Le2(e3);
        });
      });
    }, stack: { get: function() {
      if (this._stack)
        return this._stack;
      try {
        ve2 = true;
        var e3 = function e4(t3, n3, r3) {
          if (n3.length === r3)
            return n3;
          var i2 = "";
          {
            var o2, a2, u3;
            false === t3._state && (null != (o2 = t3._value) ? (a2 = o2.name || "Error", u3 = o2.message || o2, i2 = z2(o2, 0)) : (a2 = o2, u3 = ""), n3.push(a2 + (u3 ? ": " + u3 : "") + i2));
          }
          F2 && ((i2 = z2(t3._stackHolder, 2)) && -1 === n3.indexOf(i2) && n3.push(i2), t3._prev && e4(t3._prev, n3, r3));
          return n3;
        }(this, [], 20).join("\nFrom previous: ");
        return null !== this._state && (this._stack = e3), e3;
      } finally {
        ve2 = false;
      }
    } }, timeout: function(r3, i2) {
      var o2 = this;
      return r3 < 1 / 0 ? new je2(function(e3, t3) {
        var n3 = setTimeout(function() {
          return t3(new Z2.Timeout(i2));
        }, r3);
        o2.then(e3, t3).finally(clearTimeout.bind(null, n3));
      }) : this;
    } }), "undefined" != typeof Symbol && Symbol.toStringTag && l2(je2.prototype, Symbol.toStringTag, "Dexie.Promise"), Oe2.env = tt(), r2(je2, { all: function() {
      var o2 = R2.apply(null, arguments).map($e2);
      return new je2(function(n3, r3) {
        0 === o2.length && n3([]);
        var i2 = o2.length;
        o2.forEach(function(e3, t3) {
          return je2.resolve(e3).then(function(e4) {
            o2[t3] = e4, --i2 || n3(o2);
          }, r3);
        });
      });
    }, resolve: function(n3) {
      if (n3 instanceof je2)
        return n3;
      if (n3 && "function" == typeof n3.then)
        return new je2(function(e4, t3) {
          n3.then(e4, t3);
        });
      var e3 = new je2(fe2, true, n3);
      return Re2(e3, ke2), e3;
    }, reject: Le2, race: function() {
      var e3 = R2.apply(null, arguments).map($e2);
      return new je2(function(t3, n3) {
        e3.map(function(e4) {
          return je2.resolve(e4).then(t3, n3);
        });
      });
    }, PSD: { get: function() {
      return Pe2;
    }, set: function(e3) {
      return Pe2 = e3;
    } }, totalEchoes: { get: function() {
      return Qe2;
    } }, newPSD: He2, usePSD: nt2, scheduler: { get: function() {
      return me2;
    }, set: function(e3) {
      me2 = e3;
    } }, rejectionMapper: { get: function() {
      return xe2;
    }, set: function(e3) {
      xe2 = e3;
    } }, follow: function(i2, n3) {
      return new je2(function(e3, t3) {
        return He2(function(n4, r3) {
          var e4 = Pe2;
          e4.unhandleds = [], e4.onunhandled = r3, e4.finalize = oe2(function() {
            var t4, e5 = this;
            t4 = function() {
              0 === e5.unhandleds.length ? n4() : r3(e5.unhandleds[0]);
            }, Se2.push(function e6() {
              t4(), Se2.splice(Se2.indexOf(e6), 1);
            }), ++Ke2, me2(function() {
              0 == --Ke2 && Ne2();
            }, []);
          }, e4.finalize), i2();
        }, n3, e3, t3);
      });
    } }), pe2 && (pe2.allSettled && l2(je2, "allSettled", function() {
      var e3 = R2.apply(null, arguments).map($e2);
      return new je2(function(n3) {
        0 === e3.length && n3([]);
        var r3 = e3.length, i2 = new Array(r3);
        e3.forEach(function(e4, t3) {
          return je2.resolve(e4).then(function(e5) {
            return i2[t3] = { status: "fulfilled", value: e5 };
          }, function(e5) {
            return i2[t3] = { status: "rejected", reason: e5 };
          }).then(function() {
            return --r3 || n3(i2);
          });
        });
      });
    }), pe2.any && "undefined" != typeof AggregateError && l2(je2, "any", function() {
      var e3 = R2.apply(null, arguments).map($e2);
      return new je2(function(n3, r3) {
        0 === e3.length && r3(new AggregateError([]));
        var i2 = e3.length, o2 = new Array(i2);
        e3.forEach(function(e4, t3) {
          return je2.resolve(e4).then(function(e5) {
            return n3(e5);
          }, function(e5) {
            o2[t3] = e5, --i2 || r3(new AggregateError(o2));
          });
        });
      });
    }));
    var ze = { awaits: 0, echoes: 0, id: 0 }, Ve2 = 0, We2 = [], Ye2 = 0, Qe2 = 0, Ge2 = 0;
    function He2(e3, t3, n3, r3) {
      var i2 = Pe2, o2 = Object.create(i2);
      o2.parent = i2, o2.ref = 0, o2.global = false, o2.id = ++Ge2, Oe2.env, o2.env = ye2 ? { Promise: je2, PromiseProp: { value: je2, configurable: true, writable: true }, all: je2.all, race: je2.race, allSettled: je2.allSettled, any: je2.any, resolve: je2.resolve, reject: je2.reject } : {}, t3 && a(o2, t3), ++i2.ref, o2.finalize = function() {
        --this.parent.ref || this.parent.finalize();
      };
      r3 = nt2(o2, e3, n3, r3);
      return 0 === o2.ref && o2.finalize(), r3;
    }
    function Xe2() {
      return ze.id || (ze.id = ++Ve2), ++ze.awaits, ze.echoes += de2, ze.id;
    }
    function Je2() {
      return !!ze.awaits && (0 == --ze.awaits && (ze.id = 0), ze.echoes = ze.awaits * de2, true);
    }
    function $e2(e3) {
      return ze.echoes && e3 && e3.constructor === pe2 ? (Xe2(), e3.then(function(e4) {
        return Je2(), e4;
      }, function(e4) {
        return Je2(), ot(e4);
      })) : e3;
    }
    function Ze2() {
      var e3 = We2[We2.length - 1];
      We2.pop(), et(e3, false);
    }
    function et(e3, t3) {
      var n3, r3 = Pe2;
      (t3 ? !ze.echoes || Ye2++ && e3 === Pe2 : !Ye2 || --Ye2 && e3 === Pe2) || queueMicrotask(t3 ? (function(e4) {
        ++Qe2, ze.echoes && 0 != --ze.echoes || (ze.echoes = ze.awaits = ze.id = 0), We2.push(Pe2), et(e4, true);
      }).bind(null, e3) : Ze2), e3 !== Pe2 && (Pe2 = e3, r3 === Oe2 && (Oe2.env = tt()), ye2 && (n3 = Oe2.env.Promise, t3 = e3.env, (r3.global || e3.global) && (Object.defineProperty(f2, "Promise", t3.PromiseProp), n3.all = t3.all, n3.race = t3.race, n3.resolve = t3.resolve, n3.reject = t3.reject, t3.allSettled && (n3.allSettled = t3.allSettled), t3.any && (n3.any = t3.any))));
    }
    function tt() {
      var e3 = f2.Promise;
      return ye2 ? { Promise: e3, PromiseProp: Object.getOwnPropertyDescriptor(f2, "Promise"), all: e3.all, race: e3.race, allSettled: e3.allSettled, any: e3.any, resolve: e3.resolve, reject: e3.reject } : {};
    }
    function nt2(e3, t3, n3, r3, i2) {
      var o2 = Pe2;
      try {
        return et(e3, true), t3(n3, r3, i2);
      } finally {
        et(o2, false);
      }
    }
    function rt2(t3, n3, r3, i2) {
      return "function" != typeof t3 ? t3 : function() {
        var e3 = Pe2;
        r3 && Xe2(), et(n3, true);
        try {
          return t3.apply(this, arguments);
        } finally {
          et(e3, false), i2 && queueMicrotask(Je2);
        }
      };
    }
    function it2(e3) {
      Promise === pe2 && 0 === ze.echoes ? 0 === Ye2 ? e3() : enqueueNativeMicroTask(e3) : setTimeout(e3, 0);
    }
    -1 === ("" + W2).indexOf("[native code]") && (Xe2 = Je2 = ne2);
    var ot = je2.reject;
    function at2(e3) {
      return !/(dexie\.js|dexie\.min\.js)/.test(e3);
    }
    var e2 = "4.0.1-beta.6", ut2 = String.fromCharCode(65535), st2 = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", ct2 = "String expected.", lt2 = [], ft = "undefined" != typeof navigator && /(MSIE|Trident|Edge)/.test(navigator.userAgent), ht = ft, dt2 = ft, pt2 = "__dbnames", yt = "readonly", vt = "readwrite";
    function mt(e3, t3) {
      return e3 ? t3 ? function() {
        return e3.apply(this, arguments) && t3.apply(this, arguments);
      } : e3 : t3;
    }
    var bt = { type: 3, lower: -1 / 0, lowerOpen: false, upper: [[]], upperOpen: false };
    function gt(t3) {
      return "string" != typeof t3 || /\./.test(t3) ? function(e3) {
        return e3;
      } : function(e3) {
        return void 0 === e3[t3] && t3 in e3 && delete (e3 = j2(e3))[t3], e3;
      };
    }
    function wt() {
      throw Z2.Type();
    }
    function _t(e3, t3) {
      try {
        var n3 = kt(e3), r3 = kt(t3);
        if (n3 !== r3)
          return "Array" === n3 ? 1 : "Array" === r3 ? -1 : "binary" === n3 ? 1 : "binary" === r3 ? -1 : "string" === n3 ? 1 : "string" === r3 ? -1 : "Date" === n3 ? 1 : "Date" !== r3 ? NaN : -1;
        switch (n3) {
          case "number":
          case "Date":
          case "string":
            return t3 < e3 ? 1 : e3 < t3 ? -1 : 0;
          case "binary":
            return function(e4, t4) {
              for (var n4 = e4.length, r4 = t4.length, i2 = n4 < r4 ? n4 : r4, o2 = 0; o2 < i2; ++o2)
                if (e4[o2] !== t4[o2])
                  return e4[o2] < t4[o2] ? -1 : 1;
              return n4 === r4 ? 0 : n4 < r4 ? -1 : 1;
            }(xt(e3), xt(t3));
          case "Array":
            return function(e4, t4) {
              for (var n4 = e4.length, r4 = t4.length, i2 = n4 < r4 ? n4 : r4, o2 = 0; o2 < i2; ++o2) {
                var a2 = _t(e4[o2], t4[o2]);
                if (0 !== a2)
                  return a2;
              }
              return n4 === r4 ? 0 : n4 < r4 ? -1 : 1;
            }(e3, t3);
        }
      } catch (e4) {
      }
      return NaN;
    }
    function kt(e3) {
      var t3 = typeof e3;
      if ("object" != t3)
        return t3;
      if (ArrayBuffer.isView(e3))
        return "binary";
      e3 = C2(e3);
      return "ArrayBuffer" === e3 ? "binary" : e3;
    }
    function xt(e3) {
      return e3 instanceof Uint8Array ? e3 : ArrayBuffer.isView(e3) ? new Uint8Array(e3.buffer, e3.byteOffset, e3.byteLength) : new Uint8Array(e3);
    }
    var Ot = (Pt.prototype._trans = function(e3, r3, t3) {
      var n3 = this._tx || Pe2.trans, i2 = this.name;
      function o2(e4, t4, n4) {
        if (!n4.schema[i2])
          throw new Z2.NotFound("Table " + i2 + " not part of transaction");
        return r3(n4.idbtrans, n4);
      }
      var a2 = Fe2();
      try {
        return n3 && n3.db._novip === this.db._novip ? n3 === Pe2.trans ? n3._promise(e3, o2, t3) : He2(function() {
          return n3._promise(e3, o2, t3);
        }, { trans: n3, transless: Pe2.transless || Pe2 }) : function t4(n4, r4, i3, o3) {
          if (n4.idbdb && (n4._state.openComplete || Pe2.letThrough || n4._vip)) {
            var a3 = n4._createTransaction(r4, i3, n4._dbSchema);
            try {
              a3.create(), n4._state.PR1398_maxLoop = 3;
            } catch (e4) {
              return e4.name === J2.InvalidState && n4.isOpen() && 0 < --n4._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), n4._close(), n4.open().then(function() {
                return t4(n4, r4, i3, o3);
              })) : ot(e4);
            }
            return a3._promise(r4, function(e4, t5) {
              return He2(function() {
                return Pe2.trans = a3, o3(e4, t5, a3);
              });
            }).then(function(e4) {
              if ("readwrite" === r4)
                try {
                  a3.idbtrans.commit();
                } catch (e5) {
                }
              return "readonly" === r4 ? e4 : a3._completion.then(function() {
                return e4;
              });
            });
          }
          if (n4._state.openComplete)
            return ot(new Z2.DatabaseClosed(n4._state.dbOpenError));
          if (!n4._state.isBeingOpened) {
            if (!n4._options.autoOpen)
              return ot(new Z2.DatabaseClosed());
            n4.open().catch(ne2);
          }
          return n4._state.dbReadyPromise.then(function() {
            return t4(n4, r4, i3, o3);
          });
        }(this.db, e3, [this.name], o2);
      } finally {
        a2 && Me2();
      }
    }, Pt.prototype.get = function(t3, e3) {
      var n3 = this;
      return t3 && t3.constructor === Object ? this.where(t3).first(e3) : this._trans("readonly", function(e4) {
        return n3.core.get({ trans: e4, key: t3 }).then(function(e5) {
          return n3.hook.reading.fire(e5);
        });
      }).then(e3);
    }, Pt.prototype.where = function(o2) {
      if ("string" == typeof o2)
        return new this.db.WhereClause(this, o2);
      if (g2(o2))
        return new this.db.WhereClause(this, "[".concat(o2.join("+"), "]"));
      var n3 = k2(o2);
      if (1 === n3.length)
        return this.where(n3[0]).equals(o2[n3[0]]);
      var e3 = this.schema.indexes.concat(this.schema.primKey).filter(function(t4) {
        if (t4.compound && n3.every(function(e5) {
          return 0 <= t4.keyPath.indexOf(e5);
        })) {
          for (var e4 = 0; e4 < n3.length; ++e4)
            if (-1 === n3.indexOf(t4.keyPath[e4]))
              return false;
          return true;
        }
        return false;
      }).sort(function(e4, t4) {
        return e4.keyPath.length - t4.keyPath.length;
      })[0];
      if (e3 && this.db._maxKey !== ut2) {
        var t3 = e3.keyPath.slice(0, n3.length);
        return this.where(t3).equals(t3.map(function(e4) {
          return o2[e4];
        }));
      }
      !e3 && F2 && console.warn("The query ".concat(JSON.stringify(o2), " on ").concat(this.name, " would benefit of a ") + "compound index [".concat(n3.join("+"), "]"));
      var a2 = this.schema.idxByName, r3 = this.db._deps.indexedDB;
      function u3(e4, t4) {
        return 0 === r3.cmp(e4, t4);
      }
      var i2 = n3.reduce(function(e4, t4) {
        var n4 = e4[0], r4 = e4[1], e4 = a2[t4], i3 = o2[t4];
        return [n4 || e4, n4 || !e4 ? mt(r4, e4 && e4.multi ? function(e5) {
          e5 = x2(e5, t4);
          return g2(e5) && e5.some(function(e6) {
            return u3(i3, e6);
          });
        } : function(e5) {
          return u3(i3, x2(e5, t4));
        }) : r4];
      }, [null, null]), t3 = i2[0], i2 = i2[1];
      return t3 ? this.where(t3.name).equals(o2[t3.keyPath]).filter(i2) : e3 ? this.filter(i2) : this.where(n3).equals("");
    }, Pt.prototype.filter = function(e3) {
      return this.toCollection().and(e3);
    }, Pt.prototype.count = function(e3) {
      return this.toCollection().count(e3);
    }, Pt.prototype.offset = function(e3) {
      return this.toCollection().offset(e3);
    }, Pt.prototype.limit = function(e3) {
      return this.toCollection().limit(e3);
    }, Pt.prototype.each = function(e3) {
      return this.toCollection().each(e3);
    }, Pt.prototype.toArray = function(e3) {
      return this.toCollection().toArray(e3);
    }, Pt.prototype.toCollection = function() {
      return new this.db.Collection(new this.db.WhereClause(this));
    }, Pt.prototype.orderBy = function(e3) {
      return new this.db.Collection(new this.db.WhereClause(this, g2(e3) ? "[".concat(e3.join("+"), "]") : e3));
    }, Pt.prototype.reverse = function() {
      return this.toCollection().reverse();
    }, Pt.prototype.mapToClass = function(r3) {
      var e3, t3 = this.db, n3 = this.name;
      function i2() {
        return null !== e3 && e3.apply(this, arguments) || this;
      }
      (this.schema.mappedClass = r3).prototype instanceof wt && (function(e4, t4) {
        if ("function" != typeof t4 && null !== t4)
          throw new TypeError("Class extends value " + String(t4) + " is not a constructor or null");
        function n4() {
          this.constructor = e4;
        }
        s(e4, t4), e4.prototype = null === t4 ? Object.create(t4) : (n4.prototype = t4.prototype, new n4());
      }(i2, e3 = r3), Object.defineProperty(i2.prototype, "db", { get: function() {
        return t3;
      }, enumerable: false, configurable: true }), i2.prototype.table = function() {
        return n3;
      }, r3 = i2);
      for (var o2 = /* @__PURE__ */ new Set(), a2 = r3.prototype; a2; a2 = c(a2))
        Object.getOwnPropertyNames(a2).forEach(function(e4) {
          return o2.add(e4);
        });
      function u3(e4) {
        if (!e4)
          return e4;
        var t4, n4 = Object.create(r3.prototype);
        for (t4 in e4)
          if (!o2.has(t4))
            try {
              n4[t4] = e4[t4];
            } catch (e5) {
            }
        return n4;
      }
      return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = u3, this.hook("reading", u3), r3;
    }, Pt.prototype.defineClass = function() {
      return this.mapToClass(function(e3) {
        a(this, e3);
      });
    }, Pt.prototype.add = function(t3, n3) {
      var r3 = this, e3 = this.schema.primKey, i2 = e3.auto, o2 = e3.keyPath, a2 = t3;
      return o2 && i2 && (a2 = gt(o2)(t3)), this._trans("readwrite", function(e4) {
        return r3.core.mutate({ trans: e4, type: "add", keys: null != n3 ? [n3] : null, values: [a2] });
      }).then(function(e4) {
        return e4.numFailures ? je2.reject(e4.failures[0]) : e4.lastResult;
      }).then(function(e4) {
        if (o2)
          try {
            O2(t3, o2, e4);
          } catch (e5) {
          }
        return e4;
      });
    }, Pt.prototype.update = function(e3, t3) {
      if ("object" != typeof e3 || g2(e3))
        return this.where(":id").equals(e3).modify(t3);
      e3 = x2(e3, this.schema.primKey.keyPath);
      return void 0 === e3 ? ot(new Z2.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(e3).modify(t3);
    }, Pt.prototype.put = function(t3, n3) {
      var r3 = this, e3 = this.schema.primKey, i2 = e3.auto, o2 = e3.keyPath, a2 = t3;
      return o2 && i2 && (a2 = gt(o2)(t3)), this._trans("readwrite", function(e4) {
        return r3.core.mutate({ trans: e4, type: "put", values: [a2], keys: null != n3 ? [n3] : null });
      }).then(function(e4) {
        return e4.numFailures ? je2.reject(e4.failures[0]) : e4.lastResult;
      }).then(function(e4) {
        if (o2)
          try {
            O2(t3, o2, e4);
          } catch (e5) {
          }
        return e4;
      });
    }, Pt.prototype.delete = function(t3) {
      var n3 = this;
      return this._trans("readwrite", function(e3) {
        return n3.core.mutate({ trans: e3, type: "delete", keys: [t3] });
      }).then(function(e3) {
        return e3.numFailures ? je2.reject(e3.failures[0]) : void 0;
      });
    }, Pt.prototype.clear = function() {
      var t3 = this;
      return this._trans("readwrite", function(e3) {
        return t3.core.mutate({ trans: e3, type: "deleteRange", range: bt });
      }).then(function(e3) {
        return e3.numFailures ? je2.reject(e3.failures[0]) : void 0;
      });
    }, Pt.prototype.bulkGet = function(t3) {
      var n3 = this;
      return this._trans("readonly", function(e3) {
        return n3.core.getMany({ keys: t3, trans: e3 }).then(function(e4) {
          return e4.map(function(e5) {
            return n3.hook.reading.fire(e5);
          });
        });
      });
    }, Pt.prototype.bulkAdd = function(r3, e3, t3) {
      var o2 = this, a2 = Array.isArray(e3) ? e3 : void 0, u3 = (t3 = t3 || (a2 ? void 0 : e3)) ? t3.allKeys : void 0;
      return this._trans("readwrite", function(e4) {
        var t4 = o2.schema.primKey, n3 = t4.auto, t4 = t4.keyPath;
        if (t4 && a2)
          throw new Z2.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
        if (a2 && a2.length !== r3.length)
          throw new Z2.InvalidArgument("Arguments objects and keys must have the same length");
        var i2 = r3.length, t4 = t4 && n3 ? r3.map(gt(t4)) : r3;
        return o2.core.mutate({ trans: e4, type: "add", keys: a2, values: t4, wantResults: u3 }).then(function(e5) {
          var t5 = e5.numFailures, n4 = e5.results, r4 = e5.lastResult, e5 = e5.failures;
          if (0 === t5)
            return u3 ? n4 : r4;
          throw new X2("".concat(o2.name, ".bulkAdd(): ").concat(t5, " of ").concat(i2, " operations failed"), e5);
        });
      });
    }, Pt.prototype.bulkPut = function(r3, e3, t3) {
      var o2 = this, a2 = Array.isArray(e3) ? e3 : void 0, u3 = (t3 = t3 || (a2 ? void 0 : e3)) ? t3.allKeys : void 0;
      return this._trans("readwrite", function(e4) {
        var t4 = o2.schema.primKey, n3 = t4.auto, t4 = t4.keyPath;
        if (t4 && a2)
          throw new Z2.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
        if (a2 && a2.length !== r3.length)
          throw new Z2.InvalidArgument("Arguments objects and keys must have the same length");
        var i2 = r3.length, t4 = t4 && n3 ? r3.map(gt(t4)) : r3;
        return o2.core.mutate({ trans: e4, type: "put", keys: a2, values: t4, wantResults: u3 }).then(function(e5) {
          var t5 = e5.numFailures, n4 = e5.results, r4 = e5.lastResult, e5 = e5.failures;
          if (0 === t5)
            return u3 ? n4 : r4;
          throw new X2("".concat(o2.name, ".bulkPut(): ").concat(t5, " of ").concat(i2, " operations failed"), e5);
        });
      });
    }, Pt.prototype.bulkUpdate = function(t3) {
      var h3 = this, n3 = this.core, r3 = t3.map(function(e3) {
        return e3.key;
      }), i2 = t3.map(function(e3) {
        return e3.changes;
      }), d2 = [];
      return this._trans("readwrite", function(e3) {
        return n3.getMany({ trans: e3, keys: r3, cache: "clone" }).then(function(c2) {
          var l3 = [], f3 = [];
          t3.forEach(function(e4, t4) {
            var n4 = e4.key, r4 = e4.changes, i3 = c2[t4];
            if (i3) {
              for (var o2 = 0, a2 = Object.keys(r4); o2 < a2.length; o2++) {
                var u3 = a2[o2], s3 = r4[u3];
                if (u3 === h3.schema.primKey.keyPath) {
                  if (0 !== _t(s3, n4))
                    throw new Z2.Constraint("Cannot update primary key in bulkUpdate()");
                } else
                  O2(i3, u3, s3);
              }
              d2.push(t4), l3.push(n4), f3.push(i3);
            }
          });
          var s2 = l3.length;
          return n3.mutate({ trans: e3, type: "put", keys: l3, values: f3, updates: { keys: r3, changeSpecs: i2 } }).then(function(e4) {
            var t4 = e4.numFailures, n4 = e4.failures;
            if (0 === t4)
              return s2;
            for (var r4 = 0, i3 = Object.keys(n4); r4 < i3.length; r4++) {
              var o2, a2 = i3[r4], u3 = d2[Number(a2)];
              null != u3 && (o2 = n4[a2], delete n4[a2], n4[u3] = o2);
            }
            throw new X2("".concat(h3.name, ".bulkUpdate(): ").concat(t4, " of ").concat(s2, " operations failed"), n4);
          });
        });
      });
    }, Pt.prototype.bulkDelete = function(t3) {
      var r3 = this, i2 = t3.length;
      return this._trans("readwrite", function(e3) {
        return r3.core.mutate({ trans: e3, type: "delete", keys: t3 });
      }).then(function(e3) {
        var t4 = e3.numFailures, n3 = e3.lastResult, e3 = e3.failures;
        if (0 === t4)
          return n3;
        throw new X2("".concat(r3.name, ".bulkDelete(): ").concat(t4, " of ").concat(i2, " operations failed"), e3);
      });
    }, Pt);
    function Pt() {
    }
    function Et(i2) {
      function t3(e4, t4) {
        if (t4) {
          for (var n4 = arguments.length, r3 = new Array(n4 - 1); --n4; )
            r3[n4 - 1] = arguments[n4];
          return a2[e4].subscribe.apply(null, r3), i2;
        }
        if ("string" == typeof e4)
          return a2[e4];
      }
      var a2 = {};
      t3.addEventType = u3;
      for (var e3 = 1, n3 = arguments.length; e3 < n3; ++e3)
        u3(arguments[e3]);
      return t3;
      function u3(e4, n4, r3) {
        if ("object" != typeof e4) {
          var i3;
          n4 = n4 || ce2;
          var o2 = { subscribers: [], fire: r3 = r3 || ne2, subscribe: function(e5) {
            -1 === o2.subscribers.indexOf(e5) && (o2.subscribers.push(e5), o2.fire = n4(o2.fire, e5));
          }, unsubscribe: function(t4) {
            o2.subscribers = o2.subscribers.filter(function(e5) {
              return e5 !== t4;
            }), o2.fire = o2.subscribers.reduce(n4, r3);
          } };
          return a2[e4] = t3[e4] = o2;
        }
        k2(i3 = e4).forEach(function(e5) {
          var t4 = i3[e5];
          if (g2(t4))
            u3(e5, i3[e5][0], i3[e5][1]);
          else {
            if ("asap" !== t4)
              throw new Z2.InvalidArgument("Invalid event config");
            var n5 = u3(e5, re2, function() {
              for (var e6 = arguments.length, t5 = new Array(e6); e6--; )
                t5[e6] = arguments[e6];
              n5.subscribers.forEach(function(e7) {
                w2(function() {
                  e7.apply(null, t5);
                });
              });
            });
          }
        });
      }
    }
    function Kt(e3, t3) {
      return o(t3).from({ prototype: e3 }), t3;
    }
    function St(e3, t3) {
      return !(e3.filter || e3.algorithm || e3.or) && (t3 ? e3.justLimit : !e3.replayFilter);
    }
    function jt(e3, t3) {
      e3.filter = mt(e3.filter, t3);
    }
    function At(e3, t3, n3) {
      var r3 = e3.replayFilter;
      e3.replayFilter = r3 ? function() {
        return mt(r3(), t3());
      } : t3, e3.justLimit = n3 && !r3;
    }
    function Ct(e3, t3) {
      if (e3.isPrimKey)
        return t3.primaryKey;
      var n3 = t3.getIndexByKeyPath(e3.index);
      if (!n3)
        throw new Z2.Schema("KeyPath " + e3.index + " on object store " + t3.name + " is not indexed");
      return n3;
    }
    function qt(e3, t3, n3) {
      var r3 = Ct(e3, t3.schema);
      return t3.openCursor({ trans: n3, values: !e3.keysOnly, reverse: "prev" === e3.dir, unique: !!e3.unique, query: { index: r3, range: e3.range } });
    }
    function Dt(e3, o2, t3, n3) {
      var a2 = e3.replayFilter ? mt(e3.filter, e3.replayFilter()) : e3.filter;
      if (e3.or) {
        var u3 = {}, r3 = function(e4, t4, n4) {
          var r4, i2;
          a2 && !a2(t4, n4, function(e5) {
            return t4.stop(e5);
          }, function(e5) {
            return t4.fail(e5);
          }) || ("[object ArrayBuffer]" === (i2 = "" + (r4 = t4.primaryKey)) && (i2 = "" + new Uint8Array(r4)), m2(u3, i2) || (u3[i2] = true, o2(e4, t4, n4)));
        };
        return Promise.all([e3.or._iterate(r3, t3), Tt(qt(e3, n3, t3), e3.algorithm, r3, !e3.keysOnly && e3.valueMapper)]);
      }
      return Tt(qt(e3, n3, t3), mt(e3.algorithm, a2), o2, !e3.keysOnly && e3.valueMapper);
    }
    function Tt(e3, r3, i2, o2) {
      var a2 = Ue2(o2 ? function(e4, t3, n3) {
        return i2(o2(e4), t3, n3);
      } : i2);
      return e3.then(function(n3) {
        if (n3)
          return n3.start(function() {
            var t3 = function() {
              return n3.continue();
            };
            r3 && !r3(n3, function(e4) {
              return t3 = e4;
            }, function(e4) {
              n3.stop(e4), t3 = ne2;
            }, function(e4) {
              n3.fail(e4), t3 = ne2;
            }) || a2(n3.value, n3, function(e4) {
              return t3 = e4;
            }), t3();
          });
      });
    }
    var It = (Rt.prototype._read = function(e3, t3) {
      var n3 = this._ctx;
      return n3.error ? n3.table._trans(null, ot.bind(null, n3.error)) : n3.table._trans("readonly", e3).then(t3);
    }, Rt.prototype._write = function(e3) {
      var t3 = this._ctx;
      return t3.error ? t3.table._trans(null, ot.bind(null, t3.error)) : t3.table._trans("readwrite", e3, "locked");
    }, Rt.prototype._addAlgorithm = function(e3) {
      var t3 = this._ctx;
      t3.algorithm = mt(t3.algorithm, e3);
    }, Rt.prototype._iterate = function(e3, t3) {
      return Dt(this._ctx, e3, t3, this._ctx.table.core);
    }, Rt.prototype.clone = function(e3) {
      var t3 = Object.create(this.constructor.prototype), n3 = Object.create(this._ctx);
      return e3 && a(n3, e3), t3._ctx = n3, t3;
    }, Rt.prototype.raw = function() {
      return this._ctx.valueMapper = null, this;
    }, Rt.prototype.each = function(t3) {
      var n3 = this._ctx;
      return this._read(function(e3) {
        return Dt(n3, t3, e3, n3.table.core);
      });
    }, Rt.prototype.count = function(e3) {
      var i2 = this;
      return this._read(function(e4) {
        var t3 = i2._ctx, n3 = t3.table.core;
        if (St(t3, true))
          return n3.count({ trans: e4, query: { index: Ct(t3, n3.schema), range: t3.range } }).then(function(e5) {
            return Math.min(e5, t3.limit);
          });
        var r3 = 0;
        return Dt(t3, function() {
          return ++r3, false;
        }, e4, n3).then(function() {
          return r3;
        });
      }).then(e3);
    }, Rt.prototype.sortBy = function(e3, t3) {
      var n3 = e3.split(".").reverse(), r3 = n3[0], i2 = n3.length - 1;
      function o2(e4, t4) {
        return t4 ? o2(e4[n3[t4]], t4 - 1) : e4[r3];
      }
      var a2 = "next" === this._ctx.dir ? 1 : -1;
      function u3(e4, t4) {
        e4 = o2(e4, i2), t4 = o2(t4, i2);
        return e4 < t4 ? -a2 : t4 < e4 ? a2 : 0;
      }
      return this.toArray(function(e4) {
        return e4.sort(u3);
      }).then(t3);
    }, Rt.prototype.toArray = function(e3) {
      var o2 = this;
      return this._read(function(e4) {
        var t3 = o2._ctx;
        if ("next" === t3.dir && St(t3, true) && 0 < t3.limit) {
          var n3 = t3.valueMapper, r3 = Ct(t3, t3.table.core.schema);
          return t3.table.core.query({ trans: e4, limit: t3.limit, values: true, query: { index: r3, range: t3.range } }).then(function(e5) {
            e5 = e5.result;
            return n3 ? e5.map(n3) : e5;
          });
        }
        var i2 = [];
        return Dt(t3, function(e5) {
          return i2.push(e5);
        }, e4, t3.table.core).then(function() {
          return i2;
        });
      }, e3);
    }, Rt.prototype.offset = function(t3) {
      var e3 = this._ctx;
      return t3 <= 0 || (e3.offset += t3, St(e3) ? At(e3, function() {
        var n3 = t3;
        return function(e4, t4) {
          return 0 === n3 || (1 === n3 ? --n3 : t4(function() {
            e4.advance(n3), n3 = 0;
          }), false);
        };
      }) : At(e3, function() {
        var e4 = t3;
        return function() {
          return --e4 < 0;
        };
      })), this;
    }, Rt.prototype.limit = function(e3) {
      return this._ctx.limit = Math.min(this._ctx.limit, e3), At(this._ctx, function() {
        var r3 = e3;
        return function(e4, t3, n3) {
          return --r3 <= 0 && t3(n3), 0 <= r3;
        };
      }, true), this;
    }, Rt.prototype.until = function(r3, i2) {
      return jt(this._ctx, function(e3, t3, n3) {
        return !r3(e3.value) || (t3(n3), i2);
      }), this;
    }, Rt.prototype.first = function(e3) {
      return this.limit(1).toArray(function(e4) {
        return e4[0];
      }).then(e3);
    }, Rt.prototype.last = function(e3) {
      return this.reverse().first(e3);
    }, Rt.prototype.filter = function(t3) {
      var e3;
      return jt(this._ctx, function(e4) {
        return t3(e4.value);
      }), (e3 = this._ctx).isMatch = mt(e3.isMatch, t3), this;
    }, Rt.prototype.and = function(e3) {
      return this.filter(e3);
    }, Rt.prototype.or = function(e3) {
      return new this.db.WhereClause(this._ctx.table, e3, this);
    }, Rt.prototype.reverse = function() {
      return this._ctx.dir = "prev" === this._ctx.dir ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
    }, Rt.prototype.desc = function() {
      return this.reverse();
    }, Rt.prototype.eachKey = function(n3) {
      var e3 = this._ctx;
      return e3.keysOnly = !e3.isMatch, this.each(function(e4, t3) {
        n3(t3.key, t3);
      });
    }, Rt.prototype.eachUniqueKey = function(e3) {
      return this._ctx.unique = "unique", this.eachKey(e3);
    }, Rt.prototype.eachPrimaryKey = function(n3) {
      var e3 = this._ctx;
      return e3.keysOnly = !e3.isMatch, this.each(function(e4, t3) {
        n3(t3.primaryKey, t3);
      });
    }, Rt.prototype.keys = function(e3) {
      var t3 = this._ctx;
      t3.keysOnly = !t3.isMatch;
      var n3 = [];
      return this.each(function(e4, t4) {
        n3.push(t4.key);
      }).then(function() {
        return n3;
      }).then(e3);
    }, Rt.prototype.primaryKeys = function(e3) {
      var n3 = this._ctx;
      if ("next" === n3.dir && St(n3, true) && 0 < n3.limit)
        return this._read(function(e4) {
          var t3 = Ct(n3, n3.table.core.schema);
          return n3.table.core.query({ trans: e4, values: false, limit: n3.limit, query: { index: t3, range: n3.range } });
        }).then(function(e4) {
          return e4.result;
        }).then(e3);
      n3.keysOnly = !n3.isMatch;
      var r3 = [];
      return this.each(function(e4, t3) {
        r3.push(t3.primaryKey);
      }).then(function() {
        return r3;
      }).then(e3);
    }, Rt.prototype.uniqueKeys = function(e3) {
      return this._ctx.unique = "unique", this.keys(e3);
    }, Rt.prototype.firstKey = function(e3) {
      return this.limit(1).keys(function(e4) {
        return e4[0];
      }).then(e3);
    }, Rt.prototype.lastKey = function(e3) {
      return this.reverse().firstKey(e3);
    }, Rt.prototype.distinct = function() {
      var e3 = this._ctx, e3 = e3.index && e3.table.schema.idxByName[e3.index];
      if (!e3 || !e3.multi)
        return this;
      var n3 = {};
      return jt(this._ctx, function(e4) {
        var t3 = e4.primaryKey.toString(), e4 = m2(n3, t3);
        return n3[t3] = true, !e4;
      }), this;
    }, Rt.prototype.modify = function(w3) {
      var n3 = this, _3 = this._ctx;
      return this._write(function(d2) {
        var o2, a2, p3;
        p3 = "function" == typeof w3 ? w3 : (o2 = k2(w3), a2 = o2.length, function(e4) {
          for (var t4 = false, n4 = 0; n4 < a2; ++n4) {
            var r3 = o2[n4], i2 = w3[r3];
            x2(e4, r3) !== i2 && (O2(e4, r3, i2), t4 = true);
          }
          return t4;
        });
        function y3(e4, t4) {
          var n4 = t4.failures, t4 = t4.numFailures;
          s2 += e4 - t4;
          for (var r3 = 0, i2 = k2(n4); r3 < i2.length; r3++) {
            var o3 = i2[r3];
            u3.push(n4[o3]);
          }
        }
        var v3 = _3.table.core, e3 = v3.schema.primaryKey, m3 = e3.outbound, b3 = e3.extractKey, g3 = n3.db._options.modifyChunkSize || 200, u3 = [], s2 = 0, t3 = [];
        return n3.clone().primaryKeys().then(function(f3) {
          function h3(c2) {
            var l3 = Math.min(g3, f3.length - c2);
            return v3.getMany({ trans: d2, keys: f3.slice(c2, c2 + l3), cache: "immutable" }).then(function(e4) {
              for (var n4 = [], t4 = [], r3 = m3 ? [] : null, i2 = [], o3 = 0; o3 < l3; ++o3) {
                var a3 = e4[o3], u4 = { value: j2(a3), primKey: f3[c2 + o3] };
                false !== p3.call(u4, u4.value, u4) && (null == u4.value ? i2.push(f3[c2 + o3]) : m3 || 0 === _t(b3(a3), b3(u4.value)) ? (t4.push(u4.value), m3 && r3.push(f3[c2 + o3])) : (i2.push(f3[c2 + o3]), n4.push(u4.value)));
              }
              var s3 = St(_3) && _3.limit === 1 / 0 && ("function" != typeof w3 || w3 === Bt) && { index: _3.index, range: _3.range };
              return Promise.resolve(0 < n4.length && v3.mutate({ trans: d2, type: "add", values: n4 }).then(function(e5) {
                for (var t5 in e5.failures)
                  i2.splice(parseInt(t5), 1);
                y3(n4.length, e5);
              })).then(function() {
                return (0 < t4.length || s3 && "object" == typeof w3) && v3.mutate({ trans: d2, type: "put", keys: r3, values: t4, criteria: s3, changeSpec: "function" != typeof w3 && w3 }).then(function(e5) {
                  return y3(t4.length, e5);
                });
              }).then(function() {
                return (0 < i2.length || s3 && w3 === Bt) && v3.mutate({ trans: d2, type: "delete", keys: i2, criteria: s3 }).then(function(e5) {
                  return y3(i2.length, e5);
                });
              }).then(function() {
                return f3.length > c2 + l3 && h3(c2 + g3);
              });
            });
          }
          return h3(0).then(function() {
            if (0 < u3.length)
              throw new H2("Error modifying one or more objects", u3, s2, t3);
            return f3.length;
          });
        });
      });
    }, Rt.prototype.delete = function() {
      var i2 = this._ctx, n3 = i2.range;
      return St(i2) && (i2.isPrimKey && !dt2 || 3 === n3.type) ? this._write(function(e3) {
        var t3 = i2.table.core.schema.primaryKey, r3 = n3;
        return i2.table.core.count({ trans: e3, query: { index: t3, range: r3 } }).then(function(n4) {
          return i2.table.core.mutate({ trans: e3, type: "deleteRange", range: r3 }).then(function(e4) {
            var t4 = e4.failures;
            e4.lastResult, e4.results;
            e4 = e4.numFailures;
            if (e4)
              throw new H2("Could not delete some values", Object.keys(t4).map(function(e5) {
                return t4[e5];
              }), n4 - e4);
            return n4 - e4;
          });
        });
      }) : this.modify(Bt);
    }, Rt);
    function Rt() {
    }
    var Bt = function(e3, t3) {
      return t3.value = null;
    };
    function Ft(e3, t3) {
      return e3 < t3 ? -1 : e3 === t3 ? 0 : 1;
    }
    function Mt(e3, t3) {
      return t3 < e3 ? -1 : e3 === t3 ? 0 : 1;
    }
    function Nt(e3, t3, n3) {
      e3 = e3 instanceof Wt ? new e3.Collection(e3) : e3;
      return e3._ctx.error = new (n3 || TypeError)(t3), e3;
    }
    function Lt(e3) {
      return new e3.Collection(e3, function() {
        return Vt("");
      }).limit(0);
    }
    function Ut(e3, s2, n3, r3) {
      var i2, c2, l3, f3, h3, d2, p3, y3 = n3.length;
      if (!n3.every(function(e4) {
        return "string" == typeof e4;
      }))
        return Nt(e3, ct2);
      function t3(e4) {
        i2 = "next" === e4 ? function(e5) {
          return e5.toUpperCase();
        } : function(e5) {
          return e5.toLowerCase();
        }, c2 = "next" === e4 ? function(e5) {
          return e5.toLowerCase();
        } : function(e5) {
          return e5.toUpperCase();
        }, l3 = "next" === e4 ? Ft : Mt;
        var t4 = n3.map(function(e5) {
          return { lower: c2(e5), upper: i2(e5) };
        }).sort(function(e5, t5) {
          return l3(e5.lower, t5.lower);
        });
        f3 = t4.map(function(e5) {
          return e5.upper;
        }), h3 = t4.map(function(e5) {
          return e5.lower;
        }), p3 = "next" === (d2 = e4) ? "" : r3;
      }
      t3("next");
      e3 = new e3.Collection(e3, function() {
        return zt(f3[0], h3[y3 - 1] + r3);
      });
      e3._ondirectionchange = function(e4) {
        t3(e4);
      };
      var v3 = 0;
      return e3._addAlgorithm(function(e4, t4, n4) {
        var r4 = e4.key;
        if ("string" != typeof r4)
          return false;
        var i3 = c2(r4);
        if (s2(i3, h3, v3))
          return true;
        for (var o2 = null, a2 = v3; a2 < y3; ++a2) {
          var u3 = function(e5, t5, n5, r5, i4, o3) {
            for (var a3 = Math.min(e5.length, r5.length), u4 = -1, s3 = 0; s3 < a3; ++s3) {
              var c3 = t5[s3];
              if (c3 !== r5[s3])
                return i4(e5[s3], n5[s3]) < 0 ? e5.substr(0, s3) + n5[s3] + n5.substr(s3 + 1) : i4(e5[s3], r5[s3]) < 0 ? e5.substr(0, s3) + r5[s3] + n5.substr(s3 + 1) : 0 <= u4 ? e5.substr(0, u4) + t5[u4] + n5.substr(u4 + 1) : null;
              i4(e5[s3], c3) < 0 && (u4 = s3);
            }
            return a3 < r5.length && "next" === o3 ? e5 + n5.substr(e5.length) : a3 < e5.length && "prev" === o3 ? e5.substr(0, n5.length) : u4 < 0 ? null : e5.substr(0, u4) + r5[u4] + n5.substr(u4 + 1);
          }(r4, i3, f3[a2], h3[a2], l3, d2);
          null === u3 && null === o2 ? v3 = a2 + 1 : (null === o2 || 0 < l3(o2, u3)) && (o2 = u3);
        }
        return t4(null !== o2 ? function() {
          e4.continue(o2 + p3);
        } : n4), false;
      }), e3;
    }
    function zt(e3, t3, n3, r3) {
      return { type: 2, lower: e3, upper: t3, lowerOpen: n3, upperOpen: r3 };
    }
    function Vt(e3) {
      return { type: 1, lower: e3, upper: e3 };
    }
    var Wt = (Object.defineProperty(Yt.prototype, "Collection", { get: function() {
      return this._ctx.table.db.Collection;
    }, enumerable: false, configurable: true }), Yt.prototype.between = function(e3, t3, n3, r3) {
      n3 = false !== n3, r3 = true === r3;
      try {
        return 0 < this._cmp(e3, t3) || 0 === this._cmp(e3, t3) && (n3 || r3) && (!n3 || !r3) ? Lt(this) : new this.Collection(this, function() {
          return zt(e3, t3, !n3, !r3);
        });
      } catch (e4) {
        return Nt(this, st2);
      }
    }, Yt.prototype.equals = function(e3) {
      return null == e3 ? Nt(this, st2) : new this.Collection(this, function() {
        return Vt(e3);
      });
    }, Yt.prototype.above = function(e3) {
      return null == e3 ? Nt(this, st2) : new this.Collection(this, function() {
        return zt(e3, void 0, true);
      });
    }, Yt.prototype.aboveOrEqual = function(e3) {
      return null == e3 ? Nt(this, st2) : new this.Collection(this, function() {
        return zt(e3, void 0, false);
      });
    }, Yt.prototype.below = function(e3) {
      return null == e3 ? Nt(this, st2) : new this.Collection(this, function() {
        return zt(void 0, e3, false, true);
      });
    }, Yt.prototype.belowOrEqual = function(e3) {
      return null == e3 ? Nt(this, st2) : new this.Collection(this, function() {
        return zt(void 0, e3);
      });
    }, Yt.prototype.startsWith = function(e3) {
      return "string" != typeof e3 ? Nt(this, ct2) : this.between(e3, e3 + ut2, true, true);
    }, Yt.prototype.startsWithIgnoreCase = function(e3) {
      return "" === e3 ? this.startsWith(e3) : Ut(this, function(e4, t3) {
        return 0 === e4.indexOf(t3[0]);
      }, [e3], ut2);
    }, Yt.prototype.equalsIgnoreCase = function(e3) {
      return Ut(this, function(e4, t3) {
        return e4 === t3[0];
      }, [e3], "");
    }, Yt.prototype.anyOfIgnoreCase = function() {
      var e3 = R2.apply(I2, arguments);
      return 0 === e3.length ? Lt(this) : Ut(this, function(e4, t3) {
        return -1 !== t3.indexOf(e4);
      }, e3, "");
    }, Yt.prototype.startsWithAnyOfIgnoreCase = function() {
      var e3 = R2.apply(I2, arguments);
      return 0 === e3.length ? Lt(this) : Ut(this, function(t3, e4) {
        return e4.some(function(e5) {
          return 0 === t3.indexOf(e5);
        });
      }, e3, ut2);
    }, Yt.prototype.anyOf = function() {
      var t3 = this, i2 = R2.apply(I2, arguments), o2 = this._cmp;
      try {
        i2.sort(o2);
      } catch (e4) {
        return Nt(this, st2);
      }
      if (0 === i2.length)
        return Lt(this);
      var e3 = new this.Collection(this, function() {
        return zt(i2[0], i2[i2.length - 1]);
      });
      e3._ondirectionchange = function(e4) {
        o2 = "next" === e4 ? t3._ascending : t3._descending, i2.sort(o2);
      };
      var a2 = 0;
      return e3._addAlgorithm(function(e4, t4, n3) {
        for (var r3 = e4.key; 0 < o2(r3, i2[a2]); )
          if (++a2 === i2.length)
            return t4(n3), false;
        return 0 === o2(r3, i2[a2]) || (t4(function() {
          e4.continue(i2[a2]);
        }), false);
      }), e3;
    }, Yt.prototype.notEqual = function(e3) {
      return this.inAnyRange([[-1 / 0, e3], [e3, this.db._maxKey]], { includeLowers: false, includeUppers: false });
    }, Yt.prototype.noneOf = function() {
      var e3 = R2.apply(I2, arguments);
      if (0 === e3.length)
        return new this.Collection(this);
      try {
        e3.sort(this._ascending);
      } catch (e4) {
        return Nt(this, st2);
      }
      var t3 = e3.reduce(function(e4, t4) {
        return e4 ? e4.concat([[e4[e4.length - 1][1], t4]]) : [[-1 / 0, t4]];
      }, null);
      return t3.push([e3[e3.length - 1], this.db._maxKey]), this.inAnyRange(t3, { includeLowers: false, includeUppers: false });
    }, Yt.prototype.inAnyRange = function(e3, t3) {
      var o2 = this, a2 = this._cmp, u3 = this._ascending, n3 = this._descending, s2 = this._min, c2 = this._max;
      if (0 === e3.length)
        return Lt(this);
      if (!e3.every(function(e4) {
        return void 0 !== e4[0] && void 0 !== e4[1] && u3(e4[0], e4[1]) <= 0;
      }))
        return Nt(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", Z2.InvalidArgument);
      var r3 = !t3 || false !== t3.includeLowers, i2 = t3 && true === t3.includeUppers;
      var l3, f3 = u3;
      function h3(e4, t4) {
        return f3(e4[0], t4[0]);
      }
      try {
        (l3 = e3.reduce(function(e4, t4) {
          for (var n4 = 0, r4 = e4.length; n4 < r4; ++n4) {
            var i3 = e4[n4];
            if (a2(t4[0], i3[1]) < 0 && 0 < a2(t4[1], i3[0])) {
              i3[0] = s2(i3[0], t4[0]), i3[1] = c2(i3[1], t4[1]);
              break;
            }
          }
          return n4 === r4 && e4.push(t4), e4;
        }, [])).sort(h3);
      } catch (e4) {
        return Nt(this, st2);
      }
      var d2 = 0, p3 = i2 ? function(e4) {
        return 0 < u3(e4, l3[d2][1]);
      } : function(e4) {
        return 0 <= u3(e4, l3[d2][1]);
      }, y3 = r3 ? function(e4) {
        return 0 < n3(e4, l3[d2][0]);
      } : function(e4) {
        return 0 <= n3(e4, l3[d2][0]);
      };
      var v3 = p3, e3 = new this.Collection(this, function() {
        return zt(l3[0][0], l3[l3.length - 1][1], !r3, !i2);
      });
      return e3._ondirectionchange = function(e4) {
        f3 = "next" === e4 ? (v3 = p3, u3) : (v3 = y3, n3), l3.sort(h3);
      }, e3._addAlgorithm(function(e4, t4, n4) {
        for (var r4, i3 = e4.key; v3(i3); )
          if (++d2 === l3.length)
            return t4(n4), false;
        return !p3(r4 = i3) && !y3(r4) || (0 === o2._cmp(i3, l3[d2][1]) || 0 === o2._cmp(i3, l3[d2][0]) || t4(function() {
          f3 === u3 ? e4.continue(l3[d2][0]) : e4.continue(l3[d2][1]);
        }), false);
      }), e3;
    }, Yt.prototype.startsWithAnyOf = function() {
      var e3 = R2.apply(I2, arguments);
      return e3.every(function(e4) {
        return "string" == typeof e4;
      }) ? 0 === e3.length ? Lt(this) : this.inAnyRange(e3.map(function(e4) {
        return [e4, e4 + ut2];
      })) : Nt(this, "startsWithAnyOf() only works with strings");
    }, Yt);
    function Yt() {
    }
    function Qt(t3) {
      return Ue2(function(e3) {
        return Gt(e3), t3(e3.target.error), false;
      });
    }
    function Gt(e3) {
      e3.stopPropagation && e3.stopPropagation(), e3.preventDefault && e3.preventDefault();
    }
    var Ht = "storagemutated", Xt = "x-storagemutated-1", Jt = Et(null, Ht), $t = (Zt.prototype._lock = function() {
      return b2(!Pe2.global), ++this._reculock, 1 !== this._reculock || Pe2.global || (Pe2.lockOwnerFor = this), this;
    }, Zt.prototype._unlock = function() {
      if (b2(!Pe2.global), 0 == --this._reculock)
        for (Pe2.global || (Pe2.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
          var e3 = this._blockedFuncs.shift();
          try {
            nt2(e3[1], e3[0]);
          } catch (e4) {
          }
        }
      return this;
    }, Zt.prototype._locked = function() {
      return this._reculock && Pe2.lockOwnerFor !== this;
    }, Zt.prototype.create = function(t3) {
      var n3 = this;
      if (!this.mode)
        return this;
      var e3 = this.db.idbdb, r3 = this.db._state.dbOpenError;
      if (b2(!this.idbtrans), !t3 && !e3)
        switch (r3 && r3.name) {
          case "DatabaseClosedError":
            throw new Z2.DatabaseClosed(r3);
          case "MissingAPIError":
            throw new Z2.MissingAPI(r3.message, r3);
          default:
            throw new Z2.OpenFailed(r3);
        }
      if (!this.active)
        throw new Z2.TransactionInactive();
      return b2(null === this._completion._state), (t3 = this.idbtrans = t3 || (this.db.core || e3).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = Ue2(function(e4) {
        Gt(e4), n3._reject(t3.error);
      }), t3.onabort = Ue2(function(e4) {
        Gt(e4), n3.active && n3._reject(new Z2.Abort(t3.error)), n3.active = false, n3.on("abort").fire(e4);
      }), t3.oncomplete = Ue2(function() {
        n3.active = false, n3._resolve(), "mutatedParts" in t3 && Jt.storagemutated.fire(t3.mutatedParts);
      }), this;
    }, Zt.prototype._promise = function(n3, r3, i2) {
      var o2 = this;
      if ("readwrite" === n3 && "readwrite" !== this.mode)
        return ot(new Z2.ReadOnly("Transaction is readonly"));
      if (!this.active)
        return ot(new Z2.TransactionInactive());
      if (this._locked())
        return new je2(function(e4, t3) {
          o2._blockedFuncs.push([function() {
            o2._promise(n3, r3, i2).then(e4, t3);
          }, Pe2]);
        });
      if (i2)
        return He2(function() {
          var e4 = new je2(function(e5, t3) {
            o2._lock();
            var n4 = r3(e5, t3, o2);
            n4 && n4.then && n4.then(e5, t3);
          });
          return e4.finally(function() {
            return o2._unlock();
          }), e4._lib = true, e4;
        });
      var e3 = new je2(function(e4, t3) {
        var n4 = r3(e4, t3, o2);
        n4 && n4.then && n4.then(e4, t3);
      });
      return e3._lib = true, e3;
    }, Zt.prototype._root = function() {
      return this.parent ? this.parent._root() : this;
    }, Zt.prototype.waitFor = function(e3) {
      var t3, r3 = this._root(), i2 = je2.resolve(e3);
      r3._waitingFor ? r3._waitingFor = r3._waitingFor.then(function() {
        return i2;
      }) : (r3._waitingFor = i2, r3._waitingQueue = [], t3 = r3.idbtrans.objectStore(r3.storeNames[0]), function e4() {
        for (++r3._spinCount; r3._waitingQueue.length; )
          r3._waitingQueue.shift()();
        r3._waitingFor && (t3.get(-1 / 0).onsuccess = e4);
      }());
      var o2 = r3._waitingFor;
      return new je2(function(t4, n3) {
        i2.then(function(e4) {
          return r3._waitingQueue.push(Ue2(t4.bind(null, e4)));
        }, function(e4) {
          return r3._waitingQueue.push(Ue2(n3.bind(null, e4)));
        }).finally(function() {
          r3._waitingFor === o2 && (r3._waitingFor = null);
        });
      });
    }, Zt.prototype.abort = function() {
      this.active && (this.active = false, this.idbtrans && this.idbtrans.abort(), this._reject(new Z2.Abort()));
    }, Zt.prototype.table = function(e3) {
      var t3 = this._memoizedTables || (this._memoizedTables = {});
      if (m2(t3, e3))
        return t3[e3];
      var n3 = this.schema[e3];
      if (!n3)
        throw new Z2.NotFound("Table " + e3 + " not part of transaction");
      n3 = new this.db.Table(e3, n3, this);
      return n3.core = this.db.core.table(e3), t3[e3] = n3;
    }, Zt);
    function Zt() {
    }
    function en(e3, t3, n3, r3, i2, o2, a2) {
      return { name: e3, keyPath: t3, unique: n3, multi: r3, auto: i2, compound: o2, src: (n3 && !a2 ? "&" : "") + (r3 ? "*" : "") + (i2 ? "++" : "") + tn(t3) };
    }
    function tn(e3) {
      return "string" == typeof e3 ? e3 : e3 ? "[" + [].join.call(e3, "+") + "]" : "";
    }
    function nn(e3, t3, n3) {
      return { name: e3, primKey: t3, indexes: n3, mappedClass: null, idxByName: (r3 = function(e4) {
        return [e4.name, e4];
      }, n3.reduce(function(e4, t4, n4) {
        n4 = r3(t4, n4);
        return n4 && (e4[n4[0]] = n4[1]), e4;
      }, {})) };
      var r3;
    }
    var rn = function(e3) {
      try {
        return e3.only([[]]), rn = function() {
          return [[]];
        }, [[]];
      } catch (e4) {
        return rn = function() {
          return ut2;
        }, ut2;
      }
    };
    function on(t3) {
      return null == t3 ? function() {
      } : "string" == typeof t3 ? 1 === (n3 = t3).split(".").length ? function(e3) {
        return e3[n3];
      } : function(e3) {
        return x2(e3, n3);
      } : function(e3) {
        return x2(e3, t3);
      };
      var n3;
    }
    function an(e3) {
      return [].slice.call(e3);
    }
    var un = 0;
    function sn(e3) {
      return null == e3 ? ":id" : "string" == typeof e3 ? e3 : "[".concat(e3.join("+"), "]");
    }
    function cn(e3, i2, t3) {
      function _3(e4) {
        if (3 === e4.type)
          return null;
        if (4 === e4.type)
          throw new Error("Cannot convert never type to IDBKeyRange");
        var t4 = e4.lower, n4 = e4.upper, r4 = e4.lowerOpen, e4 = e4.upperOpen;
        return void 0 === t4 ? void 0 === n4 ? null : i2.upperBound(n4, !!e4) : void 0 === n4 ? i2.lowerBound(t4, !!r4) : i2.bound(t4, n4, !!r4, !!e4);
      }
      function n3(e4) {
        var h3, w3 = e4.name;
        return { name: w3, schema: e4, mutate: function(e5) {
          var y3 = e5.trans, v3 = e5.type, m3 = e5.keys, b3 = e5.values, g3 = e5.range;
          return new Promise(function(t4, e6) {
            t4 = Ue2(t4);
            var n4 = y3.objectStore(w3), r4 = null == n4.keyPath, i3 = "put" === v3 || "add" === v3;
            if (!i3 && "delete" !== v3 && "deleteRange" !== v3)
              throw new Error("Invalid operation type: " + v3);
            var o3, a3 = (m3 || b3 || { length: 1 }).length;
            if (m3 && b3 && m3.length !== b3.length)
              throw new Error("Given keys array must have same length as given values array.");
            if (0 === a3)
              return t4({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
            function u4(e7) {
              ++l3, Gt(e7);
            }
            var s3 = [], c3 = [], l3 = 0;
            if ("deleteRange" === v3) {
              if (4 === g3.type)
                return t4({ numFailures: l3, failures: c3, results: [], lastResult: void 0 });
              3 === g3.type ? s3.push(o3 = n4.clear()) : s3.push(o3 = n4.delete(_3(g3)));
            } else {
              var r4 = i3 ? r4 ? [b3, m3] : [b3, null] : [m3, null], f3 = r4[0], h4 = r4[1];
              if (i3)
                for (var d2 = 0; d2 < a3; ++d2)
                  s3.push(o3 = h4 && void 0 !== h4[d2] ? n4[v3](f3[d2], h4[d2]) : n4[v3](f3[d2])), o3.onerror = u4;
              else
                for (d2 = 0; d2 < a3; ++d2)
                  s3.push(o3 = n4[v3](f3[d2])), o3.onerror = u4;
            }
            function p3(e7) {
              e7 = e7.target.result, s3.forEach(function(e8, t5) {
                return null != e8.error && (c3[t5] = e8.error);
              }), t4({ numFailures: l3, failures: c3, results: "delete" === v3 ? m3 : s3.map(function(e8) {
                return e8.result;
              }), lastResult: e7 });
            }
            o3.onerror = function(e7) {
              u4(e7), p3(e7);
            }, o3.onsuccess = p3;
          });
        }, getMany: function(e5) {
          var f3 = e5.trans, h4 = e5.keys;
          return new Promise(function(t4, e6) {
            t4 = Ue2(t4);
            for (var n4, r4 = f3.objectStore(w3), i3 = h4.length, o3 = new Array(i3), a3 = 0, u4 = 0, s3 = function(e7) {
              e7 = e7.target;
              o3[e7._pos] = e7.result, ++u4 === a3 && t4(o3);
            }, c3 = Qt(e6), l3 = 0; l3 < i3; ++l3)
              null != h4[l3] && ((n4 = r4.get(h4[l3]))._pos = l3, n4.onsuccess = s3, n4.onerror = c3, ++a3);
            0 === a3 && t4(o3);
          });
        }, get: function(e5) {
          var r4 = e5.trans, i3 = e5.key;
          return new Promise(function(t4, e6) {
            t4 = Ue2(t4);
            var n4 = r4.objectStore(w3).get(i3);
            n4.onsuccess = function(e7) {
              return t4(e7.target.result);
            }, n4.onerror = Qt(e6);
          });
        }, query: (h3 = s2, function(f3) {
          return new Promise(function(n4, e5) {
            n4 = Ue2(n4);
            var r4, i3, o3, t4 = f3.trans, a3 = f3.values, u4 = f3.limit, s3 = f3.query, c3 = u4 === 1 / 0 ? void 0 : u4, l3 = s3.index, s3 = s3.range, t4 = t4.objectStore(w3), l3 = l3.isPrimaryKey ? t4 : t4.index(l3.name), s3 = _3(s3);
            if (0 === u4)
              return n4({ result: [] });
            h3 ? ((c3 = a3 ? l3.getAll(s3, c3) : l3.getAllKeys(s3, c3)).onsuccess = function(e6) {
              return n4({ result: e6.target.result });
            }, c3.onerror = Qt(e5)) : (r4 = 0, i3 = !a3 && "openKeyCursor" in l3 ? l3.openKeyCursor(s3) : l3.openCursor(s3), o3 = [], i3.onsuccess = function(e6) {
              var t5 = i3.result;
              return t5 ? (o3.push(a3 ? t5.value : t5.primaryKey), ++r4 === u4 ? n4({ result: o3 }) : void t5.continue()) : n4({ result: o3 });
            }, i3.onerror = Qt(e5));
          });
        }), openCursor: function(e5) {
          var c3 = e5.trans, o3 = e5.values, a3 = e5.query, u4 = e5.reverse, l3 = e5.unique;
          return new Promise(function(t4, n4) {
            t4 = Ue2(t4);
            var e6 = a3.index, r4 = a3.range, i3 = c3.objectStore(w3), i3 = e6.isPrimaryKey ? i3 : i3.index(e6.name), e6 = u4 ? l3 ? "prevunique" : "prev" : l3 ? "nextunique" : "next", s3 = !o3 && "openKeyCursor" in i3 ? i3.openKeyCursor(_3(r4), e6) : i3.openCursor(_3(r4), e6);
            s3.onerror = Qt(n4), s3.onsuccess = Ue2(function(e7) {
              var r5, i4, o4, a4, u5 = s3.result;
              u5 ? (u5.___id = ++un, u5.done = false, r5 = u5.continue.bind(u5), i4 = (i4 = u5.continuePrimaryKey) && i4.bind(u5), o4 = u5.advance.bind(u5), a4 = function() {
                throw new Error("Cursor not stopped");
              }, u5.trans = c3, u5.stop = u5.continue = u5.continuePrimaryKey = u5.advance = function() {
                throw new Error("Cursor not started");
              }, u5.fail = Ue2(n4), u5.next = function() {
                var e8 = this, t5 = 1;
                return this.start(function() {
                  return t5-- ? e8.continue() : e8.stop();
                }).then(function() {
                  return e8;
                });
              }, u5.start = function(e8) {
                function t5() {
                  if (s3.result)
                    try {
                      e8();
                    } catch (e9) {
                      u5.fail(e9);
                    }
                  else
                    u5.done = true, u5.start = function() {
                      throw new Error("Cursor behind last entry");
                    }, u5.stop();
                }
                var n5 = new Promise(function(t6, e9) {
                  t6 = Ue2(t6), s3.onerror = Qt(e9), u5.fail = e9, u5.stop = function(e10) {
                    u5.stop = u5.continue = u5.continuePrimaryKey = u5.advance = a4, t6(e10);
                  };
                });
                return s3.onsuccess = Ue2(function(e9) {
                  s3.onsuccess = t5, t5();
                }), u5.continue = r5, u5.continuePrimaryKey = i4, u5.advance = o4, t5(), n5;
              }, t4(u5)) : t4(null);
            }, n4);
          });
        }, count: function(e5) {
          var t4 = e5.query, i3 = e5.trans, o3 = t4.index, a3 = t4.range;
          return new Promise(function(t5, e6) {
            var n4 = i3.objectStore(w3), r4 = o3.isPrimaryKey ? n4 : n4.index(o3.name), n4 = _3(a3), r4 = n4 ? r4.count(n4) : r4.count();
            r4.onsuccess = Ue2(function(e7) {
              return t5(e7.target.result);
            }), r4.onerror = Qt(e6);
          });
        } };
      }
      var r3, o2, a2, u3 = (o2 = t3, a2 = an((r3 = e3).objectStoreNames), { schema: { name: r3.name, tables: a2.map(function(e4) {
        return o2.objectStore(e4);
      }).map(function(t4) {
        var e4 = t4.keyPath, n4 = t4.autoIncrement, r4 = g2(e4), i3 = {}, n4 = { name: t4.name, primaryKey: { name: null, isPrimaryKey: true, outbound: null == e4, compound: r4, keyPath: e4, autoIncrement: n4, unique: true, extractKey: on(e4) }, indexes: an(t4.indexNames).map(function(e5) {
          return t4.index(e5);
        }).map(function(e5) {
          var t5 = e5.name, n5 = e5.unique, r5 = e5.multiEntry, e5 = e5.keyPath, r5 = { name: t5, compound: g2(e5), keyPath: e5, unique: n5, multiEntry: r5, extractKey: on(e5) };
          return i3[sn(e5)] = r5;
        }), getIndexByKeyPath: function(e5) {
          return i3[sn(e5)];
        } };
        return i3[":id"] = n4.primaryKey, null != e4 && (i3[sn(e4)] = n4.primaryKey), n4;
      }) }, hasGetAll: 0 < a2.length && "getAll" in o2.objectStore(a2[0]) && !("undefined" != typeof navigator && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }), t3 = u3.schema, s2 = u3.hasGetAll, u3 = t3.tables.map(n3), c2 = {};
      return u3.forEach(function(e4) {
        return c2[e4.name] = e4;
      }), { stack: "dbcore", transaction: e3.transaction.bind(e3), table: function(e4) {
        if (!c2[e4])
          throw new Error("Table '".concat(e4, "' not found"));
        return c2[e4];
      }, MIN_KEY: -1 / 0, MAX_KEY: rn(i2), schema: t3 };
    }
    function ln(e3, t3, n3, r3) {
      var i2 = n3.IDBKeyRange;
      return n3.indexedDB, { dbcore: (r3 = cn(t3, i2, r3), e3.dbcore.reduce(function(e4, t4) {
        t4 = t4.create;
        return _2(_2({}, e4), t4(e4));
      }, r3)) };
    }
    function fn(n3, e3) {
      var t3 = e3.db, e3 = ln(n3._middlewares, t3, n3._deps, e3);
      n3.core = e3.dbcore, n3.tables.forEach(function(e4) {
        var t4 = e4.name;
        n3.core.schema.tables.some(function(e5) {
          return e5.name === t4;
        }) && (e4.core = n3.core.table(t4), n3[t4] instanceof n3.Table && (n3[t4].core = e4.core));
      });
    }
    function hn(i2, e3, t3, o2) {
      t3.forEach(function(n3) {
        var r3 = o2[n3];
        e3.forEach(function(e4) {
          var t4 = d(e4, n3);
          (!t4 || "value" in t4 && void 0 === t4.value) && (e4 === i2.Transaction.prototype || e4 instanceof i2.Transaction ? l2(e4, n3, { get: function() {
            return this.table(n3);
          }, set: function(e5) {
            u2(this, n3, { value: e5, writable: true, configurable: true, enumerable: true });
          } }) : e4[n3] = new i2.Table(n3, r3));
        });
      });
    }
    function dn(n3, e3) {
      e3.forEach(function(e4) {
        for (var t3 in e4)
          e4[t3] instanceof n3.Table && delete e4[t3];
      });
    }
    function pn(e3, t3) {
      return e3._cfg.version - t3._cfg.version;
    }
    function yn(n3, r3, i2, e3) {
      var o2 = n3._dbSchema, a2 = n3._createTransaction("readwrite", n3._storeNames, o2);
      a2.create(i2), a2._completion.catch(e3);
      var u3 = a2._reject.bind(a2), p3 = Pe2.transless || Pe2;
      He2(function() {
        var s2, c2, l3, f3, t3, e4, h3, d2;
        Pe2.trans = a2, Pe2.transless = p3, 0 === r3 ? (k2(o2).forEach(function(e5) {
          mn(i2, e5, o2[e5].primKey, o2[e5].indexes);
        }), fn(n3, i2), je2.follow(function() {
          return n3.on.populate.fire(a2);
        }).catch(u3)) : (c2 = r3, l3 = a2, f3 = i2, t3 = [], e4 = (s2 = n3)._versions, h3 = s2._dbSchema = gn(0, s2.idbdb, f3), d2 = false, e4.filter(function(e5) {
          return e5._cfg.version >= c2;
        }).forEach(function(u4) {
          t3.push(function() {
            var t4 = h3, e5 = u4._cfg.dbschema;
            wn(s2, t4, f3), wn(s2, e5, f3), h3 = s2._dbSchema = e5;
            var n4 = vn(t4, e5);
            n4.add.forEach(function(e6) {
              mn(f3, e6[0], e6[1].primKey, e6[1].indexes);
            }), n4.change.forEach(function(e6) {
              if (e6.recreate)
                throw new Z2.Upgrade("Not yet support for changing primary key");
              var t5 = f3.objectStore(e6.name);
              e6.add.forEach(function(e7) {
                return bn(t5, e7);
              }), e6.change.forEach(function(e7) {
                t5.deleteIndex(e7.name), bn(t5, e7);
              }), e6.del.forEach(function(e7) {
                return t5.deleteIndex(e7);
              });
            });
            var r4 = u4._cfg.contentUpgrade;
            if (r4 && u4._cfg.version > c2) {
              fn(s2, f3), l3._memoizedTables = {}, d2 = true;
              var i3 = P2(e5);
              n4.del.forEach(function(e6) {
                i3[e6] = t4[e6];
              }), dn(s2, [s2.Transaction.prototype]), hn(s2, [s2.Transaction.prototype], k2(i3), i3), l3.schema = i3;
              var o3, a3 = B2(r4);
              a3 && Xe2();
              n4 = je2.follow(function() {
                var e6;
                (o3 = r4(l3)) && a3 && (e6 = Je2.bind(null, null), o3.then(e6, e6));
              });
              return o3 && "function" == typeof o3.then ? je2.resolve(o3) : n4.then(function() {
                return o3;
              });
            }
          }), t3.push(function(e5) {
            var t4, n4, r4;
            d2 && ht || (t4 = u4._cfg.dbschema, n4 = t4, r4 = e5, [].slice.call(r4.db.objectStoreNames).forEach(function(e6) {
              return null == n4[e6] && r4.db.deleteObjectStore(e6);
            })), dn(s2, [s2.Transaction.prototype]), hn(s2, [s2.Transaction.prototype], s2._storeNames, s2._dbSchema), l3.schema = s2._dbSchema;
          });
        }), function e5() {
          return t3.length ? je2.resolve(t3.shift()(l3.idbtrans)).then(e5) : je2.resolve();
        }().then(function() {
          var t4, n4;
          n4 = f3, k2(t4 = h3).forEach(function(e5) {
            n4.db.objectStoreNames.contains(e5) || mn(n4, e5, t4[e5].primKey, t4[e5].indexes);
          });
        }).catch(u3));
      });
    }
    function vn(e3, t3) {
      var n3, r3 = { del: [], add: [], change: [] };
      for (n3 in e3)
        t3[n3] || r3.del.push(n3);
      for (n3 in t3) {
        var i2 = e3[n3], o2 = t3[n3];
        if (i2) {
          var a2 = { name: n3, def: o2, recreate: false, del: [], add: [], change: [] };
          if ("" + (i2.primKey.keyPath || "") != "" + (o2.primKey.keyPath || "") || i2.primKey.auto !== o2.primKey.auto && !ft)
            a2.recreate = true, r3.change.push(a2);
          else {
            var u3 = i2.idxByName, s2 = o2.idxByName, c2 = void 0;
            for (c2 in u3)
              s2[c2] || a2.del.push(c2);
            for (c2 in s2) {
              var l3 = u3[c2], f3 = s2[c2];
              l3 ? l3.src !== f3.src && a2.change.push(f3) : a2.add.push(f3);
            }
            (0 < a2.del.length || 0 < a2.add.length || 0 < a2.change.length) && r3.change.push(a2);
          }
        } else
          r3.add.push([n3, o2]);
      }
      return r3;
    }
    function mn(e3, t3, n3, r3) {
      var i2 = e3.db.createObjectStore(t3, n3.keyPath ? { keyPath: n3.keyPath, autoIncrement: n3.auto } : { autoIncrement: n3.auto });
      return r3.forEach(function(e4) {
        return bn(i2, e4);
      }), i2;
    }
    function bn(e3, t3) {
      e3.createIndex(t3.name, t3.keyPath, { unique: t3.unique, multiEntry: t3.multi });
    }
    function gn(e3, t3, u3) {
      var s2 = {};
      return y2(t3.objectStoreNames, 0).forEach(function(e4) {
        for (var t4 = u3.objectStore(e4), n3 = en(tn(a2 = t4.keyPath), a2 || "", false, false, !!t4.autoIncrement, a2 && "string" != typeof a2, true), r3 = [], i2 = 0; i2 < t4.indexNames.length; ++i2) {
          var o2 = t4.index(t4.indexNames[i2]), a2 = o2.keyPath, o2 = en(o2.name, a2, !!o2.unique, !!o2.multiEntry, false, a2 && "string" != typeof a2, false);
          r3.push(o2);
        }
        s2[e4] = nn(e4, n3, r3);
      }), s2;
    }
    function wn(e3, t3, n3) {
      for (var r3 = n3.db.objectStoreNames, i2 = 0; i2 < r3.length; ++i2) {
        var o2 = r3[i2], a2 = n3.objectStore(o2);
        e3._hasGetAll = "getAll" in a2;
        for (var u3 = 0; u3 < a2.indexNames.length; ++u3) {
          var s2 = a2.indexNames[u3], c2 = a2.index(s2).keyPath, l3 = "string" == typeof c2 ? c2 : "[" + y2(c2).join("+") + "]";
          !t3[o2] || (c2 = t3[o2].idxByName[l3]) && (c2.name = s2, delete t3[o2].idxByName[l3], t3[o2].idxByName[s2] = c2);
        }
      }
      "undefined" != typeof navigator && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && f2.WorkerGlobalScope && f2 instanceof f2.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (e3._hasGetAll = false);
    }
    var _n = (kn.prototype._parseStoresSpec = function(r3, i2) {
      k2(r3).forEach(function(e3) {
        if (null !== r3[e3]) {
          var t3 = r3[e3].split(",").map(function(e4, t4) {
            var n4 = (e4 = e4.trim()).replace(/([&*]|\+\+)/g, ""), r4 = /^\[/.test(n4) ? n4.match(/^\[(.*)\]$/)[1].split("+") : n4;
            return en(n4, r4 || null, /\&/.test(e4), /\*/.test(e4), /\+\+/.test(e4), g2(r4), 0 === t4);
          }), n3 = t3.shift();
          if (n3.multi)
            throw new Z2.Schema("Primary key cannot be multi-valued");
          t3.forEach(function(e4) {
            if (e4.auto)
              throw new Z2.Schema("Only primary key can be marked as autoIncrement (++)");
            if (!e4.keyPath)
              throw new Z2.Schema("Index must have a name and cannot be an empty string");
          }), i2[e3] = nn(e3, n3, t3);
        }
      });
    }, kn.prototype.stores = function(e3) {
      var t3 = this.db;
      this._cfg.storesSource = this._cfg.storesSource ? a(this._cfg.storesSource, e3) : e3;
      var e3 = t3._versions, n3 = {}, r3 = {};
      return e3.forEach(function(e4) {
        a(n3, e4._cfg.storesSource), r3 = e4._cfg.dbschema = {}, e4._parseStoresSpec(n3, r3);
      }), t3._dbSchema = r3, dn(t3, [t3._allTables, t3, t3.Transaction.prototype]), hn(t3, [t3._allTables, t3, t3.Transaction.prototype, this._cfg.tables], k2(r3), r3), t3._storeNames = k2(r3), this;
    }, kn.prototype.upgrade = function(e3) {
      return this._cfg.contentUpgrade = le2(this._cfg.contentUpgrade || ne2, e3), this;
    }, kn);
    function kn() {
    }
    function xn(e3, t3) {
      var n3 = e3._dbNamesDB;
      return n3 || (n3 = e3._dbNamesDB = new ur(pt2, { addons: [], indexedDB: e3, IDBKeyRange: t3 })).version(1).stores({ dbnames: "name" }), n3.table("dbnames");
    }
    function On(e3) {
      return e3 && "function" == typeof e3.databases;
    }
    function Pn(e3) {
      return He2(function() {
        return Pe2.letThrough = true, e3();
      });
    }
    function En(e3) {
      return !("from" in e3);
    }
    var Kn = function(e3, t3) {
      if (!this) {
        var n3 = new Kn();
        return e3 && "d" in e3 && a(n3, e3), n3;
      }
      a(this, arguments.length ? { d: 1, from: e3, to: 1 < arguments.length ? t3 : e3 } : { d: 0 });
    };
    function Sn(e3, t3, n3) {
      var r3 = _t(t3, n3);
      if (!isNaN(r3)) {
        if (0 < r3)
          throw RangeError();
        if (En(e3))
          return a(e3, { from: t3, to: n3, d: 1 });
        var i2 = e3.l, r3 = e3.r;
        if (_t(n3, e3.from) < 0)
          return i2 ? Sn(i2, t3, n3) : e3.l = { from: t3, to: n3, d: 1, l: null, r: null }, qn(e3);
        if (0 < _t(t3, e3.to))
          return r3 ? Sn(r3, t3, n3) : e3.r = { from: t3, to: n3, d: 1, l: null, r: null }, qn(e3);
        _t(t3, e3.from) < 0 && (e3.from = t3, e3.l = null, e3.d = r3 ? r3.d + 1 : 1), 0 < _t(n3, e3.to) && (e3.to = n3, e3.r = null, e3.d = e3.l ? e3.l.d + 1 : 1);
        n3 = !e3.r;
        i2 && !e3.l && jn(e3, i2), r3 && n3 && jn(e3, r3);
      }
    }
    function jn(e3, t3) {
      En(t3) || function e4(t4, n3) {
        var r3 = n3.from, i2 = n3.to, o2 = n3.l, n3 = n3.r;
        Sn(t4, r3, i2), o2 && e4(t4, o2), n3 && e4(t4, n3);
      }(e3, t3);
    }
    function An(e3, t3) {
      var n3 = Cn(t3), r3 = n3.next();
      if (r3.done)
        return false;
      for (var i2 = r3.value, o2 = Cn(e3), a2 = o2.next(i2.from), u3 = a2.value; !r3.done && !a2.done; ) {
        if (_t(u3.from, i2.to) <= 0 && 0 <= _t(u3.to, i2.from))
          return true;
        _t(i2.from, u3.from) < 0 ? i2 = (r3 = n3.next(u3.from)).value : u3 = (a2 = o2.next(i2.from)).value;
      }
      return false;
    }
    function Cn(e3) {
      var n3 = En(e3) ? null : { s: 0, n: e3 };
      return { next: function(e4) {
        for (var t3 = 0 < arguments.length; n3; )
          switch (n3.s) {
            case 0:
              if (n3.s = 1, t3)
                for (; n3.n.l && _t(e4, n3.n.from) < 0; )
                  n3 = { up: n3, n: n3.n.l, s: 1 };
              else
                for (; n3.n.l; )
                  n3 = { up: n3, n: n3.n.l, s: 1 };
            case 1:
              if (n3.s = 2, !t3 || _t(e4, n3.n.to) <= 0)
                return { value: n3.n, done: false };
            case 2:
              if (n3.n.r) {
                n3.s = 3, n3 = { up: n3, n: n3.n.r, s: 0 };
                continue;
              }
            case 3:
              n3 = n3.up;
          }
        return { done: true };
      } };
    }
    function qn(e3) {
      var t3, n3, r3 = ((null === (t3 = e3.r) || void 0 === t3 ? void 0 : t3.d) || 0) - ((null === (n3 = e3.l) || void 0 === n3 ? void 0 : n3.d) || 0), i2 = 1 < r3 ? "r" : r3 < -1 ? "l" : "";
      i2 && (t3 = "r" == i2 ? "l" : "r", n3 = _2({}, e3), r3 = e3[i2], e3.from = r3.from, e3.to = r3.to, e3[i2] = r3[i2], n3[i2] = r3[t3], (e3[t3] = n3).d = Dn(n3)), e3.d = Dn(e3);
    }
    function Dn(e3) {
      var t3 = e3.r, e3 = e3.l;
      return (t3 ? e3 ? Math.max(t3.d, e3.d) : t3.d : e3 ? e3.d : 0) + 1;
    }
    function Tn(t3, n3) {
      return k2(n3).forEach(function(e3) {
        t3[e3] ? jn(t3[e3], n3[e3]) : t3[e3] = function e4(t4) {
          var n4, r3, i2 = {};
          for (n4 in t4)
            m2(t4, n4) && (r3 = t4[n4], i2[n4] = !r3 || "object" != typeof r3 || K2.has(r3.constructor) ? r3 : e4(r3));
          return i2;
        }(n3[e3]);
      }), t3;
    }
    function In(t3, n3) {
      return Object.keys(t3).some(function(e3) {
        return n3[e3] && An(n3[e3], t3[e3]);
      });
    }
    r2(Kn.prototype, ((W2 = { add: function(e3) {
      return jn(this, e3), this;
    }, addKey: function(e3) {
      return Sn(this, e3, e3), this;
    }, addKeys: function(e3) {
      var t3 = this;
      return e3.forEach(function(e4) {
        return Sn(t3, e4, e4);
      }), this;
    } })[q2] = function() {
      return Cn(this);
    }, W2));
    var Rn = {}, Bn = {}, Fn = false;
    function Mn(e3) {
      Tn(Bn, e3), Fn || (Fn = true, setTimeout(function() {
        Fn = false;
        var e4 = Bn;
        Bn = {}, Nn(e4);
      }, 0));
    }
    function Nn(e3, t3) {
      void 0 === t3 && (t3 = false);
      var n3, r3 = /* @__PURE__ */ new Set();
      for (n3 in e3) {
        var i2, o2 = /^idb\:\/\/(.*)\/(.*)\//.exec(n3);
        o2 && (i2 = o2[1], o2 = o2[2], (o2 = Rn["idb://".concat(i2, "/").concat(o2)]) && function(e4, t4, n4, r4) {
          for (var i3 = r4 && [], o3 = 0, a2 = Object.entries(e4.queries.query); o3 < a2.length; o3++) {
            for (var u3 = a2[o3], s2 = u3[0], u3 = u3[1], c2 = r4 && [], l3 = 0, f3 = u3; l3 < f3.length; l3++) {
              var h3 = f3[l3];
              h3.obsSet && In(t4, h3.obsSet) ? h3.subscribers.forEach(function(e5) {
                return n4.add(e5);
              }) : r4 && c2.push(h3);
            }
            r4 && i3.push([s2, c2]);
          }
          if (r4)
            for (var d2 = 0, p3 = i3; d2 < p3.length; d2++) {
              var y3 = p3[d2], s2 = y3[0], c2 = y3[1];
              e4.queries.query[s2] = c2;
            }
        }(o2, e3, r3, t3));
      }
      r3.forEach(function(e4) {
        return e4();
      });
    }
    function Ln(f3) {
      var h3 = f3._state, r3 = f3._deps.indexedDB;
      if (h3.isBeingOpened || f3.idbdb)
        return h3.dbReadyPromise.then(function() {
          return h3.dbOpenError ? ot(h3.dbOpenError) : f3;
        });
      F2 && (h3.openCanceller._stackHolder = U2()), h3.isBeingOpened = true, h3.dbOpenError = null, h3.openComplete = false;
      var t3 = h3.openCanceller;
      function e3() {
        if (h3.openCanceller !== t3)
          throw new Z2.DatabaseClosed("db.open() was cancelled");
      }
      function n3() {
        return new je2(function(s2, n4) {
          if (e3(), !r3)
            throw new Z2.MissingAPI();
          var c2 = f3.name, l3 = h3.autoSchema ? r3.open(c2) : r3.open(c2, Math.round(10 * f3.verno));
          if (!l3)
            throw new Z2.MissingAPI();
          l3.onerror = Qt(n4), l3.onblocked = Ue2(f3._fireOnBlocked), l3.onupgradeneeded = Ue2(function(e4) {
            var t4;
            d2 = l3.transaction, h3.autoSchema && !f3._options.allowEmptyDB ? (l3.onerror = Gt, d2.abort(), l3.result.close(), (t4 = r3.deleteDatabase(c2)).onsuccess = t4.onerror = Ue2(function() {
              n4(new Z2.NoSuchDatabase("Database ".concat(c2, " doesnt exist")));
            })) : (d2.onerror = Qt(n4), e4 = e4.oldVersion > Math.pow(2, 62) ? 0 : e4.oldVersion, p3 = e4 < 1, f3.idbdb = l3.result, yn(f3, e4 / 10, d2, n4));
          }, n4), l3.onsuccess = Ue2(function() {
            d2 = null;
            var e4, t4, n5, r4, i3, o3 = f3.idbdb = l3.result, a2 = y2(o3.objectStoreNames);
            if (0 < a2.length)
              try {
                var u3 = o3.transaction(1 === (r4 = a2).length ? r4[0] : r4, "readonly");
                h3.autoSchema ? (t4 = o3, n5 = u3, (e4 = f3).verno = t4.version / 10, n5 = e4._dbSchema = gn(0, t4, n5), e4._storeNames = y2(t4.objectStoreNames, 0), hn(e4, [e4._allTables], k2(n5), n5)) : (wn(f3, f3._dbSchema, u3), ((i3 = vn(gn(0, (i3 = f3).idbdb, u3), i3._dbSchema)).add.length || i3.change.some(function(e5) {
                  return e5.add.length || e5.change.length;
                })) && console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.")), fn(f3, u3);
              } catch (e5) {
              }
            lt2.push(f3), o3.onversionchange = Ue2(function(e5) {
              h3.vcFired = true, f3.on("versionchange").fire(e5);
            }), o3.onclose = Ue2(function(e5) {
              f3.on("close").fire(e5);
            }), p3 && (i3 = f3._deps, u3 = c2, o3 = i3.indexedDB, i3 = i3.IDBKeyRange, On(o3) || u3 === pt2 || xn(o3, i3).put({ name: u3 }).catch(ne2)), s2();
          }, n4);
        }).catch(function(e4) {
          return e4 && "UnknownError" === e4.name && 0 < h3.PR1398_maxLoop ? (h3.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), n3()) : je2.reject(e4);
        });
      }
      var i2, o2 = h3.dbReadyResolve, d2 = null, p3 = false;
      return je2.race([t3, ("undefined" == typeof navigator ? je2.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(e4) {
        function t4() {
          return indexedDB.databases().finally(e4);
        }
        i2 = setInterval(t4, 100), t4();
      }).finally(function() {
        return clearInterval(i2);
      }) : Promise.resolve()).then(n3)]).then(function() {
        return e3(), h3.onReadyBeingFired = [], je2.resolve(Pn(function() {
          return f3.on.ready.fire(f3.vip);
        })).then(function e4() {
          if (0 < h3.onReadyBeingFired.length) {
            var t4 = h3.onReadyBeingFired.reduce(le2, ne2);
            return h3.onReadyBeingFired = [], je2.resolve(Pn(function() {
              return t4(f3.vip);
            })).then(e4);
          }
        });
      }).finally(function() {
        h3.openCanceller === t3 && (h3.onReadyBeingFired = null, h3.isBeingOpened = false);
      }).catch(function(e4) {
        h3.dbOpenError = e4;
        try {
          d2 && d2.abort();
        } catch (e5) {
        }
        return t3 === h3.openCanceller && f3._close(), ot(e4);
      }).finally(function() {
        h3.openComplete = true, o2();
      }).then(function() {
        var n4;
        return p3 && (n4 = {}, f3.tables.forEach(function(t4) {
          t4.schema.indexes.forEach(function(e4) {
            e4.name && (n4["idb://".concat(f3.name, "/").concat(t4.name, "/").concat(e4.name)] = new Kn(-1 / 0, [[[]]]));
          }), n4["idb://".concat(f3.name, "/").concat(t4.name, "/")] = n4["idb://".concat(f3.name, "/").concat(t4.name, "/:dels")] = new Kn(-1 / 0, [[[]]]);
        }), Jt(Ht).fire(n4), Nn(n4, true)), f3;
      });
    }
    function Un(t3) {
      function e3(e4) {
        return t3.next(e4);
      }
      var r3 = n3(e3), i2 = n3(function(e4) {
        return t3.throw(e4);
      });
      function n3(n4) {
        return function(e4) {
          var t4 = n4(e4), e4 = t4.value;
          return t4.done ? e4 : e4 && "function" == typeof e4.then ? e4.then(r3, i2) : g2(e4) ? Promise.all(e4).then(r3, i2) : r3(e4);
        };
      }
      return n3(e3)();
    }
    function zn(e3, t3, n3) {
      for (var r3 = g2(e3) ? e3.slice() : [e3], i2 = 0; i2 < n3; ++i2)
        r3.push(t3);
      return r3;
    }
    var Vn = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(f3) {
      return _2(_2({}, f3), { table: function(e3) {
        var a2 = f3.table(e3), t3 = a2.schema, u3 = {}, s2 = [];
        function c2(e4, t4, n4) {
          var r4 = sn(e4), i3 = u3[r4] = u3[r4] || [], o2 = null == e4 ? 0 : "string" == typeof e4 ? 1 : e4.length, a3 = 0 < t4, a3 = _2(_2({}, n4), { name: a3 ? "".concat(r4, "(virtual-from:").concat(n4.name, ")") : n4.name, lowLevelIndex: n4, isVirtual: a3, keyTail: t4, keyLength: o2, extractKey: on(e4), unique: !a3 && n4.unique });
          return i3.push(a3), a3.isPrimaryKey || s2.push(a3), 1 < o2 && c2(2 === o2 ? e4[0] : e4.slice(0, o2 - 1), t4 + 1, n4), i3.sort(function(e5, t5) {
            return e5.keyTail - t5.keyTail;
          }), a3;
        }
        e3 = c2(t3.primaryKey.keyPath, 0, t3.primaryKey);
        u3[":id"] = [e3];
        for (var n3 = 0, r3 = t3.indexes; n3 < r3.length; n3++) {
          var i2 = r3[n3];
          c2(i2.keyPath, 0, i2);
        }
        function l3(e4) {
          var t4, n4 = e4.query.index;
          return n4.isVirtual ? _2(_2({}, e4), { query: { index: n4.lowLevelIndex, range: (t4 = e4.query.range, n4 = n4.keyTail, { type: 1 === t4.type ? 2 : t4.type, lower: zn(t4.lower, t4.lowerOpen ? f3.MAX_KEY : f3.MIN_KEY, n4), lowerOpen: true, upper: zn(t4.upper, t4.upperOpen ? f3.MIN_KEY : f3.MAX_KEY, n4), upperOpen: true }) } }) : e4;
        }
        return _2(_2({}, a2), { schema: _2(_2({}, t3), { primaryKey: e3, indexes: s2, getIndexByKeyPath: function(e4) {
          return (e4 = u3[sn(e4)]) && e4[0];
        } }), count: function(e4) {
          return a2.count(l3(e4));
        }, query: function(e4) {
          return a2.query(l3(e4));
        }, openCursor: function(t4) {
          var e4 = t4.query.index, r4 = e4.keyTail, n4 = e4.isVirtual, i3 = e4.keyLength;
          return n4 ? a2.openCursor(l3(t4)).then(function(e5) {
            return e5 && o2(e5);
          }) : a2.openCursor(t4);
          function o2(n5) {
            return Object.create(n5, { continue: { value: function(e5) {
              null != e5 ? n5.continue(zn(e5, t4.reverse ? f3.MAX_KEY : f3.MIN_KEY, r4)) : t4.unique ? n5.continue(n5.key.slice(0, i3).concat(t4.reverse ? f3.MIN_KEY : f3.MAX_KEY, r4)) : n5.continue();
            } }, continuePrimaryKey: { value: function(e5, t5) {
              n5.continuePrimaryKey(zn(e5, f3.MAX_KEY, r4), t5);
            } }, primaryKey: { get: function() {
              return n5.primaryKey;
            } }, key: { get: function() {
              var e5 = n5.key;
              return 1 === i3 ? e5[0] : e5.slice(0, i3);
            } }, value: { get: function() {
              return n5.value;
            } } });
          }
        } });
      } });
    } };
    function Wn(i2, o2, a2, u3) {
      return a2 = a2 || {}, u3 = u3 || "", k2(i2).forEach(function(e3) {
        var t3, n3, r3;
        m2(o2, e3) ? (t3 = i2[e3], n3 = o2[e3], "object" == typeof t3 && "object" == typeof n3 && t3 && n3 ? (r3 = C2(t3)) !== C2(n3) ? a2[u3 + e3] = o2[e3] : "Object" === r3 ? Wn(t3, n3, a2, u3 + e3 + ".") : t3 !== n3 && (a2[u3 + e3] = o2[e3]) : t3 !== n3 && (a2[u3 + e3] = o2[e3])) : a2[u3 + e3] = void 0;
      }), k2(o2).forEach(function(e3) {
        m2(i2, e3) || (a2[u3 + e3] = o2[e3]);
      }), a2;
    }
    function Yn(e3, t3) {
      return "delete" === t3.type ? t3.keys : t3.keys || t3.values.map(e3.extractKey);
    }
    var Qn = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(e3) {
      return _2(_2({}, e3), { table: function(r3) {
        var y3 = e3.table(r3), v3 = y3.schema.primaryKey;
        return _2(_2({}, y3), { mutate: function(e4) {
          var t3 = Pe2.trans, n3 = t3.table(r3).hook, h3 = n3.deleting, d2 = n3.creating, p3 = n3.updating;
          switch (e4.type) {
            case "add":
              if (d2.fire === ne2)
                break;
              return t3._promise("readwrite", function() {
                return a2(e4);
              }, true);
            case "put":
              if (d2.fire === ne2 && p3.fire === ne2)
                break;
              return t3._promise("readwrite", function() {
                return a2(e4);
              }, true);
            case "delete":
              if (h3.fire === ne2)
                break;
              return t3._promise("readwrite", function() {
                return a2(e4);
              }, true);
            case "deleteRange":
              if (h3.fire === ne2)
                break;
              return t3._promise("readwrite", function() {
                return function n4(r4, i2, o2) {
                  return y3.query({ trans: r4, values: false, query: { index: v3, range: i2 }, limit: o2 }).then(function(e5) {
                    var t4 = e5.result;
                    return a2({ type: "delete", keys: t4, trans: r4 }).then(function(e6) {
                      return 0 < e6.numFailures ? Promise.reject(e6.failures[0]) : t4.length < o2 ? { failures: [], numFailures: 0, lastResult: void 0 } : n4(r4, _2(_2({}, i2), { lower: t4[t4.length - 1], lowerOpen: true }), o2);
                    });
                  });
                }(e4.trans, e4.range, 1e4);
              }, true);
          }
          return y3.mutate(e4);
          function a2(c2) {
            var e5, t4, n4, l3 = Pe2.trans, f3 = c2.keys || Yn(v3, c2);
            if (!f3)
              throw new Error("Keys missing");
            return "delete" !== (c2 = "add" === c2.type || "put" === c2.type ? _2(_2({}, c2), { keys: f3 }) : _2({}, c2)).type && (c2.values = i([], c2.values, true)), c2.keys && (c2.keys = i([], c2.keys, true)), e5 = y3, n4 = f3, ("add" === (t4 = c2).type ? Promise.resolve([]) : e5.getMany({ trans: t4.trans, keys: n4, cache: "immutable" })).then(function(u3) {
              var s2 = f3.map(function(e6, t5) {
                var n5, r4, i2, o2 = u3[t5], a3 = { onerror: null, onsuccess: null };
                return "delete" === c2.type ? h3.fire.call(a3, e6, o2, l3) : "add" === c2.type || void 0 === o2 ? (n5 = d2.fire.call(a3, e6, c2.values[t5], l3), null == e6 && null != n5 && (c2.keys[t5] = e6 = n5, v3.outbound || O2(c2.values[t5], v3.keyPath, e6))) : (n5 = Wn(o2, c2.values[t5]), (r4 = p3.fire.call(a3, n5, e6, o2, l3)) && (i2 = c2.values[t5], Object.keys(r4).forEach(function(e7) {
                  m2(i2, e7) ? i2[e7] = r4[e7] : O2(i2, e7, r4[e7]);
                }))), a3;
              });
              return y3.mutate(c2).then(function(e6) {
                for (var t5 = e6.failures, n5 = e6.results, r4 = e6.numFailures, e6 = e6.lastResult, i2 = 0; i2 < f3.length; ++i2) {
                  var o2 = (n5 || f3)[i2], a3 = s2[i2];
                  null == o2 ? a3.onerror && a3.onerror(t5[i2]) : a3.onsuccess && a3.onsuccess("put" === c2.type && u3[i2] ? c2.values[i2] : o2);
                }
                return { failures: t5, results: n5, numFailures: r4, lastResult: e6 };
              }).catch(function(t5) {
                return s2.forEach(function(e6) {
                  return e6.onerror && e6.onerror(t5);
                }), Promise.reject(t5);
              });
            });
          }
        } });
      } });
    } };
    function Gn(e3, t3, n3) {
      try {
        if (!t3)
          return null;
        if (t3.keys.length < e3.length)
          return null;
        for (var r3 = [], i2 = 0, o2 = 0; i2 < t3.keys.length && o2 < e3.length; ++i2)
          0 === _t(t3.keys[i2], e3[o2]) && (r3.push(n3 ? j2(t3.values[i2]) : t3.values[i2]), ++o2);
        return r3.length === e3.length ? r3 : null;
      } catch (e4) {
        return null;
      }
    }
    var Hn = { stack: "dbcore", level: -1, create: function(t3) {
      return { table: function(e3) {
        var n3 = t3.table(e3);
        return _2(_2({}, n3), { getMany: function(t4) {
          if (!t4.cache)
            return n3.getMany(t4);
          var e4 = Gn(t4.keys, t4.trans._cache, "clone" === t4.cache);
          return e4 ? je2.resolve(e4) : n3.getMany(t4).then(function(e5) {
            return t4.trans._cache = { keys: t4.keys, values: "clone" === t4.cache ? j2(e5) : e5 }, e5;
          });
        }, mutate: function(e4) {
          return "add" !== e4.type && (e4.trans._cache = null), n3.mutate(e4);
        } });
      } };
    } };
    function Xn(e3, t3) {
      return "readonly" === e3.trans.mode && !!e3.subscr && !e3.trans.explicit && "disabled" !== e3.trans.db._options.cache && !t3.schema.primaryKey.outbound;
    }
    function Jn(e3, t3) {
      switch (e3) {
        case "query":
          return t3.values && !t3.unique;
        case "get":
        case "getMany":
        case "count":
        case "openCursor":
          return false;
      }
    }
    var $n = { stack: "dbcore", level: 0, name: "Observability", create: function(r3) {
      var m3 = r3.schema.name, b3 = new Kn(r3.MIN_KEY, r3.MAX_KEY);
      return _2(_2({}, r3), { transaction: function(e3, t3, n3) {
        if (Pe2.subscr && "readonly" !== t3)
          throw new Z2.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(Pe2.querier));
        return r3.transaction(e3, t3, n3);
      }, table: function(d2) {
        function e3(e4) {
          var e4 = (t4 = e4.query).index, t4 = t4.range;
          return [e4, new Kn(null !== (e4 = t4.lower) && void 0 !== e4 ? e4 : r3.MIN_KEY, null !== (t4 = t4.upper) && void 0 !== t4 ? t4 : r3.MAX_KEY)];
        }
        var p3 = r3.table(d2), y3 = p3.schema, v3 = y3.primaryKey, c2 = v3.extractKey, l3 = v3.outbound, t3 = _2(_2({}, p3), { mutate: function(t4) {
          function n3(e5) {
            return e5 = "idb://".concat(m3, "/").concat(d2, "/").concat(e5), i2[e5] || (i2[e5] = new Kn());
          }
          var e4, o2, a2, r4 = t4.trans, i2 = t4.mutatedParts || (t4.mutatedParts = {}), u3 = n3(""), s2 = n3(":dels"), c3 = t4.type, l4 = "deleteRange" === t4.type ? [t4.range] : "delete" === t4.type ? [t4.keys] : t4.values.length < 50 ? [Yn(v3, t4).filter(function(e5) {
            return e5;
          }), t4.values] : [], f4 = l4[0], h3 = l4[1], l4 = t4.trans._cache;
          return g2(f4) ? (u3.addKeys(f4), (l4 = "delete" === c3 || f4.length === h3.length ? Gn(f4, l4) : null) || "add" === c3 || s2.addKeys(f4), (l4 || h3) && (e4 = n3, o2 = l4, a2 = h3, y3.indexes.forEach(function(t5) {
            var n4 = e4(t5.name || "");
            function r5(e5) {
              return null != e5 ? t5.extractKey(e5) : null;
            }
            function i3(e5) {
              return t5.multiEntry && g2(e5) ? e5.forEach(function(e6) {
                return n4.addKey(e6);
              }) : n4.addKey(e5);
            }
            (o2 || a2).forEach(function(e5, t6) {
              var n5 = o2 && r5(o2[t6]), t6 = a2 && r5(a2[t6]);
              0 !== _t(n5, t6) && (null != n5 && i3(n5), null != t6 && i3(t6));
            });
          }))) : f4 ? (h3 = { from: f4.lower, to: f4.upper }, s2.add(h3), u3.add(h3)) : (u3.add(b3), s2.add(b3), y3.indexes.forEach(function(e5) {
            return n3(e5.name).add(b3);
          })), p3.mutate(t4).then(function(e5) {
            return !f4 || "add" !== t4.type && "put" !== t4.type || u3.addKeys(e5.results), r4.mutatedParts = Tn(r4.mutatedParts || {}, i2), e5;
          });
        } }), f3 = { get: function(e4) {
          return [v3, new Kn(e4.key)];
        }, getMany: function(e4) {
          return [v3, new Kn().addKeys(e4.keys)];
        }, count: e3, query: e3, openCursor: e3 };
        return k2(f3).forEach(function(s2) {
          t3[s2] = function(i2) {
            var e4 = Pe2.subscr, t4 = !!e4, n3 = Xn(Pe2, p3) && Jn(s2, i2) ? i2.obsSet = {} : e4;
            if (t4) {
              var r4 = function(e5) {
                e5 = "idb://".concat(m3, "/").concat(d2, "/").concat(e5);
                return n3[e5] || (n3[e5] = new Kn());
              }, o2 = r4(""), a2 = r4(":dels"), e4 = f3[s2](i2), t4 = e4[0], e4 = e4[1];
              if (r4(t4.name || "").add(e4), !t4.isPrimaryKey) {
                if ("count" !== s2) {
                  var u3 = "query" === s2 && l3 && i2.values && p3.query(_2(_2({}, i2), { values: false }));
                  return p3[s2].apply(this, arguments).then(function(t5) {
                    if ("query" === s2) {
                      if (l3 && i2.values)
                        return u3.then(function(e6) {
                          e6 = e6.result;
                          return o2.addKeys(e6), t5;
                        });
                      var e5 = i2.values ? t5.result.map(c2) : t5.result;
                      (i2.values ? o2 : a2).addKeys(e5);
                    } else if ("openCursor" === s2) {
                      var n4 = t5, r5 = i2.values;
                      return n4 && Object.create(n4, { key: { get: function() {
                        return a2.addKey(n4.primaryKey), n4.key;
                      } }, primaryKey: { get: function() {
                        var e6 = n4.primaryKey;
                        return a2.addKey(e6), e6;
                      } }, value: { get: function() {
                        return r5 && o2.addKey(n4.primaryKey), n4.value;
                      } } });
                    }
                    return t5;
                  });
                }
                a2.add(b3);
              }
            }
            return p3[s2].apply(this, arguments);
          };
        }), t3;
      } });
    } };
    function Zn(e3, t3, n3) {
      if (0 === n3.numFailures)
        return t3;
      if ("deleteRange" === t3.type)
        return null;
      var r3 = t3.keys ? t3.keys.length : "values" in t3 && t3.values ? t3.values.length : 1;
      if (n3.numFailures === r3)
        return null;
      t3 = _2({}, t3);
      return g2(t3.keys) && (t3.keys = t3.keys.filter(function(e4, t4) {
        return !(t4 in n3.failures);
      })), "values" in t3 && g2(t3.values) && (t3.values = t3.values.filter(function(e4, t4) {
        return !(t4 in n3.failures);
      })), t3;
    }
    function er(e3, t3) {
      return n3 = e3, (void 0 === (r3 = t3).lower || (r3.lowerOpen ? 0 < _t(n3, r3.lower) : 0 <= _t(n3, r3.lower))) && (e3 = e3, void 0 === (t3 = t3).upper || (t3.upperOpen ? _t(e3, t3.upper) < 0 : _t(e3, t3.upper) <= 0));
      var n3, r3;
    }
    function tr(e3, u3, t3, n3, r3, s2) {
      if (!t3 || 0 === t3.length)
        return e3;
      var i2 = u3.query.index, c2 = n3.schema.primaryKey.extractKey, l3 = i2.extractKey, o2 = (i2.lowLevelIndex || i2).extractKey, t3 = t3.reduce(function(e4, t4) {
        var n4 = e4, r4 = "add" === t4.type || "put" === t4.type ? t4.values.filter(function(e5) {
          return er(l3(e5), u3.query.range);
        }).map(function(e5) {
          return e5 = j2(e5), s2 && Object.freeze(e5), e5;
        }) : [];
        switch (t4.type) {
          case "add":
            n4 = e4.concat(u3.values ? r4 : r4.map(function(e5) {
              return c2(e5);
            }));
            break;
          case "put":
            var i3 = new Kn().addKeys(t4.values.map(function(e5) {
              return c2(e5);
            })), n4 = e4.filter(function(e5) {
              e5 = u3.values ? c2(e5) : e5;
              return !An(new Kn(e5), i3);
            }).concat(u3.values ? r4 : r4.map(function(e5) {
              return c2(e5);
            }));
            break;
          case "delete":
            var o3 = new Kn().addKeys(t4.keys);
            n4 = e4.filter(function(e5) {
              e5 = u3.values ? c2(e5) : e5;
              return !An(new Kn(e5), o3);
            });
            break;
          case "deleteRange":
            var a2 = t4.range;
            n4 = e4.filter(function(e5) {
              return !er(c2(e5), a2);
            });
        }
        return n4;
      }, e3);
      return t3 === e3 ? e3 : (t3.sort(function(e4, t4) {
        return _t(o2(e4), o2(t4)) || _t(c2(e4), c2(t4));
      }), u3.limit && u3.limit < 1 / 0 && (t3.length > u3.limit ? t3.length = u3.limit : e3.length === u3.limit && t3.length < u3.limit && (r3.dirty = true)), s2 ? Object.freeze(t3) : t3);
    }
    function nr(e3, t3) {
      return 0 === _t(e3.lower, t3.lower) && 0 === _t(e3.upper, t3.upper) && !!e3.lowerOpen == !!t3.lowerOpen && !!e3.upperOpen == !!t3.upperOpen;
    }
    function rr(e3, t3) {
      return function(e4, t4, n3, r3) {
        if (void 0 === e4)
          return void 0 !== t4 ? -1 : 0;
        if (void 0 === t4)
          return 1;
        if (0 === (t4 = _t(e4, t4))) {
          if (n3 && r3)
            return 0;
          if (n3)
            return 1;
          if (r3)
            return -1;
        }
        return t4;
      }(e3.lower, t3.lower, e3.lowerOpen, t3.lowerOpen) <= 0 && 0 <= function(e4, t4, n3, r3) {
        if (void 0 === e4)
          return void 0 !== t4 ? 1 : 0;
        if (void 0 === t4)
          return -1;
        if (0 === (t4 = _t(e4, t4))) {
          if (n3 && r3)
            return 0;
          if (n3)
            return -1;
          if (r3)
            return 1;
        }
        return t4;
      }(e3.upper, t3.upper, e3.upperOpen, t3.upperOpen);
    }
    function ir(n3, r3, i2, e3) {
      n3.subscribers.add(i2), e3.addEventListener("abort", function() {
        var e4, t3;
        n3.subscribers.delete(i2), 0 === n3.subscribers.size && (e4 = n3, t3 = r3, setTimeout(function() {
          0 === e4.subscribers.size && T2(t3, e4);
        }, 3e3));
      });
    }
    var or = { stack: "dbcore", level: 0, name: "Cache", create: function(g3) {
      var w3 = g3.schema.name;
      return _2(_2({}, g3), { transaction: function(y3, v3, e3) {
        var m3, t3, b3 = g3.transaction(y3, v3, e3);
        return "readwrite" === v3 && (t3 = (m3 = new AbortController()).signal, e3 = function(p3) {
          return function() {
            if (m3.abort(), "readwrite" === v3) {
              for (var t4 = /* @__PURE__ */ new Set(), e4 = 0, n3 = y3; e4 < n3.length; e4++) {
                var r3 = n3[e4], i2 = Rn["idb://".concat(w3, "/").concat(r3)], o2 = g3.table(r3);
                if (i2) {
                  var a2 = i2.optimisticOps.filter(function(e5) {
                    return e5.trans === b3;
                  });
                  if (0 < a2.length) {
                    i2.optimisticOps = i2.optimisticOps.filter(function(e5) {
                      return e5.trans !== b3;
                    });
                    for (var u3 = 0, s2 = Object.values(i2.queries.query); u3 < s2.length; u3++)
                      for (var c2 = s2[u3], l3 = 0, f3 = c2.slice(); l3 < f3.length; l3++) {
                        var h3, d2 = f3[l3];
                        null != d2.res && b3.mutatedParts && (p3 && !d2.dirty ? (h3 = Object.isFrozen(d2.res), h3 = tr(d2.res, d2.req, a2, o2, d2, h3), d2.dirty ? (T2(c2, d2), d2.subscribers.forEach(function(e5) {
                          return t4.add(e5);
                        })) : h3 !== d2.res && (d2.res = h3, d2.promise = je2.resolve({ result: h3 }))) : (d2.dirty && T2(c2, d2), d2.subscribers.forEach(function(e5) {
                          return t4.add(e5);
                        })));
                      }
                  }
                }
              }
              t4.forEach(function(e5) {
                return e5();
              });
            }
          };
        }, b3.addEventListener("abort", e3(false), { signal: t3 }), b3.addEventListener("error", e3(false), { signal: t3 }), b3.addEventListener("complete", e3(true), { signal: t3 })), b3;
      }, table: function(c2) {
        var l3 = g3.table(c2), i2 = l3.schema.primaryKey;
        return _2(_2({}, l3), { mutate: function(t3) {
          if (i2.outbound || "disabled" === Pe2.trans.db._options.cache)
            return l3.mutate(t3);
          var r3 = Rn["idb://".concat(w3, "/").concat(c2)];
          if (!r3)
            return l3.mutate(t3);
          var e3 = l3.mutate(t3);
          return "add" !== t3.type && "put" !== t3.type || !(50 <= t3.values.length || Yn(i2, t3).some(function(e4) {
            return null == e4;
          })) ? (r3.optimisticOps.push(t3), Mn(t3.mutatedParts), e3.then(function(e4) {
            0 < e4.numFailures && (T2(r3.optimisticOps, t3), (e4 = Zn(0, t3, e4)) && r3.optimisticOps.push(e4), Mn(t3.mutatedParts));
          }), e3.catch(function() {
            T2(r3.optimisticOps, t3), Mn(t3.mutatedParts);
          })) : e3.then(function(n3) {
            var e4 = Zn(0, _2(_2({}, t3), { values: t3.values.map(function(e5, t4) {
              e5 = i2.keyPath.includes(".") ? j2(e5) : _2({}, e5);
              return O2(e5, i2.keyPath, n3.results[t4]), e5;
            }) }), n3);
            r3.optimisticOps.push(e4), queueMicrotask(function() {
              return Mn(t3.mutatedParts);
            });
          }), e3;
        }, query: function(t3) {
          if (!Xn(Pe2, l3) || !Jn("query", t3))
            return l3.query(t3);
          var i3 = "immutable" === Pe2.trans.db._options.cache, e3 = Pe2, n3 = e3.requery, r3 = e3.signal, o2 = function(e4, t4, n4, r4) {
            var i4 = Rn["idb://".concat(e4, "/").concat(t4)];
            if (!i4)
              return [];
            if (!(t4 = i4.queries[n4]))
              return [null, false, i4, null];
            var o3 = t4[(r4.query ? r4.query.index.name : null) || ""];
            if (!o3)
              return [null, false, i4, null];
            switch (n4) {
              case "query":
                var a3 = o3.find(function(e5) {
                  return e5.req.limit === r4.limit && e5.req.values === r4.values && nr(e5.req.query.range, r4.query.range);
                });
                return a3 ? [a3, true, i4, o3] : [o3.find(function(e5) {
                  return ("limit" in e5.req ? e5.req.limit : 1 / 0) >= r4.limit && (!r4.values || e5.req.values) && rr(e5.req.query.range, r4.query.range);
                }), false, i4, o3];
              case "count":
                a3 = o3.find(function(e5) {
                  return nr(e5.req.query.range, r4.query.range);
                });
                return [a3, !!a3, i4, o3];
            }
          }(w3, c2, "query", t3), a2 = o2[0], e3 = o2[1], u3 = o2[2], s2 = o2[3];
          return a2 && e3 ? a2.obsSet = t3.obsSet : (e3 = l3.query(t3).then(function(e4) {
            var t4 = e4.result;
            if (a2.res = t4, i3) {
              for (var n4 = 0, r4 = t4.length; n4 < r4; ++n4)
                Object.freeze(t4[n4]);
              Object.freeze(t4);
            } else
              e4.result = j2(t4);
            return e4;
          }).catch(function(e4) {
            return s2 && a2 && T2(s2, a2), Promise.reject(e4);
          }), a2 = { obsSet: t3.obsSet, promise: e3, subscribers: /* @__PURE__ */ new Set(), type: "query", req: t3, dirty: false }, s2 ? s2.push(a2) : (s2 = [a2], (u3 = u3 || (Rn["idb://".concat(w3, "/").concat(c2)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[t3.query.index.name || ""] = s2)), ir(a2, s2, n3, r3), a2.promise.then(function(e4) {
            return { result: tr(e4.result, t3, null == u3 ? void 0 : u3.optimisticOps, l3, a2, i3) };
          });
        } });
      } });
    } };
    function ar(e3, r3) {
      return new Proxy(e3, { get: function(e4, t3, n3) {
        return "db" === t3 ? r3 : Reflect.get(e4, t3, n3);
      } });
    }
    var ur = (sr.prototype.version = function(t3) {
      if (isNaN(t3) || t3 < 0.1)
        throw new Z2.Type("Given version is not a positive number");
      if (t3 = Math.round(10 * t3) / 10, this.idbdb || this._state.isBeingOpened)
        throw new Z2.Schema("Cannot add version when database is open");
      this.verno = Math.max(this.verno, t3);
      var e3 = this._versions, n3 = e3.filter(function(e4) {
        return e4._cfg.version === t3;
      })[0];
      return n3 || (n3 = new this.Version(t3), e3.push(n3), e3.sort(pn), n3.stores({}), this._state.autoSchema = false, n3);
    }, sr.prototype._whenReady = function(e3) {
      var n3 = this;
      return this.idbdb && (this._state.openComplete || Pe2.letThrough || this._vip) ? e3() : new je2(function(e4, t3) {
        if (n3._state.openComplete)
          return t3(new Z2.DatabaseClosed(n3._state.dbOpenError));
        if (!n3._state.isBeingOpened) {
          if (!n3._options.autoOpen)
            return void t3(new Z2.DatabaseClosed());
          n3.open().catch(ne2);
        }
        n3._state.dbReadyPromise.then(e4, t3);
      }).then(e3);
    }, sr.prototype.use = function(e3) {
      var t3 = e3.stack, n3 = e3.create, r3 = e3.level, i2 = e3.name;
      i2 && this.unuse({ stack: t3, name: i2 });
      e3 = this._middlewares[t3] || (this._middlewares[t3] = []);
      return e3.push({ stack: t3, create: n3, level: null == r3 ? 10 : r3, name: i2 }), e3.sort(function(e4, t4) {
        return e4.level - t4.level;
      }), this;
    }, sr.prototype.unuse = function(e3) {
      var t3 = e3.stack, n3 = e3.name, r3 = e3.create;
      return t3 && this._middlewares[t3] && (this._middlewares[t3] = this._middlewares[t3].filter(function(e4) {
        return r3 ? e4.create !== r3 : !!n3 && e4.name !== n3;
      })), this;
    }, sr.prototype.open = function() {
      var e3 = this;
      return nt2(Oe2, function() {
        return Ln(e3);
      });
    }, sr.prototype._close = function() {
      var n3 = this._state, e3 = lt2.indexOf(this);
      if (0 <= e3 && lt2.splice(e3, 1), this.idbdb) {
        try {
          this.idbdb.close();
        } catch (e4) {
        }
        this.idbdb = null;
      }
      n3.dbReadyPromise = new je2(function(e4) {
        n3.dbReadyResolve = e4;
      }), n3.openCanceller = new je2(function(e4, t3) {
        n3.cancelOpen = t3;
      });
    }, sr.prototype.close = function(e3) {
      var t3 = (void 0 === e3 ? { disableAutoOpen: true } : e3).disableAutoOpen;
      this._close();
      e3 = this._state;
      t3 && (this._options.autoOpen = false), e3.dbOpenError = new Z2.DatabaseClosed(), e3.isBeingOpened && e3.cancelOpen(e3.dbOpenError);
    }, sr.prototype.delete = function() {
      var i2 = this, n3 = 0 < arguments.length, o2 = this._state;
      return new je2(function(r3, t3) {
        function e3() {
          i2.close({ disableAutoOpen: false });
          var e4 = i2._deps.indexedDB.deleteDatabase(i2.name);
          e4.onsuccess = Ue2(function() {
            var e5, t4, n4;
            e5 = i2._deps, t4 = i2.name, n4 = e5.indexedDB, e5 = e5.IDBKeyRange, On(n4) || t4 === pt2 || xn(n4, e5).delete(t4).catch(ne2), r3();
          }), e4.onerror = Qt(t3), e4.onblocked = i2._fireOnBlocked;
        }
        if (n3)
          throw new Z2.InvalidArgument("Arguments not allowed in db.delete()");
        o2.isBeingOpened ? o2.dbReadyPromise.then(e3) : e3();
      });
    }, sr.prototype.backendDB = function() {
      return this.idbdb;
    }, sr.prototype.isOpen = function() {
      return null !== this.idbdb;
    }, sr.prototype.hasBeenClosed = function() {
      var e3 = this._state.dbOpenError;
      return e3 && "DatabaseClosed" === e3.name;
    }, sr.prototype.hasFailed = function() {
      return null !== this._state.dbOpenError;
    }, sr.prototype.dynamicallyOpened = function() {
      return this._state.autoSchema;
    }, Object.defineProperty(sr.prototype, "tables", { get: function() {
      var t3 = this;
      return k2(this._allTables).map(function(e3) {
        return t3._allTables[e3];
      });
    }, enumerable: false, configurable: true }), sr.prototype.transaction = function() {
      var e3 = (function(e4, t3, n3) {
        var r3 = arguments.length;
        if (r3 < 2)
          throw new Z2.InvalidArgument("Too few arguments");
        for (var i2 = new Array(r3 - 1); --r3; )
          i2[r3 - 1] = arguments[r3];
        return n3 = i2.pop(), [e4, E2(i2), n3];
      }).apply(this, arguments);
      return this._transaction.apply(this, e3);
    }, sr.prototype._transaction = function(e3, t3, n3) {
      var r3 = this, i2 = Pe2.trans;
      i2 && i2.db === this && -1 === e3.indexOf("!") || (i2 = null);
      var o2, a2, u3 = -1 !== e3.indexOf("?");
      e3 = e3.replace("!", "").replace("?", "");
      try {
        if (a2 = t3.map(function(e4) {
          e4 = e4 instanceof r3.Table ? e4.name : e4;
          if ("string" != typeof e4)
            throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
          return e4;
        }), "r" == e3 || e3 === yt)
          o2 = yt;
        else {
          if ("rw" != e3 && e3 != vt)
            throw new Z2.InvalidArgument("Invalid transaction mode: " + e3);
          o2 = vt;
        }
        if (i2) {
          if (i2.mode === yt && o2 === vt) {
            if (!u3)
              throw new Z2.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
            i2 = null;
          }
          i2 && a2.forEach(function(e4) {
            if (i2 && -1 === i2.storeNames.indexOf(e4)) {
              if (!u3)
                throw new Z2.SubTransaction("Table " + e4 + " not included in parent transaction.");
              i2 = null;
            }
          }), u3 && i2 && !i2.active && (i2 = null);
        }
      } catch (n4) {
        return i2 ? i2._promise(null, function(e4, t4) {
          t4(n4);
        }) : ot(n4);
      }
      var s2 = (function i3(o3, a3, u4, s3, c2) {
        return je2.resolve().then(function() {
          var e4 = Pe2.transless || Pe2, t4 = o3._createTransaction(a3, u4, o3._dbSchema, s3);
          if (t4.explicit = true, e4 = { trans: t4, transless: e4 }, s3)
            t4.idbtrans = s3.idbtrans;
          else
            try {
              t4.create(), o3._state.PR1398_maxLoop = 3;
            } catch (e5) {
              return e5.name === J2.InvalidState && o3.isOpen() && 0 < --o3._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), o3._close(), o3.open().then(function() {
                return i3(o3, a3, u4, null, c2);
              })) : ot(e5);
            }
          var n4, r4 = B2(c2);
          return r4 && Xe2(), e4 = je2.follow(function() {
            var e5;
            (n4 = c2.call(t4, t4)) && (r4 ? (e5 = Je2.bind(null, null), n4.then(e5, e5)) : "function" == typeof n4.next && "function" == typeof n4.throw && (n4 = Un(n4)));
          }, e4), (n4 && "function" == typeof n4.then ? je2.resolve(n4).then(function(e5) {
            return t4.active ? e5 : ot(new Z2.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
          }) : e4.then(function() {
            return n4;
          })).then(function(e5) {
            return s3 && t4._resolve(), t4._completion.then(function() {
              return e5;
            });
          }).catch(function(e5) {
            return t4._reject(e5), ot(e5);
          });
        });
      }).bind(null, this, o2, a2, i2, n3);
      return i2 ? i2._promise(o2, s2, "lock") : Pe2.trans ? nt2(Pe2.transless, function() {
        return r3._whenReady(s2);
      }) : this._whenReady(s2);
    }, sr.prototype.table = function(e3) {
      if (!m2(this._allTables, e3))
        throw new Z2.InvalidTable("Table ".concat(e3, " does not exist"));
      return this._allTables[e3];
    }, sr);
    function sr(e3, t3) {
      var o2 = this;
      this._middlewares = {}, this.verno = 0;
      var n3 = sr.dependencies;
      this._options = t3 = _2({ addons: sr.addons, autoOpen: true, indexedDB: n3.indexedDB, IDBKeyRange: n3.IDBKeyRange, cache: "cloned" }, t3), this._deps = { indexedDB: t3.indexedDB, IDBKeyRange: t3.IDBKeyRange };
      n3 = t3.addons;
      this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
      var a2, r3, u3, i2, s2, c2 = { dbOpenError: null, isBeingOpened: false, onReadyBeingFired: null, openComplete: false, dbReadyResolve: ne2, dbReadyPromise: null, cancelOpen: ne2, openCanceller: null, autoSchema: true, PR1398_maxLoop: 3 };
      c2.dbReadyPromise = new je2(function(e4) {
        c2.dbReadyResolve = e4;
      }), c2.openCanceller = new je2(function(e4, t4) {
        c2.cancelOpen = t4;
      }), this._state = c2, this.name = e3, this.on = Et(this, "populate", "blocked", "versionchange", "close", { ready: [le2, ne2] }), this.on.ready.subscribe = v2(this.on.ready.subscribe, function(i3) {
        return function(n4, r4) {
          sr.vip(function() {
            var t4, e4 = o2._state;
            e4.openComplete ? (e4.dbOpenError || je2.resolve().then(n4), r4 && i3(n4)) : e4.onReadyBeingFired ? (e4.onReadyBeingFired.push(n4), r4 && i3(n4)) : (i3(n4), t4 = o2, r4 || i3(function e5() {
              t4.on.ready.unsubscribe(n4), t4.on.ready.unsubscribe(e5);
            }));
          });
        };
      }), this.Collection = (a2 = this, Kt(It.prototype, function(e4, t4) {
        this.db = a2;
        var n4 = bt, r4 = null;
        if (t4)
          try {
            n4 = t4();
          } catch (e5) {
            r4 = e5;
          }
        var i3 = e4._ctx, t4 = i3.table, e4 = t4.hook.reading.fire;
        this._ctx = { table: t4, index: i3.index, isPrimKey: !i3.index || t4.schema.primKey.keyPath && i3.index === t4.schema.primKey.name, range: n4, keysOnly: false, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: true, isMatch: null, offset: 0, limit: 1 / 0, error: r4, or: i3.or, valueMapper: e4 !== re2 ? e4 : null };
      })), this.Table = (r3 = this, Kt(Ot.prototype, function(e4, t4, n4) {
        this.db = r3, this._tx = n4, this.name = e4, this.schema = t4, this.hook = r3._allTables[e4] ? r3._allTables[e4].hook : Et(null, { creating: [ae2, ne2], reading: [ie2, re2], updating: [se2, ne2], deleting: [ue2, ne2] });
      })), this.Transaction = (u3 = this, Kt($t.prototype, function(e4, t4, n4, r4, i3) {
        var o3 = this;
        this.db = u3, this.mode = e4, this.storeNames = t4, this.schema = n4, this.chromeTransactionDurability = r4, this.idbtrans = null, this.on = Et(this, "complete", "error", "abort"), this.parent = i3 || null, this.active = true, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new je2(function(e5, t5) {
          o3._resolve = e5, o3._reject = t5;
        }), this._completion.then(function() {
          o3.active = false, o3.on.complete.fire();
        }, function(e5) {
          var t5 = o3.active;
          return o3.active = false, o3.on.error.fire(e5), o3.parent ? o3.parent._reject(e5) : t5 && o3.idbtrans && o3.idbtrans.abort(), ot(e5);
        });
      })), this.Version = (i2 = this, Kt(_n.prototype, function(e4) {
        this.db = i2, this._cfg = { version: e4, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
      })), this.WhereClause = (s2 = this, Kt(Wt.prototype, function(e4, t4, n4) {
        if (this.db = s2, this._ctx = { table: e4, index: ":id" === t4 ? null : t4, or: n4 }, this._cmp = this._ascending = _t, this._descending = function(e5, t5) {
          return _t(t5, e5);
        }, this._max = function(e5, t5) {
          return 0 < _t(e5, t5) ? e5 : t5;
        }, this._min = function(e5, t5) {
          return _t(e5, t5) < 0 ? e5 : t5;
        }, this._IDBKeyRange = s2._deps.IDBKeyRange, !this._IDBKeyRange)
          throw new Z2.MissingAPI();
      })), this.on("versionchange", function(e4) {
        0 < e4.newVersion ? console.warn("Another connection wants to upgrade database '".concat(o2.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(o2.name, "'. Closing db now to resume the delete request.")), o2.close({ disableAutoOpen: false }), o2._state.openComplete = false;
      }), this.on("blocked", function(e4) {
        !e4.newVersion || e4.newVersion < e4.oldVersion ? console.warn("Dexie.delete('".concat(o2.name, "') was blocked")) : console.warn("Upgrade '".concat(o2.name, "' blocked by other connection holding version ").concat(e4.oldVersion / 10));
      }), this._maxKey = rn(t3.IDBKeyRange), this._createTransaction = function(e4, t4, n4, r4) {
        return new o2.Transaction(e4, t4, n4, o2._options.chromeTransactionDurability, r4);
      }, this._fireOnBlocked = function(t4) {
        o2.on("blocked").fire(t4), lt2.filter(function(e4) {
          return e4.name === o2.name && e4 !== o2 && !e4._state.vcFired;
        }).map(function(e4) {
          return e4.on("versionchange").fire(t4);
        });
      }, this.use(Hn), this.use(or), this.use($n), this.use(Vn), this.use(Qn);
      var l3 = new Proxy(this, { get: function(e4, t4, n4) {
        if ("_vip" === t4)
          return true;
        if ("table" === t4)
          return function(e5) {
            return ar(o2.table(e5), l3);
          };
        var r4 = Reflect.get(e4, t4, n4);
        return r4 instanceof Ot ? ar(r4, l3) : "tables" === t4 ? r4.map(function(e5) {
          return ar(e5, l3);
        }) : "_createTransaction" === t4 ? function() {
          return ar(r4.apply(this, arguments), l3);
        } : r4;
      } });
      this.vip = l3, n3.forEach(function(e4) {
        return e4(o2);
      });
    }
    var cr, W2 = "undefined" != typeof Symbol && "observable" in Symbol ? Symbol.observable : "@@observable", lr = (fr.prototype.subscribe = function(e3, t3, n3) {
      return this._subscribe(e3 && "function" != typeof e3 ? e3 : { next: e3, error: t3, complete: n3 });
    }, fr.prototype[W2] = function() {
      return this;
    }, fr);
    function fr(e3) {
      this._subscribe = e3;
    }
    try {
      cr = { indexedDB: f2.indexedDB || f2.mozIndexedDB || f2.webkitIndexedDB || f2.msIndexedDB, IDBKeyRange: f2.IDBKeyRange || f2.webkitIDBKeyRange };
    } catch (e3) {
      cr = { indexedDB: null, IDBKeyRange: null };
    }
    function hr(h3) {
      var d2, p3 = false, e3 = new lr(function(r3) {
        var i2 = B2(h3);
        var o2, a2 = false, u3 = {}, s2 = {}, e4 = { get closed() {
          return a2;
        }, unsubscribe: function() {
          a2 || (a2 = true, o2 && o2.abort(), c2 && Jt.storagemutated.unsubscribe(f3));
        } };
        r3.start && r3.start(e4);
        var c2 = false, l3 = function() {
          return it2(t3);
        };
        var f3 = function(e5) {
          Tn(u3, e5), In(s2, u3) && l3();
        }, t3 = function() {
          var t4, n3, e5;
          !a2 && cr.indexedDB && (u3 = {}, t4 = {}, o2 && o2.abort(), o2 = new AbortController(), e5 = function(e6) {
            var t5 = Fe2();
            try {
              i2 && Xe2();
              var n4 = He2(h3, e6);
              return n4 = i2 ? n4.finally(Je2) : n4;
            } finally {
              t5 && Me2();
            }
          }(n3 = { subscr: t4, signal: o2.signal, requery: l3, querier: h3, trans: null }), Promise.resolve(e5).then(function(e6) {
            p3 = true, d2 = e6, a2 || n3.signal.aborted || (u3 = {}, function(e7) {
              for (var t5 in e7)
                if (m2(e7, t5))
                  return;
              return 1;
            }(s2 = t4) || c2 || (Jt(Ht, f3), c2 = true), it2(function() {
              return !a2 && r3.next && r3.next(e6);
            }));
          }, function(e6) {
            p3 = false, ["DatabaseClosedError", "AbortError"].includes(null == e6 ? void 0 : e6.name) || a2 || it2(function() {
              a2 || r3.error && r3.error(e6);
            });
          }));
        };
        return setTimeout(l3, 0), e4;
      });
      return e3.hasValue = function() {
        return p3;
      }, e3.getValue = function() {
        return d2;
      }, e3;
    }
    var dr = ur;
    function pr(e3) {
      var t3 = vr;
      try {
        vr = true, Jt.storagemutated.fire(e3), Nn(e3, true);
      } finally {
        vr = t3;
      }
    }
    r2(dr, _2(_2({}, te2), { delete: function(e3) {
      return new dr(e3, { addons: [] }).delete();
    }, exists: function(e3) {
      return new dr(e3, { addons: [] }).open().then(function(e4) {
        return e4.close(), true;
      }).catch("NoSuchDatabaseError", function() {
        return false;
      });
    }, getDatabaseNames: function(e3) {
      try {
        return t3 = dr.dependencies, n3 = t3.indexedDB, t3 = t3.IDBKeyRange, (On(n3) ? Promise.resolve(n3.databases()).then(function(e4) {
          return e4.map(function(e5) {
            return e5.name;
          }).filter(function(e5) {
            return e5 !== pt2;
          });
        }) : xn(n3, t3).toCollection().primaryKeys()).then(e3);
      } catch (e4) {
        return ot(new Z2.MissingAPI());
      }
      var t3, n3;
    }, defineClass: function() {
      return function(e3) {
        a(this, e3);
      };
    }, ignoreTransaction: function(e3) {
      return Pe2.trans ? nt2(Pe2.transless, e3) : e3();
    }, vip: Pn, async: function(t3) {
      return function() {
        try {
          var e3 = Un(t3.apply(this, arguments));
          return e3 && "function" == typeof e3.then ? e3 : je2.resolve(e3);
        } catch (e4) {
          return ot(e4);
        }
      };
    }, spawn: function(e3, t3, n3) {
      try {
        var r3 = Un(e3.apply(n3, t3 || []));
        return r3 && "function" == typeof r3.then ? r3 : je2.resolve(r3);
      } catch (e4) {
        return ot(e4);
      }
    }, currentTransaction: { get: function() {
      return Pe2.trans || null;
    } }, waitFor: function(e3, t3) {
      t3 = je2.resolve("function" == typeof e3 ? dr.ignoreTransaction(e3) : e3).timeout(t3 || 6e4);
      return Pe2.trans ? Pe2.trans.waitFor(t3) : t3;
    }, Promise: je2, debug: { get: function() {
      return F2;
    }, set: function(e3) {
      M2(e3, "dexie" === e3 ? function() {
        return true;
      } : at2);
    } }, derive: o, extend: a, props: r2, override: v2, Events: Et, on: Jt, liveQuery: hr, extendObservabilitySet: Tn, getByKeyPath: x2, setByKeyPath: O2, delByKeyPath: function(t3, e3) {
      "string" == typeof e3 ? O2(t3, e3, void 0) : "length" in e3 && [].map.call(e3, function(e4) {
        O2(t3, e4, void 0);
      });
    }, shallowClone: P2, deepClone: j2, getObjectDiff: Wn, cmp: _t, asap: w2, minKey: -1 / 0, addons: [], connections: lt2, errnames: J2, dependencies: cr, cache: Rn, semVer: e2, version: e2.split(".").map(function(e3) {
      return parseInt(e3);
    }).reduce(function(e3, t3, n3) {
      return e3 + t3 / Math.pow(10, 2 * n3);
    }) })), dr.maxKey = rn(dr.dependencies.IDBKeyRange), "undefined" != typeof dispatchEvent && "undefined" != typeof addEventListener && (Jt(Ht, function(e3) {
      var t3;
      vr || (ft ? (t3 = document.createEvent("CustomEvent")).initCustomEvent(Xt, true, true, e3) : t3 = new CustomEvent(Xt, { detail: e3 }), vr = true, dispatchEvent(t3), vr = false);
    }), addEventListener(Xt, function(e3) {
      e3 = e3.detail;
      vr || pr(e3);
    }));
    var yr, vr = false;
    return "undefined" != typeof BroadcastChannel ? ("function" == typeof (yr = new BroadcastChannel(Xt)).unref && yr.unref(), Jt(Ht, function(e3) {
      vr || yr.postMessage(e3);
    }), yr.onmessage = function(e3) {
      e3.data && pr(e3.data);
    }) : "undefined" != typeof self && "undefined" != typeof navigator && (Jt(Ht, function(t3) {
      try {
        vr || ("undefined" != typeof localStorage && localStorage.setItem(Xt, JSON.stringify({ trig: Math.random(), changedParts: t3 })), "object" == typeof self.clients && i([], self.clients.matchAll({ includeUncontrolled: true }), true).forEach(function(e3) {
          return e3.postMessage({ type: Xt, changedParts: t3 });
        }));
      } catch (e3) {
      }
    }), "undefined" != typeof addEventListener && addEventListener("storage", function(e3) {
      e3.key !== Xt || (e3 = JSON.parse(e3.newValue)) && pr(e3.changedParts);
    }), (e2 = self.document && navigator.serviceWorker) && e2.addEventListener("message", function(e3) {
      e3 = e3.data;
      e3 && e3.type === Xt && pr(e3.changedParts);
    })), je2.rejectionMapper = function(e3, t3) {
      return !e3 || e3 instanceof Q2 || e3 instanceof TypeError || e3 instanceof SyntaxError || !e3.name || !ee2[e3.name] ? e3 : (t3 = new ee2[e3.name](t3 || e3.message, e3), "stack" in e3 && l2(t3, "stack", { get: function() {
        return this.inner.stack;
      } }), t3);
    }, M2(F2, at2), _2(ur, Object.freeze({ __proto__: null, Dexie: ur, liveQuery: hr, Entity: wt, cmp: _t, default: ur, RangeSet: Kn, mergeRanges: jn, rangesOverlap: An }), { default: ur }), ur;
  });
})(dexie_min);
var dexie_minExports = dexie_min.exports;
const _Dexie = /* @__PURE__ */ getDefaultExportFromCjs(dexie_minExports);
const DexieSymbol = Symbol.for("Dexie");
const Dexie = globalThis[DexieSymbol] || (globalThis[DexieSymbol] = _Dexie);
if (_Dexie.semVer !== Dexie.semVer) {
  throw new Error(`Two different versions of Dexie loaded in the same app: ${_Dexie.semVer} and ${Dexie.semVer}`);
}
var DEXIE_DOCS_TABLE_NAME = "docs";
var DEXIE_CHANGES_TABLE_NAME = "changes";
var DEXIE_ATTACHMENTS_TABLE_NAME = "attachments";
var RX_STORAGE_NAME_DEXIE = "dexie";
var DEXIE_STATE_DB_BY_NAME = /* @__PURE__ */ new Map();
var REF_COUNT_PER_DEXIE_DB = /* @__PURE__ */ new Map();
function getDexieDbWithTables(databaseName, collectionName, settings, schema) {
  var dexieDbName = "rxdb-dexie-" + databaseName + "--" + schema.version + "--" + collectionName;
  var state = getFromMapOrCreate(DEXIE_STATE_DB_BY_NAME, dexieDbName, () => {
    var value = (async () => {
      var useSettings = flatClone(settings);
      useSettings.autoOpen = false;
      var dexieDb = new Dexie(dexieDbName, useSettings);
      var dexieStoresSettings = {
        [DEXIE_DOCS_TABLE_NAME]: getDexieStoreSchema(schema),
        [DEXIE_CHANGES_TABLE_NAME]: "++sequence, id",
        [DEXIE_ATTACHMENTS_TABLE_NAME]: "id"
      };
      dexieDb.version(1).stores(dexieStoresSettings);
      await dexieDb.open();
      return {
        dexieDb,
        dexieTable: dexieDb[DEXIE_DOCS_TABLE_NAME],
        dexieAttachmentsTable: dexieDb[DEXIE_ATTACHMENTS_TABLE_NAME],
        booleanIndexes: getBooleanIndexes(schema)
      };
    })();
    DEXIE_STATE_DB_BY_NAME.set(dexieDbName, state);
    REF_COUNT_PER_DEXIE_DB.set(state, 0);
    return value;
  });
  return state;
}
async function closeDexieDb(statePromise) {
  var state = await statePromise;
  var prevCount = REF_COUNT_PER_DEXIE_DB.get(statePromise);
  var newCount = prevCount - 1;
  if (newCount === 0) {
    state.dexieDb.close();
    REF_COUNT_PER_DEXIE_DB.delete(statePromise);
  } else {
    REF_COUNT_PER_DEXIE_DB.set(statePromise, newCount);
  }
}
var DEXIE_PIPE_SUBSTITUTE = "__";
function dexieReplaceIfStartsWithPipe(str) {
  var split = str.split(".");
  if (split.length > 1) {
    return split.map((part) => dexieReplaceIfStartsWithPipe(part)).join(".");
  }
  if (str.startsWith("|")) {
    var withoutFirst = str.substring(1);
    return DEXIE_PIPE_SUBSTITUTE + withoutFirst;
  } else {
    return str;
  }
}
function dexieReplaceIfStartsWithPipeRevert(str) {
  var split = str.split(".");
  if (split.length > 1) {
    return split.map((part) => dexieReplaceIfStartsWithPipeRevert(part)).join(".");
  }
  if (str.startsWith(DEXIE_PIPE_SUBSTITUTE)) {
    var withoutFirst = str.substring(DEXIE_PIPE_SUBSTITUTE.length);
    return "|" + withoutFirst;
  } else {
    return str;
  }
}
function fromStorageToDexie(booleanIndexes, d) {
  if (!d) {
    return d;
  }
  d = flatClone(d);
  d = fromStorageToDexieField(d);
  booleanIndexes.forEach((idx) => {
    var val = getProperty$1(d, idx);
    var newVal = val ? "1" : "0";
    setProperty(d, idx, newVal);
  });
  return d;
}
function fromDexieToStorage(booleanIndexes, d) {
  if (!d) {
    return d;
  }
  d = flatClone(d);
  d = fromDexieToStorageField(d);
  booleanIndexes.forEach((idx) => {
    var val = getProperty$1(d, idx);
    var newVal = val === "1" ? true : false;
    setProperty(d, idx, newVal);
  });
  return d;
}
function fromStorageToDexieField(documentData) {
  if (!documentData || typeof documentData === "string" || typeof documentData === "number" || typeof documentData === "boolean") {
    return documentData;
  } else if (Array.isArray(documentData)) {
    return documentData.map((row) => fromStorageToDexieField(row));
  } else if (typeof documentData === "object") {
    var ret = {};
    Object.entries(documentData).forEach(([key, value]) => {
      if (typeof value === "object") {
        value = fromStorageToDexieField(value);
      }
      ret[dexieReplaceIfStartsWithPipe(key)] = value;
    });
    return ret;
  }
}
function fromDexieToStorageField(documentData) {
  if (!documentData || typeof documentData === "string" || typeof documentData === "number" || typeof documentData === "boolean") {
    return documentData;
  } else if (Array.isArray(documentData)) {
    return documentData.map((row) => fromDexieToStorageField(row));
  } else if (typeof documentData === "object") {
    var ret = {};
    Object.entries(documentData).forEach(([key, value]) => {
      if (typeof value === "object" || Array.isArray(documentData)) {
        value = fromDexieToStorageField(value);
      }
      ret[dexieReplaceIfStartsWithPipeRevert(key)] = value;
    });
    return ret;
  }
}
function getDexieStoreSchema(rxJsonSchema) {
  var parts = [];
  var primaryKey = getPrimaryFieldOfPrimaryKey(rxJsonSchema.primaryKey);
  parts.push([primaryKey]);
  parts.push(["_deleted", primaryKey]);
  if (rxJsonSchema.indexes) {
    rxJsonSchema.indexes.forEach((index) => {
      var arIndex = toArray$2(index);
      parts.push(arIndex);
    });
  }
  parts.push(["_meta.lwt", primaryKey]);
  parts.push(["_meta.lwt"]);
  parts = parts.map((part) => {
    return part.map((str) => dexieReplaceIfStartsWithPipe(str));
  });
  var dexieSchemaRows = parts.map((part) => {
    if (part.length === 1) {
      return part[0];
    } else {
      return "[" + part.join("+") + "]";
    }
  });
  dexieSchemaRows = dexieSchemaRows.filter((elem, pos, arr) => arr.indexOf(elem) === pos);
  var dexieSchema = dexieSchemaRows.join(", ");
  return dexieSchema;
}
async function getDocsInDb(internals, docIds) {
  var state = await internals;
  var docsInDb = await state.dexieTable.bulkGet(docIds);
  return docsInDb.map((d) => fromDexieToStorage(state.booleanIndexes, d));
}
function attachmentObjectId(documentId, attachmentId) {
  return documentId + "||" + attachmentId;
}
function getBooleanIndexes(schema) {
  var checkedFields = /* @__PURE__ */ new Set();
  var ret = [];
  if (!schema.indexes) {
    return ret;
  }
  schema.indexes.forEach((index) => {
    var fields = toArray$2(index);
    fields.forEach((field) => {
      if (checkedFields.has(field)) {
        return;
      }
      checkedFields.add(field);
      var schemaObj = getSchemaByObjectPath(schema, field);
      if (schemaObj.type === "boolean") {
        ret.push(field);
      }
    });
  });
  ret.push("_deleted");
  return uniqueArray(ret);
}
function mapKeyForKeyRange(k2) {
  if (k2 === INDEX_MIN) {
    return -Infinity;
  } else {
    return k2;
  }
}
function rangeFieldToBooleanSubstitute(booleanIndexes, fieldName, value) {
  if (booleanIndexes.includes(fieldName)) {
    var newValue = value === INDEX_MAX || value === true ? "1" : "0";
    return newValue;
  } else {
    return value;
  }
}
function getKeyRangeByQueryPlan(booleanIndexes, queryPlan, IDBKeyRange2) {
  if (!IDBKeyRange2) {
    if (typeof window === "undefined") {
      throw new Error("IDBKeyRange missing");
    } else {
      IDBKeyRange2 = window.IDBKeyRange;
    }
  }
  var startKeys = queryPlan.startKeys.map((v2, i) => {
    var fieldName = queryPlan.index[i];
    return rangeFieldToBooleanSubstitute(booleanIndexes, fieldName, v2);
  }).map(mapKeyForKeyRange);
  var endKeys = queryPlan.endKeys.map((v2, i) => {
    var fieldName = queryPlan.index[i];
    return rangeFieldToBooleanSubstitute(booleanIndexes, fieldName, v2);
  }).map(mapKeyForKeyRange);
  var keyRange = IDBKeyRange2.bound(startKeys, endKeys, !queryPlan.inclusiveStart, !queryPlan.inclusiveEnd);
  return keyRange;
}
async function dexieQuery(instance, preparedQuery) {
  var state = await instance.internals;
  var query = preparedQuery.query;
  var skip2 = query.skip ? query.skip : 0;
  var limit = query.limit ? query.limit : Infinity;
  var skipPlusLimit = skip2 + limit;
  var queryPlan = preparedQuery.queryPlan;
  var queryMatcher = false;
  if (!queryPlan.selectorSatisfiedByIndex) {
    queryMatcher = getQueryMatcher(instance.schema, preparedQuery.query);
  }
  var keyRange = getKeyRangeByQueryPlan(state.booleanIndexes, queryPlan, state.dexieDb._options.IDBKeyRange);
  var queryPlanFields = queryPlan.index;
  var rows = [];
  await state.dexieDb.transaction("r", state.dexieTable, async (dexieTx) => {
    var tx = dexieTx.idbtrans;
    var store = tx.objectStore(DEXIE_DOCS_TABLE_NAME);
    var index;
    var indexName;
    indexName = "[" + queryPlanFields.map((field) => dexieReplaceIfStartsWithPipe(field)).join("+") + "]";
    index = store.index(indexName);
    var cursorReq = index.openCursor(keyRange);
    await new Promise((res) => {
      cursorReq.onsuccess = function(e2) {
        var cursor = e2.target.result;
        if (cursor) {
          var docData = fromDexieToStorage(state.booleanIndexes, cursor.value);
          if (!queryMatcher || queryMatcher(docData)) {
            rows.push(docData);
          }
          if (queryPlan.sortSatisfiedByIndex && rows.length === skipPlusLimit) {
            res();
          } else {
            cursor.continue();
          }
        } else {
          res();
        }
      };
    });
  });
  if (!queryPlan.sortSatisfiedByIndex) {
    var sortComparator = getSortComparator(instance.schema, preparedQuery.query);
    rows = rows.sort(sortComparator);
  }
  rows = rows.slice(skip2, skipPlusLimit);
  return {
    documents: rows
  };
}
async function dexieCount(instance, preparedQuery) {
  var state = await instance.internals;
  var queryPlan = preparedQuery.queryPlan;
  var queryPlanFields = queryPlan.index;
  var keyRange = getKeyRangeByQueryPlan(state.booleanIndexes, queryPlan, state.dexieDb._options.IDBKeyRange);
  var count2 = -1;
  await state.dexieDb.transaction("r", state.dexieTable, async (dexieTx) => {
    var tx = dexieTx.idbtrans;
    var store = tx.objectStore(DEXIE_DOCS_TABLE_NAME);
    var index;
    var indexName;
    indexName = "[" + queryPlanFields.map((field) => dexieReplaceIfStartsWithPipe(field)).join("+") + "]";
    index = store.index(indexName);
    var request = index.count(keyRange);
    count2 = await new Promise((res, rej) => {
      request.onsuccess = function() {
        res(request.result);
      };
      request.onerror = (err) => rej(err);
    });
  });
  return count2;
}
var instanceId = now$1();
var RxStorageInstanceDexie = /* @__PURE__ */ function() {
  function RxStorageInstanceDexie2(storage, databaseName, collectionName, schema, internals, options, settings) {
    this.changes$ = new cjs.Subject();
    this.instanceId = instanceId++;
    this.storage = storage;
    this.databaseName = databaseName;
    this.collectionName = collectionName;
    this.schema = schema;
    this.internals = internals;
    this.options = options;
    this.settings = settings;
    this.primaryPath = getPrimaryFieldOfPrimaryKey(this.schema.primaryKey);
  }
  var _proto = RxStorageInstanceDexie2.prototype;
  _proto.bulkWrite = async function bulkWrite(documentWrites, context2) {
    ensureNotClosed(this);
    documentWrites.forEach((row) => {
      if (!row.document._rev || row.previous && !row.previous._rev) {
        throw newRxError("SNH", {
          args: {
            row
          }
        });
      }
    });
    var state = await this.internals;
    var ret = {
      success: [],
      error: []
    };
    var documentKeys = documentWrites.map((writeRow) => writeRow.document[this.primaryPath]);
    var categorized;
    await state.dexieDb.transaction("rw", state.dexieTable, state.dexieAttachmentsTable, async () => {
      var docsInDbMap = /* @__PURE__ */ new Map();
      var docsInDbWithInternals = await getDocsInDb(this.internals, documentKeys);
      docsInDbWithInternals.forEach((docWithDexieInternals) => {
        var doc = docWithDexieInternals;
        if (doc) {
          docsInDbMap.set(doc[this.primaryPath], doc);
        }
        return doc;
      });
      categorized = categorizeBulkWriteRows(this, this.primaryPath, docsInDbMap, documentWrites, context2);
      ret.error = categorized.errors;
      var bulkPutDocs = [];
      categorized.bulkInsertDocs.forEach((row) => {
        ret.success.push(row.document);
        bulkPutDocs.push(row.document);
      });
      categorized.bulkUpdateDocs.forEach((row) => {
        ret.success.push(row.document);
        bulkPutDocs.push(row.document);
      });
      bulkPutDocs = bulkPutDocs.map((d) => fromStorageToDexie(state.booleanIndexes, d));
      if (bulkPutDocs.length > 0) {
        await state.dexieTable.bulkPut(bulkPutDocs);
      }
      var putAttachments = [];
      categorized.attachmentsAdd.forEach((attachment) => {
        putAttachments.push({
          id: attachmentObjectId(attachment.documentId, attachment.attachmentId),
          data: attachment.attachmentData.data
        });
      });
      categorized.attachmentsUpdate.forEach((attachment) => {
        putAttachments.push({
          id: attachmentObjectId(attachment.documentId, attachment.attachmentId),
          data: attachment.attachmentData.data
        });
      });
      await state.dexieAttachmentsTable.bulkPut(putAttachments);
      await state.dexieAttachmentsTable.bulkDelete(categorized.attachmentsRemove.map((attachment) => attachmentObjectId(attachment.documentId, attachment.attachmentId)));
    });
    categorized = ensureNotFalsy(categorized);
    if (categorized.eventBulk.events.length > 0) {
      var lastState = ensureNotFalsy(categorized.newestRow).document;
      categorized.eventBulk.checkpoint = {
        id: lastState[this.primaryPath],
        lwt: lastState._meta.lwt
      };
      categorized.eventBulk.endTime = now$1();
      this.changes$.next(categorized.eventBulk);
    }
    return ret;
  };
  _proto.findDocumentsById = async function findDocumentsById(ids, deleted) {
    ensureNotClosed(this);
    var state = await this.internals;
    var ret = [];
    await state.dexieDb.transaction("r", state.dexieTable, async () => {
      var docsInDb = await getDocsInDb(this.internals, ids);
      docsInDb.forEach((documentInDb) => {
        if (documentInDb && (!documentInDb._deleted || deleted)) {
          ret.push(documentInDb);
        }
      });
    });
    return ret;
  };
  _proto.query = function query(preparedQuery) {
    ensureNotClosed(this);
    return dexieQuery(this, preparedQuery);
  };
  _proto.count = async function count2(preparedQuery) {
    if (preparedQuery.queryPlan.selectorSatisfiedByIndex) {
      var result = await dexieCount(this, preparedQuery);
      return {
        count: result,
        mode: "fast"
      };
    } else {
      var _result = await dexieQuery(this, preparedQuery);
      return {
        count: _result.documents.length,
        mode: "slow"
      };
    }
  };
  _proto.changeStream = function changeStream() {
    ensureNotClosed(this);
    return this.changes$.asObservable();
  };
  _proto.cleanup = async function cleanup(minimumDeletedTime) {
    ensureNotClosed(this);
    var state = await this.internals;
    await state.dexieDb.transaction("rw", state.dexieTable, async () => {
      var maxDeletionTime = now$1() - minimumDeletedTime;
      var toRemove = await state.dexieTable.where("_meta.lwt").below(maxDeletionTime).toArray();
      var removeIds = [];
      toRemove.forEach((doc) => {
        if (doc._deleted === "1") {
          removeIds.push(doc[this.primaryPath]);
        }
      });
      await state.dexieTable.bulkDelete(removeIds);
    });
    return true;
  };
  _proto.getAttachmentData = async function getAttachmentData(documentId, attachmentId, _digest) {
    ensureNotClosed(this);
    var state = await this.internals;
    var id2 = attachmentObjectId(documentId, attachmentId);
    return await state.dexieDb.transaction("r", state.dexieAttachmentsTable, async () => {
      var attachment = await state.dexieAttachmentsTable.get(id2);
      if (attachment) {
        return attachment.data;
      } else {
        throw new Error("attachment missing documentId: " + documentId + " attachmentId: " + attachmentId);
      }
    });
  };
  _proto.remove = async function remove() {
    ensureNotClosed(this);
    var state = await this.internals;
    await state.dexieTable.clear();
    return this.close();
  };
  _proto.close = function close3() {
    if (this.closed) {
      return this.closed;
    }
    this.closed = (async () => {
      this.changes$.complete();
      await closeDexieDb(this.internals);
    })();
    return this.closed;
  };
  _proto.conflictResultionTasks = function conflictResultionTasks() {
    return new cjs.Subject();
  };
  _proto.resolveConflictResultionTask = async function resolveConflictResultionTask(_taskSolution) {
  };
  return RxStorageInstanceDexie2;
}();
async function createDexieStorageInstance(storage, params, settings) {
  var internals = getDexieDbWithTables(params.databaseName, params.collectionName, settings, params.schema);
  var instance = new RxStorageInstanceDexie(storage, params.databaseName, params.collectionName, params.schema, internals, params.options, settings);
  await addRxStorageMultiInstanceSupport(RX_STORAGE_NAME_DEXIE, params, instance);
  return Promise.resolve(instance);
}
function ensureNotClosed(instance) {
  if (instance.closed) {
    throw new Error("RxStorageInstanceDexie is closed " + instance.databaseName + "-" + instance.collectionName);
  }
}
var RxStorageDexie = /* @__PURE__ */ function() {
  function RxStorageDexie2(settings) {
    this.name = RX_STORAGE_NAME_DEXIE;
    this.rxdbVersion = RXDB_VERSION;
    this.settings = settings;
  }
  var _proto = RxStorageDexie2.prototype;
  _proto.createStorageInstance = function createStorageInstance(params) {
    ensureRxStorageInstanceParamsAreCorrect(params);
    return createDexieStorageInstance(this, params, this.settings);
  };
  return RxStorageDexie2;
}();
function getRxStorageDexie(settings = {}) {
  var storage = new RxStorageDexie(settings);
  return storage;
}
var SPECIAL_PROPERTIES = ["__proto__", "constructor", "prototype"];
function merge(to, from2) {
  Object.keys(from2).forEach((key) => {
    if (SPECIAL_PROPERTIES.includes(key)) {
      return;
    }
    if (typeof to[key] === "undefined") {
      to[key] = from2[key];
    } else {
      if (isObject(from2[key]))
        merge(to[key], from2[key]);
      else
        to[key] = from2[key];
    }
  });
}
function isObject(arg) {
  return "[object Object]" === arg.toString();
}
var NoSqlQueryBuilderClass = /* @__PURE__ */ function() {
  function NoSqlQueryBuilderClass2(mangoQuery, _path) {
    this.options = {};
    this._conditions = {};
    this._fields = {};
    this._path = _path;
    if (mangoQuery) {
      var queryBuilder = this;
      if (mangoQuery.selector) {
        queryBuilder.find(mangoQuery.selector);
      }
      if (mangoQuery.limit) {
        queryBuilder.limit(mangoQuery.limit);
      }
      if (mangoQuery.skip) {
        queryBuilder.skip(mangoQuery.skip);
      }
      if (mangoQuery.sort) {
        mangoQuery.sort.forEach((s) => queryBuilder.sort(s));
      }
    }
  }
  var _proto = NoSqlQueryBuilderClass2.prototype;
  _proto.where = function where(_path, _val) {
    if (!arguments.length)
      return this;
    var type2 = typeof arguments[0];
    if ("string" === type2) {
      this._path = arguments[0];
      if (2 === arguments.length) {
        this._conditions[this._path] = arguments[1];
      }
      return this;
    }
    if ("object" === type2 && !Array.isArray(arguments[0])) {
      return this.merge(arguments[0]);
    }
    throw newRxTypeError("MQ1", {
      path: arguments[0]
    });
  };
  _proto.equals = function equals(val) {
    this._ensurePath("equals");
    var path = this._path;
    this._conditions[path] = val;
    return this;
  };
  _proto.eq = function eq(val) {
    this._ensurePath("eq");
    var path = this._path;
    this._conditions[path] = val;
    return this;
  };
  _proto.or = function or(array) {
    var or2 = this._conditions.$or || (this._conditions.$or = []);
    if (!Array.isArray(array))
      array = [array];
    or2.push.apply(or2, array);
    return this;
  };
  _proto.nor = function nor(array) {
    var nor2 = this._conditions.$nor || (this._conditions.$nor = []);
    if (!Array.isArray(array))
      array = [array];
    nor2.push.apply(nor2, array);
    return this;
  };
  _proto.and = function and(array) {
    var and2 = this._conditions.$and || (this._conditions.$and = []);
    if (!Array.isArray(array))
      array = [array];
    and2.push.apply(and2, array);
    return this;
  };
  _proto.mod = function mod(_path, _val) {
    var val;
    var path;
    if (1 === arguments.length) {
      this._ensurePath("mod");
      val = arguments[0];
      path = this._path;
    } else if (2 === arguments.length && !Array.isArray(arguments[1])) {
      this._ensurePath("mod");
      val = arguments.slice();
      path = this._path;
    } else if (3 === arguments.length) {
      val = arguments.slice(1);
      path = arguments[0];
    } else {
      val = arguments[1];
      path = arguments[0];
    }
    var conds = this._conditions[path] || (this._conditions[path] = {});
    conds.$mod = val;
    return this;
  };
  _proto.exists = function exists(_path, _val) {
    var path;
    var val;
    if (0 === arguments.length) {
      this._ensurePath("exists");
      path = this._path;
      val = true;
    } else if (1 === arguments.length) {
      if ("boolean" === typeof arguments[0]) {
        this._ensurePath("exists");
        path = this._path;
        val = arguments[0];
      } else {
        path = arguments[0];
        val = true;
      }
    } else if (2 === arguments.length) {
      path = arguments[0];
      val = arguments[1];
    }
    var conds = this._conditions[path] || (this._conditions[path] = {});
    conds.$exists = val;
    return this;
  };
  _proto.elemMatch = function elemMatch(_path, _criteria) {
    if (null === arguments[0])
      throw newRxTypeError("MQ2");
    var fn;
    var path;
    var criteria;
    if ("function" === typeof arguments[0]) {
      this._ensurePath("elemMatch");
      path = this._path;
      fn = arguments[0];
    } else if (isObject(arguments[0])) {
      this._ensurePath("elemMatch");
      path = this._path;
      criteria = arguments[0];
    } else if ("function" === typeof arguments[1]) {
      path = arguments[0];
      fn = arguments[1];
    } else if (arguments[1] && isObject(arguments[1])) {
      path = arguments[0];
      criteria = arguments[1];
    } else
      throw newRxTypeError("MQ2");
    if (fn) {
      criteria = new NoSqlQueryBuilderClass2();
      fn(criteria);
      criteria = criteria._conditions;
    }
    var conds = this._conditions[path] || (this._conditions[path] = {});
    conds.$elemMatch = criteria;
    return this;
  };
  _proto.sort = function sort(arg) {
    if (!arg)
      return this;
    var len;
    var type2 = typeof arg;
    if (Array.isArray(arg)) {
      len = arg.length;
      for (var i = 0; i < arg.length; ++i) {
        _pushArr(this.options, arg[i][0], arg[i][1]);
      }
      return this;
    }
    if (1 === arguments.length && "string" === type2) {
      arg = arg.split(/\s+/);
      len = arg.length;
      for (var _i = 0; _i < len; ++_i) {
        var field = arg[_i];
        if (!field)
          continue;
        var ascend = "-" === field[0] ? -1 : 1;
        if (ascend === -1)
          field = field.substring(1);
        push(this.options, field, ascend);
      }
      return this;
    }
    if (isObject(arg)) {
      var keys = Object.keys(arg);
      keys.forEach((field2) => push(this.options, field2, arg[field2]));
      return this;
    }
    throw newRxTypeError("MQ3", {
      args: arguments
    });
  };
  _proto.merge = function merge$12(source) {
    if (!source) {
      return this;
    }
    if (!canMerge(source)) {
      throw newRxTypeError("MQ4", {
        source
      });
    }
    if (source instanceof NoSqlQueryBuilderClass2) {
      if (source._conditions)
        merge(this._conditions, source._conditions);
      if (source._fields) {
        if (!this._fields)
          this._fields = {};
        merge(this._fields, source._fields);
      }
      if (source.options) {
        if (!this.options)
          this.options = {};
        merge(this.options, source.options);
      }
      if (source._distinct)
        this._distinct = source._distinct;
      return this;
    }
    merge(this._conditions, source);
    return this;
  };
  _proto.find = function find2(criteria) {
    if (canMerge(criteria)) {
      this.merge(criteria);
    }
    return this;
  };
  _proto._ensurePath = function _ensurePath(method) {
    if (!this._path) {
      throw newRxError("MQ5", {
        method
      });
    }
  };
  _proto.toJSON = function toJSON() {
    var query = {
      selector: this._conditions
    };
    if (this.options.skip) {
      query.skip = this.options.skip;
    }
    if (this.options.limit) {
      query.limit = this.options.limit;
    }
    if (this.options.sort) {
      query.sort = mQuerySortToRxDBSort(this.options.sort);
    }
    return {
      query,
      path: this._path
    };
  };
  return NoSqlQueryBuilderClass2;
}();
function mQuerySortToRxDBSort(sort) {
  return Object.entries(sort).map(([k2, v2]) => {
    var direction = v2 === 1 ? "asc" : "desc";
    var part = {
      [k2]: direction
    };
    return part;
  });
}
var OTHER_MANGO_ATTRIBUTES = ["limit", "skip", "maxScan", "batchSize", "comment"];
OTHER_MANGO_ATTRIBUTES.forEach(function(method) {
  NoSqlQueryBuilderClass.prototype[method] = function(v2) {
    this.options[method] = v2;
    return this;
  };
});
var OTHER_MANGO_OPERATORS = ["gt", "gte", "lt", "lte", "ne", "in", "nin", "all", "regex", "size"];
OTHER_MANGO_OPERATORS.forEach(function($conditional) {
  NoSqlQueryBuilderClass.prototype[$conditional] = function() {
    var path;
    var val;
    if (1 === arguments.length) {
      this._ensurePath($conditional);
      val = arguments[0];
      path = this._path;
    } else {
      val = arguments[1];
      path = arguments[0];
    }
    var conds = this._conditions[path] === null || typeof this._conditions[path] === "object" ? this._conditions[path] : this._conditions[path] = {};
    if ($conditional === "regex") {
      if (val instanceof RegExp) {
        throw newRxError("QU16", {
          field: path,
          query: this._conditions
        });
      }
      if (typeof val === "string") {
        conds["$" + $conditional] = val;
      } else {
        conds["$" + $conditional] = val.$regex;
        if (val.$options) {
          conds.$options = val.$options;
        }
      }
    } else {
      conds["$" + $conditional] = val;
    }
    return this;
  };
});
function push(opts, field, value) {
  if (Array.isArray(opts.sort)) {
    throw newRxTypeError("MQ6", {
      opts,
      field,
      value
    });
  }
  if (value && value.$meta) {
    var sort = opts.sort || (opts.sort = {});
    sort[field] = {
      $meta: value.$meta
    };
    return;
  }
  var val = String(value || 1).toLowerCase();
  if (!/^(?:ascending|asc|descending|desc|1|-1)$/.test(val)) {
    if (Array.isArray(value))
      value = "[" + value + "]";
    throw newRxTypeError("MQ7", {
      field,
      value
    });
  }
  var s = opts.sort || (opts.sort = {});
  var valueStr = value.toString().replace("asc", "1").replace("ascending", "1").replace("desc", "-1").replace("descending", "-1");
  s[field] = parseInt(valueStr, 10);
}
function _pushArr(opts, field, value) {
  opts.sort = opts.sort || [];
  if (!Array.isArray(opts.sort)) {
    throw newRxTypeError("MQ8", {
      opts,
      field,
      value
    });
  }
  opts.sort.push([field, value]);
}
function canMerge(conds) {
  return conds instanceof NoSqlQueryBuilderClass || isObject(conds);
}
function createQueryBuilder(query, path) {
  return new NoSqlQueryBuilderClass(query, path);
}
var RXQUERY_OTHER_FLAG = "queryBuilderPath";
function runBuildingStep(rxQuery, functionName, value) {
  var queryBuilder = createQueryBuilder(clone(rxQuery.mangoQuery), rxQuery.other[RXQUERY_OTHER_FLAG]);
  queryBuilder[functionName](value);
  var queryBuilderJson = queryBuilder.toJSON();
  return createRxQuery(rxQuery.op, queryBuilderJson.query, rxQuery.collection, {
    ...rxQuery.other,
    [RXQUERY_OTHER_FLAG]: queryBuilderJson.path
  });
}
function applyBuildingStep(proto, functionName) {
  proto[functionName] = function(value) {
    return runBuildingStep(this, functionName, value);
  };
}
var RxDBQueryBuilderPlugin = {
  name: "query-builder",
  rxdb: true,
  prototypes: {
    RxQuery(proto) {
      ["where", "equals", "eq", "or", "nor", "and", "mod", "exists", "elemMatch", "sort"].forEach((attribute) => {
        applyBuildingStep(proto, attribute);
      });
      OTHER_MANGO_ATTRIBUTES.forEach((attribute) => {
        applyBuildingStep(proto, attribute);
      });
      OTHER_MANGO_OPERATORS.forEach((operator) => {
        applyBuildingStep(proto, operator);
      });
    }
  }
};
var ERROR_MESSAGES = {
  // util.js / config
  UT1: "given name is no string or empty",
  UT2: "collection- and database-names must match the regex to be compatible with couchdb databases.\n    See https://neighbourhood.ie/blog/2020/10/13/everything-you-need-to-know-about-couchdb-database-names/\n    info: if your database-name specifies a folder, the name must contain the slash-char '/' or '\\'",
  UT3: "replication-direction must either be push or pull or both. But not none",
  UT4: "given leveldown is no valid adapter",
  UT5: "keyCompression is set to true in the schema but no key-compression handler is used in the storage",
  UT6: "schema contains encrypted fields but no encryption handler is used in the storage",
  UT7: "attachments.compression is enabled but no attachment-compression plugin is used",
  // plugins
  PL1: "Given plugin is not RxDB plugin.",
  // removed in 14.0.0 - PouchDB RxStorage was removed - PL2: 'You tried importing a RxDB plugin to pouchdb. Use addRxPlugin() instead.',
  PL3: "A plugin with the same name was already added but it was not the exact same JavaScript object",
  // pouch-db.js
  // removed in 12.0.0 - P1: 'PouchDB.getBatch: limit must be > 2',
  P2: "bulkWrite() cannot be called with an empty array",
  // removed in 12.0.0 - P3: 'bulkAddRevisions cannot be called with an empty array',
  // rx-query
  QU1: "RxQuery._execOverDatabase(): op not known",
  // removed in 9.0.0 - QU2: 'limit() must get a number',
  // removed in 9.0.0 - QU3: 'skip() must get a number',
  QU4: "RxQuery.regex(): You cannot use .regex() on the primary field",
  QU5: "RxQuery.sort(): does not work because key is not defined in the schema",
  QU6: "RxQuery.limit(): cannot be called on .findOne()",
  // removed in 12.0.0 (should by ensured by the typings) - QU7: 'query must be an object',
  // removed in 12.0.0 (should by ensured by the typings) - QU8: 'query cannot be an array',
  QU9: "throwIfMissing can only be used in findOne queries",
  QU10: "result empty and throwIfMissing: true",
  QU11: "RxQuery: no valid query params given",
  QU12: "Given index is not in schema",
  QU13: "A top level field of the query is not included in the schema",
  QU14: "Running a count() query in slow mode is now allowed. Either run a count() query with a selector that fully matches an index or set allowSlowCount=true when calling the createRxDatabase",
  QU15: "For count queries it is not allowed to use skip or limit",
  QU16: "$regex queries must be defined by a string, not an RegExp instance. This is because RegExp objects cannot be JSON stringified and also they are mutable which would be dangerous",
  // mquery.js
  MQ1: "path must be a string or object",
  MQ2: "Invalid argument",
  MQ3: "Invalid sort() argument. Must be a string, object, or array",
  MQ4: "Invalid argument. Expected instanceof mquery or plain object",
  MQ5: "method must be used after where() when called with these arguments",
  MQ6: "Can't mix sort syntaxes. Use either array or object | .sort([['field', 1], ['test', -1]]) | .sort({ field: 1, test: -1 })",
  MQ7: "Invalid sort value",
  MQ8: "Can't mix sort syntaxes. Use either array or object",
  // rx-database
  DB1: "RxDocument.prepare(): another instance on this adapter has a different password",
  DB2: "RxDatabase.addCollections(): collection-names cannot start with underscore _",
  DB3: "RxDatabase.addCollections(): collection already exists. use myDatabase.[collectionName] to get it",
  DB4: "RxDatabase.addCollections(): schema is missing",
  DB5: "RxDatabase.addCollections(): collection-name not allowed",
  DB6: "RxDatabase.addCollections(): another instance created this collection with a different schema. Read this https://pubkey.github.io/rxdb/questions-answers.html#cant-change-the-schema",
  // removed in 13.0.0 (now part of the encryption plugin) DB7: 'RxDatabase.addCollections(): schema encrypted but no password given',
  DB8: "RxDatabase.create(): A RxDatabase with the same name and adapter already exists.\nMake sure to use this combination only once or set ignoreDuplicate to true if you do this intentional",
  // removed in 14.0.0 - PouchDB RxStorage is removed - DB9: 'createRxDatabase(): Adapter not added. Use addPouchPlugin(require(\'pouchdb-adapter-[adaptername]\'));',
  // removed in 14.0.0 - PouchDB RxStorage is removed DB10: 'createRxDatabase(): To use leveldown-adapters, you have to add the leveldb-plugin. Use addPouchPlugin(require(\'pouchdb-adapter-leveldb\'));',
  DB11: "createRxDatabase(): Invalid db-name, folder-paths must not have an ending slash",
  DB12: "RxDatabase.addCollections(): could not write to internal store",
  DB13: "createRxDatabase(): Invalid db-name or collection name, name contains the dollar sign",
  // rx-collection
  COL1: "RxDocument.insert() You cannot insert an existing document",
  COL2: "RxCollection.insert() fieldName ._id can only be used as primaryKey",
  COL3: "RxCollection.upsert() does not work without primary",
  COL4: "RxCollection.incrementalUpsert() does not work without primary",
  COL5: "RxCollection.find() if you want to search by _id, use .findOne(_id)",
  COL6: "RxCollection.findOne() needs a queryObject or string",
  COL7: "hook must be a function",
  COL8: "hooks-when not known",
  COL9: "RxCollection.addHook() hook-name not known",
  COL10: "RxCollection .postCreate-hooks cannot be async",
  COL11: "migrationStrategies must be an object",
  COL12: "A migrationStrategy is missing or too much",
  COL13: "migrationStrategy must be a function",
  COL14: "given static method-name is not a string",
  COL15: "static method-names cannot start with underscore _",
  COL16: "given static method is not a function",
  COL17: "RxCollection.ORM: statics-name not allowed",
  COL18: "collection-method not allowed because fieldname is in the schema",
  // removed in 14.0.0, use CONFLICT instead - COL19: 'Document update conflict. When changing a document you must work on the previous revision',
  COL20: "Storage write error",
  CONFLICT: "Document update conflict. When changing a document you must work on the previous revision",
  // rx-document.js
  DOC1: "RxDocument.get$ cannot get observable of in-array fields because order cannot be guessed",
  DOC2: "cannot observe primary path",
  DOC3: "final fields cannot be observed",
  DOC4: "RxDocument.get$ cannot observe a non-existed field",
  DOC5: "RxDocument.populate() cannot populate a non-existed field",
  DOC6: "RxDocument.populate() cannot populate because path has no ref",
  DOC7: "RxDocument.populate() ref-collection not in database",
  DOC8: "RxDocument.set(): primary-key cannot be modified",
  DOC9: "final fields cannot be modified",
  DOC10: "RxDocument.set(): cannot set childpath when rootPath not selected",
  DOC11: "RxDocument.save(): can't save deleted document",
  // removed in 10.0.0 DOC12: 'RxDocument.save(): error',
  DOC13: "RxDocument.remove(): Document is already deleted",
  DOC14: "RxDocument.destroy() does not exist",
  DOC15: "query cannot be an array",
  DOC16: "Since version 8.0.0 RxDocument.set() can only be called on temporary RxDocuments",
  DOC17: "Since version 8.0.0 RxDocument.save() can only be called on non-temporary documents",
  DOC18: "Document property for composed primary key is missing",
  DOC19: "Value of primary key(s) cannot be changed",
  DOC20: "PrimaryKey missing",
  DOC21: "PrimaryKey must be equal to PrimaryKey.trim(). It cannot start or end with a whitespace",
  DOC22: "PrimaryKey must not contain a linebreak",
  DOC23: 'PrimaryKey must not contain a double-quote ["]',
  DOC24: "Given document data could not be structured cloned. This happens if you pass non-plain-json data into it, like a Date() or a Function. In vue.js this happens if you use ref() on the document data which transforms it into a Proxy object.",
  // data-migrator.js
  DM1: "migrate() Migration has already run",
  DM2: "migration of document failed final document does not match final schema",
  DM3: "migration already running",
  DM4: "Migration errored",
  DM5: "Cannot open database state with newer RxDB version. You have to migrate your database state first. See see https://rxdb.info/migration-storage.html",
  // plugins/attachments.js
  AT1: "to use attachments, please define this in your schema",
  // plugins/encryption-crypto-js.js
  EN1: "password is not valid",
  EN2: "validatePassword: min-length of password not complied",
  EN3: "Schema contains encrypted properties but no password is given",
  EN4: "Password not valid",
  // plugins/json-dump.js
  JD1: "You must create the collections before you can import their data",
  JD2: "RxCollection.importJSON(): the imported json relies on a different schema",
  JD3: "RxCollection.importJSON(): json.passwordHash does not match the own",
  // plugins/leader-election.js
  // plugins/local-documents.js
  LD1: "RxDocument.allAttachments$ can't use attachments on local documents",
  LD2: "RxDocument.get(): objPath must be a string",
  LD3: "RxDocument.get$ cannot get observable of in-array fields because order cannot be guessed",
  LD4: "cannot observe primary path",
  LD5: "RxDocument.set() id cannot be modified",
  LD6: "LocalDocument: Function is not usable on local documents",
  LD7: "Local document already exists",
  LD8: "localDocuments not activated. Set localDocuments=true on creation, when you want to store local documents on the RxDatabase or RxCollection.",
  // plugins/replication.js
  RC1: "Replication: already added",
  RC2: "replicateCouchDB() query must be from the same RxCollection",
  // removed in 14.0.0 - PouchDB RxStorage is removed RC3: 'RxCollection.syncCouchDB() Do not use a collection\'s pouchdb as remote, use the collection instead',
  RC4: "RxCouchDBReplicationState.awaitInitialReplication() cannot await initial replication when live: true",
  RC5: "RxCouchDBReplicationState.awaitInitialReplication() cannot await initial replication if multiInstance because the replication might run on another instance",
  RC6: "syncFirestore() serverTimestampField MUST NOT be part of the collections schema and MUST NOT be nested.",
  RC_PULL: "RxReplication pull handler threw an error - see .errors for more details",
  RC_STREAM: "RxReplication pull stream$ threw an error - see .errors for more details",
  RC_PUSH: "RxReplication push handler threw an error - see .errors for more details",
  RC_PUSH_NO_AR: "RxReplication push handler did not return an array with the conflicts",
  RC_WEBRTC_PEER: "RxReplication WebRTC Peer has error",
  RC_COUCHDB_1: "replicateCouchDB() url must end with a slash like 'https://example.com/mydatabase/'",
  RC_COUCHDB_2: "replicateCouchDB() did not get valid result with rows.",
  RC_OUTDATED: "Outdated client, update required. Replication was canceled",
  RC_UNAUTHORIZED: "Unauthorized client, update the replicationState.headers to set correct auth data",
  RC_FORBIDDEN: "Client behaves wrong so the replication was canceled. Mostly happens if the client tries to write data that it is not allowed to",
  // plugins/dev-mode/check-schema.js
  SC1: "fieldnames do not match the regex",
  SC2: "SchemaCheck: name 'item' reserved for array-fields",
  SC3: "SchemaCheck: fieldname has a ref-array but items-type is not string",
  SC4: "SchemaCheck: fieldname has a ref but is not type string, [string,null] or array<string>",
  SC6: "SchemaCheck: primary can only be defined at top-level",
  SC7: "SchemaCheck: default-values can only be defined at top-level",
  SC8: "SchemaCheck: first level-fields cannot start with underscore _",
  SC10: "SchemaCheck: schema defines ._rev, this will be done automatically",
  SC11: "SchemaCheck: schema needs a number >=0 as version",
  // removed in 10.0.0 - SC12: 'SchemaCheck: primary can only be defined once',
  SC13: "SchemaCheck: primary is always index, do not declare it as index",
  SC14: "SchemaCheck: primary is always unique, do not declare it as index",
  SC15: "SchemaCheck: primary cannot be encrypted",
  SC16: "SchemaCheck: primary must have type: string",
  SC17: "SchemaCheck: top-level fieldname is not allowed",
  SC18: "SchemaCheck: indexes must be an array",
  SC19: "SchemaCheck: indexes must contain strings or arrays of strings",
  SC20: "SchemaCheck: indexes.array must contain strings",
  SC21: "SchemaCheck: given index is not defined in schema",
  SC22: "SchemaCheck: given indexKey is not type:string",
  SC23: "SchemaCheck: fieldname is not allowed",
  SC24: "SchemaCheck: required fields must be set via array. See https://spacetelescope.github.io/understanding-json-schema/reference/object.html#required",
  SC25: "SchemaCheck: compoundIndexes needs to be specified in the indexes field",
  SC26: "SchemaCheck: indexes needs to be specified at collection schema level",
  SC27: "SchemaCheck: encrypted fields need to be specified at collection schema level",
  SC28: "SchemaCheck: encrypted fields is not defined in the schema",
  SC29: "SchemaCheck: missing object key 'properties'",
  SC30: "SchemaCheck: primaryKey is required",
  SC32: "SchemaCheck: primary field must have the type string/number/integer",
  SC33: "SchemaCheck: used primary key is not a property in the schema",
  SC34: "Fields of type string that are used in an index, must have set the maxLength attribute in the schema",
  SC35: "Fields of type number/integer that are used in an index, must have set the multipleOf attribute in the schema",
  SC36: "A field of this type cannot be used as index",
  SC37: "Fields of type number that are used in an index, must have set the minimum and maximum attribute in the schema",
  SC38: "Fields of type boolean that are used in an index, must be required in the schema",
  SC39: "The primary key must have the maxLength attribute set",
  SC40: "$ref fields in the schema are not allowed. RxDB cannot resolve related schemas because it would have a negative performance impact.It would have to run http requests on runtime. $ref fields should be resolved during build time.",
  // plugins/dev-mode
  // removed in 13.9.0, use PL3 instead - DEV1: 'dev-mode added multiple times',
  // plugins/validate.js
  VD1: "Sub-schema not found, does the schemaPath exists in your schema?",
  VD2: "object does not match schema",
  // plugins/in-memory.js
  // removed in 14.0.0 - PouchDB RxStorage is removed IM1: 'InMemory: Memory-Adapter must be added. Use addPouchPlugin(require(\'pouchdb-adapter-memory\'));',
  // removed in 14.0.0 - PouchDB RxStorage is removed IM2: 'inMemoryCollection.sync(): Do not replicate with the in-memory instance. Replicate with the parent instead',
  // plugins/server.js
  S1: "You cannot create collections after calling RxDatabase.server()",
  // plugins/replication-graphql.js
  GQL1: "GraphQL replication: cannot find sub schema by key",
  // removed in 13.0.0, use RC_PULL instead - GQL2: 'GraphQL replication: unknown errors occurred in replication pull - see innerErrors for more details',
  GQL3: "GraphQL replication: pull returns more documents then batchSize",
  // removed in 13.0.0, use RC_PUSH instead - GQL4: 'GraphQL replication: unknown errors occurred in replication push - see innerErrors for more details',
  // plugins/crdt/
  CRDT1: "CRDT operations cannot be used because the crdt options are not set in the schema.",
  CRDT2: "RxDocument.incrementalModify() cannot be used when CRDTs are activated.",
  CRDT3: "To use CRDTs you MUST NOT set a conflictHandler because the default CRDT conflict handler must be used",
  // plugins/storage-dexie/
  // removed in 15.0.0, added boolean index support to dexie storage - DXE1: 'The dexie.js RxStorage does not support boolean indexes, see https://rxdb.info/rx-storage-dexie.html#boolean-index',
  /**
   * Should never be thrown, use this for
   * null checks etc. so you do not have to increase the
   * build size with error message strings.
   */
  SNH: "This should never happen"
};
var _rxCollectionProperties;
function rxCollectionProperties() {
  if (!_rxCollectionProperties) {
    var pseudoInstance = new RxCollectionBase();
    var ownProperties = Object.getOwnPropertyNames(pseudoInstance);
    var prototypeProperties = Object.getOwnPropertyNames(Object.getPrototypeOf(pseudoInstance));
    _rxCollectionProperties = [...ownProperties, ...prototypeProperties];
  }
  return _rxCollectionProperties;
}
var _rxDatabaseProperties;
function rxDatabaseProperties() {
  if (!_rxDatabaseProperties) {
    var pseudoInstance = new RxDatabaseBase("pseudoInstance", "memory");
    var ownProperties = Object.getOwnPropertyNames(pseudoInstance);
    var prototypeProperties = Object.getOwnPropertyNames(Object.getPrototypeOf(pseudoInstance));
    _rxDatabaseProperties = [...ownProperties, ...prototypeProperties];
    pseudoInstance.destroy();
  }
  return _rxDatabaseProperties;
}
var pseudoConstructor = createRxDocumentConstructor(basePrototype);
var pseudoRxDocument = new pseudoConstructor();
var _rxDocumentProperties;
function rxDocumentProperties() {
  if (!_rxDocumentProperties) {
    var reserved = ["deleted", "synced"];
    var ownProperties = Object.getOwnPropertyNames(pseudoRxDocument);
    var prototypeProperties = Object.getOwnPropertyNames(basePrototype);
    _rxDocumentProperties = [...ownProperties, ...prototypeProperties, ...reserved];
  }
  return _rxDocumentProperties;
}
function checkFieldNameRegex(fieldName) {
  if (fieldName === "_deleted") {
    return;
  }
  if (["properties"].includes(fieldName)) {
    throw newRxError("SC23", {
      fieldName
    });
  }
  var regexStr = "^[a-zA-Z](?:[[a-zA-Z0-9_]*]?[a-zA-Z0-9])?$";
  var regex = new RegExp(regexStr);
  if (
    /**
     * It must be allowed to set _id as primaryKey.
     * This makes it sometimes easier to work with RxDB+CouchDB
     * @link https://github.com/pubkey/rxdb/issues/681
     */
    fieldName !== "_id" && !fieldName.match(regex)
  ) {
    throw newRxError("SC1", {
      regex: regexStr,
      fieldName
    });
  }
}
function validateFieldsDeep(rxJsonSchema) {
  var primaryPath = getPrimaryFieldOfPrimaryKey(rxJsonSchema.primaryKey);
  function checkField(fieldName, schemaObj, path) {
    if (typeof fieldName === "string" && typeof schemaObj === "object" && !Array.isArray(schemaObj) && path.split(".").pop() !== "patternProperties")
      checkFieldNameRegex(fieldName);
    if (Object.prototype.hasOwnProperty.call(schemaObj, "item") && schemaObj.type !== "array") {
      throw newRxError("SC2", {
        fieldName
      });
    }
    if (Object.prototype.hasOwnProperty.call(schemaObj, "required") && typeof schemaObj.required === "boolean") {
      throw newRxError("SC24", {
        fieldName
      });
    }
    if (Object.prototype.hasOwnProperty.call(schemaObj, "$ref")) {
      throw newRxError("SC40", {
        fieldName
      });
    }
    if (Object.prototype.hasOwnProperty.call(schemaObj, "ref")) {
      if (Array.isArray(schemaObj.type)) {
        if (schemaObj.type.length > 2 || !schemaObj.type.includes("string") || !schemaObj.type.includes("null")) {
          throw newRxError("SC4", {
            fieldName
          });
        }
      } else {
        switch (schemaObj.type) {
          case "string":
            break;
          case "array":
            if (!schemaObj.items || !schemaObj.items.type || schemaObj.items.type !== "string") {
              throw newRxError("SC3", {
                fieldName
              });
            }
            break;
          default:
            throw newRxError("SC4", {
              fieldName
            });
        }
      }
    }
    var isNested = path.split(".").length >= 2;
    if (isNested) {
      if (schemaObj.default) {
        throw newRxError("SC7", {
          path
        });
      }
    }
    if (!isNested) {
      if (fieldName === "_id" && primaryPath !== "_id") {
        throw newRxError("COL2", {
          fieldName
        });
      }
      if (fieldName.charAt(0) === "_") {
        if (
          // exceptional allow underscore on these fields.
          fieldName === "_id" || fieldName === "_deleted"
        ) {
          return;
        }
        throw newRxError("SC8", {
          fieldName
        });
      }
    }
  }
  function traverse(currentObj, currentPath) {
    if (!currentObj || typeof currentObj !== "object") {
      return;
    }
    Object.keys(currentObj).forEach((attributeName) => {
      var schemaObj = currentObj[attributeName];
      if (!currentObj.properties && schemaObj && typeof schemaObj === "object" && !Array.isArray(currentObj)) {
        checkField(attributeName, schemaObj, currentPath);
      }
      var nextPath = currentPath;
      if (attributeName !== "properties")
        nextPath = nextPath + "." + attributeName;
      traverse(schemaObj, nextPath);
    });
  }
  traverse(rxJsonSchema, "");
  return true;
}
function checkPrimaryKey(jsonSchema) {
  if (!jsonSchema.primaryKey) {
    throw newRxError("SC30", {
      schema: jsonSchema
    });
  }
  function validatePrimarySchemaPart(schemaPart2) {
    if (!schemaPart2) {
      throw newRxError("SC33", {
        schema: jsonSchema
      });
    }
    var type2 = schemaPart2.type;
    if (!type2 || !["string", "number", "integer"].includes(type2)) {
      throw newRxError("SC32", {
        schema: jsonSchema,
        args: {
          schemaPart: schemaPart2
        }
      });
    }
  }
  if (typeof jsonSchema.primaryKey === "string") {
    var key = jsonSchema.primaryKey;
    var schemaPart = jsonSchema.properties[key];
    validatePrimarySchemaPart(schemaPart);
  } else {
    var compositePrimaryKey = jsonSchema.primaryKey;
    var keySchemaPart = getSchemaByObjectPath(jsonSchema, compositePrimaryKey.key);
    validatePrimarySchemaPart(keySchemaPart);
    compositePrimaryKey.fields.forEach((field) => {
      var schemaPart2 = getSchemaByObjectPath(jsonSchema, field);
      validatePrimarySchemaPart(schemaPart2);
    });
  }
  var primaryPath = getPrimaryFieldOfPrimaryKey(jsonSchema.primaryKey);
  var primaryPathSchemaPart = jsonSchema.properties[primaryPath];
  if (!primaryPathSchemaPart.maxLength) {
    throw newRxError("SC39", {
      schema: jsonSchema,
      args: {
        primaryPathSchemaPart
      }
    });
  }
}
function getSchemaPropertyRealPath(shortPath) {
  var pathParts = shortPath.split(".");
  var realPath = "";
  for (var i = 0; i < pathParts.length; i += 1) {
    if (pathParts[i] !== "[]") {
      realPath = realPath.concat(".properties.".concat(pathParts[i]));
    } else {
      realPath = realPath.concat(".items");
    }
  }
  return trimDots(realPath);
}
function checkSchema(jsonSchema) {
  if (!jsonSchema.primaryKey) {
    throw newRxError("SC30", {
      schema: jsonSchema
    });
  }
  if (!Object.prototype.hasOwnProperty.call(jsonSchema, "properties")) {
    throw newRxError("SC29", {
      schema: jsonSchema
    });
  }
  if (jsonSchema.properties._rev) {
    throw newRxError("SC10", {
      schema: jsonSchema
    });
  }
  if (!Object.prototype.hasOwnProperty.call(jsonSchema, "version") || typeof jsonSchema.version !== "number" || jsonSchema.version < 0) {
    throw newRxError("SC11", {
      version: jsonSchema.version
    });
  }
  validateFieldsDeep(jsonSchema);
  checkPrimaryKey(jsonSchema);
  Object.keys(jsonSchema.properties).forEach((key) => {
    var value = jsonSchema.properties[key];
    if (key === jsonSchema.primaryKey) {
      if (jsonSchema.indexes && jsonSchema.indexes.includes(key)) {
        throw newRxError("SC13", {
          value,
          schema: jsonSchema
        });
      }
      if (value.unique) {
        throw newRxError("SC14", {
          value,
          schema: jsonSchema
        });
      }
      if (jsonSchema.encrypted && jsonSchema.encrypted.includes(key)) {
        throw newRxError("SC15", {
          value,
          schema: jsonSchema
        });
      }
      if (value.type !== "string") {
        throw newRxError("SC16", {
          value,
          schema: jsonSchema
        });
      }
    }
    if (rxDocumentProperties().includes(key)) {
      throw newRxError("SC17", {
        key,
        schema: jsonSchema
      });
    }
  });
  if (jsonSchema.indexes) {
    if (!isMaybeReadonlyArray(jsonSchema.indexes)) {
      throw newRxError("SC18", {
        indexes: jsonSchema.indexes,
        schema: jsonSchema
      });
    }
    jsonSchema.indexes.forEach((index) => {
      if (!(typeof index === "string" || Array.isArray(index))) {
        throw newRxError("SC19", {
          index,
          schema: jsonSchema
        });
      }
      if (Array.isArray(index)) {
        for (var i = 0; i < index.length; i += 1) {
          if (typeof index[i] !== "string") {
            throw newRxError("SC20", {
              index,
              schema: jsonSchema
            });
          }
        }
      }
      var indexAsArray = isMaybeReadonlyArray(index) ? index : [index];
      indexAsArray.forEach((fieldName) => {
        var schemaPart = getSchemaByObjectPath(jsonSchema, fieldName);
        var type2 = schemaPart.type;
        switch (type2) {
          case "string":
            var maxLength = schemaPart.maxLength;
            if (!maxLength) {
              throw newRxError("SC34", {
                index,
                field: fieldName,
                schema: jsonSchema
              });
            }
            break;
          case "number":
          case "integer":
            var multipleOf = schemaPart.multipleOf;
            if (!multipleOf) {
              throw newRxError("SC35", {
                index,
                field: fieldName,
                schema: jsonSchema
              });
            }
            var maximum = schemaPart.maximum;
            var minimum = schemaPart.minimum;
            if (typeof maximum === "undefined" || typeof minimum === "undefined") {
              throw newRxError("SC37", {
                index,
                field: fieldName,
                schema: jsonSchema
              });
            }
            break;
          case "boolean":
            var parentPath = "";
            var lastPathPart = fieldName;
            if (fieldName.includes(".")) {
              var partParts = fieldName.split(".");
              lastPathPart = partParts.pop();
              parentPath = partParts.join(".");
            }
            var parentSchemaPart = parentPath === "" ? jsonSchema : getSchemaByObjectPath(jsonSchema, parentPath);
            if (!parentSchemaPart.required || !parentSchemaPart.required.includes(lastPathPart)) {
              throw newRxError("SC38", {
                index,
                field: fieldName,
                schema: jsonSchema
              });
            }
            break;
          default:
            throw newRxError("SC36", {
              fieldName,
              type: schemaPart.type,
              schema: jsonSchema
            });
        }
      });
    });
  }
  Object.keys(flattenObject(jsonSchema)).map((key) => {
    var split = key.split(".");
    split.pop();
    return split.join(".");
  }).filter((key) => key !== "").filter((elem, pos, arr) => arr.indexOf(elem) === pos).filter((key) => {
    var value = getProperty$1(jsonSchema, key);
    return value && !!value.index;
  }).forEach((key) => {
    key = key.replace("properties.", "");
    key = key.replace(/\.properties\./g, ".");
    throw newRxError("SC26", {
      index: trimDots(key),
      schema: jsonSchema
    });
  });
  (jsonSchema.indexes || []).reduce((indexPaths, currentIndex) => {
    if (isMaybeReadonlyArray(currentIndex)) {
      appendToArray(indexPaths, currentIndex);
    } else {
      indexPaths.push(currentIndex);
    }
    return indexPaths;
  }, []).filter((elem, pos, arr) => arr.indexOf(elem) === pos).map((indexPath) => {
    var realPath = getSchemaPropertyRealPath(indexPath);
    var schemaObj = getProperty$1(jsonSchema, realPath);
    if (!schemaObj || typeof schemaObj !== "object") {
      throw newRxError("SC21", {
        index: indexPath,
        schema: jsonSchema
      });
    }
    return {
      indexPath,
      schemaObj
    };
  }).filter((index) => index.schemaObj.type !== "string" && index.schemaObj.type !== "integer" && index.schemaObj.type !== "number" && index.schemaObj.type !== "boolean").forEach((index) => {
    throw newRxError("SC22", {
      key: index.indexPath,
      type: index.schemaObj.type,
      schema: jsonSchema
    });
  });
  Object.keys(flattenObject(jsonSchema)).map((key) => {
    var split = key.split(".");
    split.pop();
    return split.join(".");
  }).filter((key) => key !== "" && key !== "attachments").filter((elem, pos, arr) => arr.indexOf(elem) === pos).filter((key) => {
    var value = getProperty$1(jsonSchema, key);
    return value && !!value.encrypted;
  }).forEach((key) => {
    key = key.replace("properties.", "");
    key = key.replace(/\.properties\./g, ".");
    throw newRxError("SC27", {
      index: trimDots(key),
      schema: jsonSchema
    });
  });
  if (jsonSchema.encrypted) {
    jsonSchema.encrypted.forEach((propPath) => {
      var realPath = getSchemaPropertyRealPath(propPath);
      var schemaObj = getProperty$1(jsonSchema, realPath);
      if (!schemaObj || typeof schemaObj !== "object") {
        throw newRxError("SC28", {
          field: propPath,
          schema: jsonSchema
        });
      }
    });
  }
}
function checkOrmMethods(statics) {
  if (!statics) {
    return;
  }
  Object.entries(statics).forEach(([k2, v2]) => {
    if (typeof k2 !== "string") {
      throw newRxTypeError("COL14", {
        name: k2
      });
    }
    if (k2.startsWith("_")) {
      throw newRxTypeError("COL15", {
        name: k2
      });
    }
    if (typeof v2 !== "function") {
      throw newRxTypeError("COL16", {
        name: k2,
        type: typeof k2
      });
    }
    if (rxCollectionProperties().includes(k2) || rxDocumentProperties().includes(k2)) {
      throw newRxError("COL17", {
        name: k2
      });
    }
  });
}
function checkOrmDocumentMethods(schema, methods) {
  var topLevelFields = Object.keys(schema.properties);
  if (!methods) {
    return;
  }
  Object.keys(methods).filter((funName) => topLevelFields.includes(funName)).forEach((funName) => {
    throw newRxError("COL18", {
      funName
    });
  });
}
function checkMigrationStrategies(schema, migrationStrategies) {
  if (typeof migrationStrategies !== "object" || Array.isArray(migrationStrategies)) {
    throw newRxTypeError("COL11", {
      schema
    });
  }
  var previousVersions = getPreviousVersions(schema);
  if (previousVersions.length !== Object.keys(migrationStrategies).length) {
    throw newRxError("COL12", {
      have: Object.keys(migrationStrategies),
      should: previousVersions
    });
  }
  previousVersions.map((vNr) => ({
    v: vNr,
    s: migrationStrategies[vNr + 1]
  })).filter((strategy) => typeof strategy.s !== "function").forEach((strategy) => {
    throw newRxTypeError("COL13", {
      version: strategy.v,
      type: typeof strategy,
      schema
    });
  });
  return true;
}
function ensureCollectionNameValid(args2) {
  if (rxDatabaseProperties().includes(args2.name)) {
    throw newRxError("DB5", {
      name: args2.name
    });
  }
  validateDatabaseName(args2.name);
}
function ensureDatabaseNameIsValid(args2) {
  validateDatabaseName(args2.name);
  if (args2.name.includes("$")) {
    throw newRxError("DB13", {
      name: args2.name
    });
  }
  if (isFolderPath(args2.name)) {
    if (args2.name.endsWith("/") || args2.name.endsWith("\\")) {
      throw newRxError("DB11", {
        name: args2.name
      });
    }
  }
}
var validCouchDBStringRegexStr = "^[a-z][_$a-z0-9\\-]*$";
var validCouchDBStringRegex = new RegExp(validCouchDBStringRegexStr);
function validateDatabaseName(name) {
  if (typeof name !== "string" || name.length === 0) {
    throw newRxTypeError("UT1", {
      name
    });
  }
  if (isFolderPath(name)) {
    return true;
  }
  if (!name.match(validCouchDBStringRegex) && /**
   * The string ':memory:' is used in the SQLite RxStorage
   * to persist data into a memory state. Often used in tests.
   */
  name !== ":memory:") {
    throw newRxError("UT2", {
      regex: validCouchDBStringRegexStr,
      givenName: name
    });
  }
  return true;
}
function checkQuery(args2) {
  var isPlainObject = Object.prototype.toString.call(args2.queryObj) === "[object Object]";
  if (!isPlainObject) {
    throw newRxTypeError("QU11", {
      op: args2.op,
      collection: args2.collection.name,
      queryObj: args2.queryObj
    });
  }
  var validKeys = ["selector", "limit", "skip", "sort", "index"];
  Object.keys(args2.queryObj).forEach((key) => {
    if (!validKeys.includes(key)) {
      throw newRxTypeError("QU11", {
        op: args2.op,
        collection: args2.collection.name,
        queryObj: args2.queryObj,
        key,
        args: {
          validKeys
        }
      });
    }
  });
  if (args2.op === "count" && (args2.queryObj.limit || args2.queryObj.skip)) {
    throw newRxError("QU15", {
      collection: args2.collection.name,
      query: args2.queryObj
    });
  }
  ensureObjectDoesNotContainRegExp(args2.queryObj);
}
function checkMangoQuery(args2) {
  var schema = args2.rxQuery.collection.schema.jsonSchema;
  var massagedSelector = args2.mangoQuery.selector;
  var schemaTopLevelFields = Object.keys(schema.properties);
  Object.keys(massagedSelector).filter((fieldOrOperator) => !fieldOrOperator.startsWith("$")).filter((field) => !field.includes(".")).forEach((field) => {
    if (!schemaTopLevelFields.includes(field)) {
      throw newRxError("QU13", {
        schema,
        field,
        query: args2.mangoQuery
      });
    }
  });
  var schemaIndexes = schema.indexes ? schema.indexes : [];
  var index = args2.mangoQuery.index;
  if (index) {
    var isInSchema = schemaIndexes.find((schemaIndex) => deepEqual(schemaIndex, index));
    if (!isInSchema) {
      throw newRxError("QU12", {
        collection: args2.rxQuery.collection.name,
        query: args2.mangoQuery,
        schema
      });
    }
  }
  if (args2.rxQuery.op === "count") {
    if (!areSelectorsSatisfiedByIndex(args2.rxQuery.collection.schema.jsonSchema, args2.mangoQuery) && !args2.rxQuery.collection.database.allowSlowCount) {
      throw newRxError("QU14", {
        collection: args2.rxQuery.collection,
        query: args2.mangoQuery
      });
    }
  }
  if (args2.mangoQuery.sort) {
    args2.mangoQuery.sort.map((sortPart) => Object.keys(sortPart)[0]).filter((field) => !field.includes(".")).forEach((field) => {
      if (!schemaTopLevelFields.includes(field)) {
        throw newRxError("QU13", {
          schema,
          field,
          query: args2.mangoQuery
        });
      }
    });
  }
  ensureObjectDoesNotContainRegExp(args2.mangoQuery);
}
function areSelectorsSatisfiedByIndex(schema, query) {
  var preparedQuery = prepareQuery(schema, query);
  return preparedQuery.queryPlan.selectorSatisfiedByIndex;
}
function ensureObjectDoesNotContainRegExp(selector) {
  if (typeof selector !== "object" || selector === null) {
    return;
  }
  var keys = Object.keys(selector);
  keys.forEach((key) => {
    var value = selector[key];
    if (value instanceof RegExp) {
      throw newRxError("QU16", {
        field: key,
        query: selector
      });
    } else if (Array.isArray(value)) {
      value.forEach((item) => ensureObjectDoesNotContainRegExp(item));
    } else {
      ensureObjectDoesNotContainRegExp(value);
    }
  });
}
function ensurePrimaryKeyValid(primaryKey, docData) {
  if (!primaryKey) {
    throw newRxError("DOC20", {
      primaryKey,
      document: docData
    });
  }
  if (primaryKey !== primaryKey.trim()) {
    throw newRxError("DOC21", {
      primaryKey,
      document: docData
    });
  }
  if (primaryKey.includes("\r") || primaryKey.includes("\n")) {
    throw newRxError("DOC22", {
      primaryKey,
      document: docData
    });
  }
  if (primaryKey.includes('"')) {
    throw newRxError("DOC23", {
      primaryKey,
      document: docData
    });
  }
}
function deepFreezeWhenDevMode(obj) {
  if (!obj || typeof obj === "string" || typeof obj === "number") {
    return obj;
  }
  return deepFreeze(obj);
}
var DEV_MODE_PLUGIN_NAME = "dev-mode";
var RxDBDevModePlugin = {
  name: DEV_MODE_PLUGIN_NAME,
  rxdb: true,
  init: () => {
    console.warn([
      "-------------- RxDB dev-mode warning -------------------------------",
      "you are seeing this because you use the RxDB dev-mode plugin https://rxdb.info/dev-mode.html ",
      "This is great in development mode, because it will run many checks to ensure",
      "that you use RxDB correct. If you see this in production mode,",
      "you did something wrong because the dev-mode plugin will decrease the performance.",
      "",
      " Hint: To get the most out of RxDB, check out the Premium Plugins",
      "to get access to faster storages and more professional features: https://rxdb.info/premium",
      // '',
      // 'Also take part in the RxDB User Survey: https://rxdb.info/survey.html',
      "---------------------------------------------------------------------"
    ].join("\n"));
  },
  overwritable: {
    isDevMode() {
      return true;
    },
    deepFreezeWhenDevMode,
    tunnelErrorMessage(code) {
      if (!ERROR_MESSAGES[code]) {
        console.error("RxDB: Error-Code not known: " + code);
        throw new Error("Error-Code " + code + " not known, contact the maintainer");
      }
      return ERROR_MESSAGES[code];
    }
  },
  hooks: {
    preCreateRxSchema: {
      after: checkSchema
    },
    preCreateRxDatabase: {
      after: function(args2) {
        ensureDatabaseNameIsValid(args2);
      }
    },
    preCreateRxCollection: {
      after: function(args2) {
        ensureCollectionNameValid(args2);
        checkOrmDocumentMethods(args2.schema, args2.methods);
        if (args2.name.charAt(0) === "_") {
          throw newRxError("DB2", {
            name: args2.name
          });
        }
        if (!args2.schema) {
          throw newRxError("DB4", {
            name: args2.name,
            args: args2
          });
        }
      }
    },
    createRxDocument: {
      before: function(doc) {
        ensurePrimaryKeyValid(doc.primary, doc.toJSON(true));
      }
    },
    preCreateRxQuery: {
      after: function(args2) {
        checkQuery(args2);
      }
    },
    prePrepareQuery: {
      after: (args2) => {
        checkMangoQuery(args2);
      }
    },
    createRxCollection: {
      after: (args2) => {
        checkOrmMethods(args2.creator.statics);
        checkOrmMethods(args2.creator.methods);
        checkOrmMethods(args2.creator.attachments);
        if (args2.creator.schema && args2.creator.migrationStrategies) {
          checkMigrationStrategies(args2.creator.schema, args2.creator.migrationStrategies);
        }
      }
    }
  }
};
const users = [
  {
    id: "1",
    name: "Default User",
    pins: {
      releases: ["1", "2", "3"]
    }
  }
];
const releases = [
  {
    id: "2",
    name: "Akumajou Dracula X Chi no Rondo",
    platform: "nec-turbografx-16",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nec-turbografx-16/Akumajou Dracula X Chi no Rondo (J).rar"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/88361c82c4c7a04bd124fd053203d14f.png"
      ]
    }
  },
  {
    id: "3",
    name: "Bonk's Revenge",
    platform: "nec-turbografx-16",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nec-turbografx-16/Bonk's_Revenge_(U).pce"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/3c64051fab8d52009e4163540b0238d4.png"
      ]
    }
  },
  {
    id: "4",
    name: "Devil's Crush",
    platform: "nec-turbografx-16",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nec-turbografx-16/Devil's_Crush_(U).pce"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/d44c7816540784f751810f3bfac6b0b7.jpg"
      ]
    }
  },
  {
    id: "5",
    name: "Galaga '90",
    platform: "nec-turbografx-16",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nec-turbografx-16/Galaga '90 (USA).pce"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/3d2af85aa3541f3578f9ba31b413f9d9.png"
      ]
    }
  },
  {
    id: "6",
    name: "Magical Chase",
    platform: "nec-turbografx-16",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nec-turbografx-16/MAGCHASE.PCE"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/1e448dba292041fbf0926666bbf5f1d4.png"
      ]
    }
  },
  {
    id: "7",
    name: "Parodius! From Myth to Laughter",
    platform: "nec-turbografx-16",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nec-turbografx-16/Parodius Da! - Shinwa kara Owarai he (J).pce"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/833ef297b93415a147f518416e96a736.png"
      ]
    }
  },
  {
    id: "9",
    name: "Dr. Mario Turbo",
    platform: "nintendo-entertainment-system",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nintendo-entertainment-system/Dr. Mario Turbo.nes"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/1b185660481de822df4d173fbdb90908.png"
      ]
    }
  },
  {
    id: "10",
    name: "Duck Tales",
    platform: "nintendo-entertainment-system",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nintendo-entertainment-system/Duck Tales (USA).nes"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/68ef436ae9a785541beefdeacb8433b2.png"
      ]
    }
  },
  {
    id: "11",
    name: "Elite",
    platform: "nintendo-entertainment-system",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nintendo-entertainment-system/Elite.nes"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/0fd8c2c9a6e5516286350aa0a6c3e7be.png"
      ]
    }
  },
  {
    id: "12",
    name: "Galaxy 5000",
    platform: "nintendo-entertainment-system",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nintendo-entertainment-system/Galaxy 5000.nes"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/7dcabb41dcc303abd7d0c71ae989b492.png"
      ]
    }
  },
  {
    id: "13",
    name: "Kirby's Adventure",
    platform: "nintendo-entertainment-system",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nintendo-entertainment-system/Kirby's Adventure (USA) (Rev A)(1).zip"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/268bb3004e8bbc995fdd665d0cc731df.png"
      ]
    }
  },
  {
    id: "14",
    name: "Paperboy",
    platform: "nintendo-entertainment-system",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nintendo-entertainment-system/Paperboy (USA).zip"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/2a0c18f91bc6782a86ac3bdd56cfc483.png"
      ]
    }
  },
  {
    id: "15",
    name: "Super Mario Bros.",
    platform: "nintendo-entertainment-system",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nintendo-entertainment-system/Super Mario Bros. (World).nes"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/9f70f28aaa16ee9c92a8f315ceaaf0d1.png"
      ]
    }
  },
  {
    id: "16",
    name: "Super Mario Bros. 2",
    platform: "nintendo-entertainment-system",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nintendo-entertainment-system/Super Mario Bros. 2.nes"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/5e0572877d887071182fe81f03c510d7.png"
      ]
    }
  },
  {
    id: "17",
    name: "Super Mario Bros. 3",
    platform: "nintendo-entertainment-system",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nintendo-entertainment-system/Super Mario Bros. 3 (U) (PRG0) [!].nes"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/c5279e07367ef7ba59d6e772bfd9ac5d.png"
      ]
    }
  },
  {
    id: "18",
    name: "Tetris-hard-drop-stats",
    platform: "nintendo-entertainment-system",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nintendo-entertainment-system/Tetris-hard-drop-stats.nes"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/da2f5c70767a018829cb65f26d72fb8b.png"
      ]
    }
  },
  {
    id: "19",
    name: "Zelda - The Legend of Link",
    platform: "nintendo-entertainment-system",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nintendo-entertainment-system/Zelda - The Legend of Link.nes"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/8569af7f30d0cc9d05ed59141b51220e.png"
      ]
    }
  },
  {
    id: "20",
    name: "duck-tales-2",
    platform: "nintendo-entertainment-system",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nintendo-entertainment-system/duck-tales-2.nes"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/60cfde09247730b0745569ba3494bbb5.png"
      ]
    }
  },
  {
    id: "21",
    name: "Galaga",
    platform: "nintendo-entertainment-system",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nintendo-entertainment-system/galaga.nes"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/41a4f16be340241fc541152aa7c7b9d5.png"
      ]
    }
  },
  {
    id: "22",
    name: "Drill Dozer",
    platform: "nintendo-gameboy-advance",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nintendo-gameboy-advance/Drill Dozer (U).gba"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/707c65f70cb3f60c6a1f7ced7e9bf1ca.png"
      ]
    }
  },
  {
    id: "23",
    name: "Legend of Zelda, The - A Link To The Past Four Swords",
    platform: "nintendo-gameboy-advance",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nintendo-gameboy-advance/Legend of Zelda, The - A Link To The Past Four Swords (U) [!].gba"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/860450c0356941c8d1003d3252666739.jpg"
      ]
    }
  },
  {
    id: "24",
    name: "Legend of Zelda, The - The Minish Cap",
    platform: "nintendo-gameboy-advance",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nintendo-gameboy-advance/Legend of Zelda, The - The Minish Cap (U).gba"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/a687f78b9842c87225e74921765feb1b.png"
      ]
    }
  },
  {
    id: "25",
    name: "Metroid Fusion",
    platform: "nintendo-gameboy-advance",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nintendo-gameboy-advance/Metroid Fusion (USA, Australia).gba"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/8542e1ea3b61f1c76db84712e56b4b49.png"
      ]
    }
  },
  {
    id: "26",
    name: "Wario Land 4",
    platform: "nintendo-gameboy-advance",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nintendo-gameboy-advance/Wario Land 4 (UE) [!].gba"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/05d473743a62f7f3bfc3ecad84c1519c.png"
      ]
    }
  },
  {
    id: "27",
    name: "Donkey Kong",
    platform: "nintendo-gameboy-color",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nintendo-gameboy-color/Donkey Kong (JU) (V1.1) -S--!-.gb"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/85bc526b2660c952bf3513b7ada63a3d.png"
      ]
    }
  },
  {
    id: "28",
    name: "Legend of Zelda, The - Oracle of Ages",
    platform: "nintendo-gameboy-color",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nintendo-gameboy-color/Legend of Zelda, The - Oracle of Ages (USA).gbc"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/e66160e598192a253a015cb90ab371dc.png"
      ]
    }
  },
  {
    id: "29",
    name: "A Plumber For All Seasons",
    platform: "nintendo-super-nintendo-entertainment-system",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nintendo-super-nintendo-entertainment-system/A Plumber For All Seasons.sfc"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/a15d16998478f8d765e34a7513385153.png"
      ]
    }
  },
  {
    id: "31",
    name: "SMW2 Plus 2 - Yoshis Island",
    platform: "nintendo-super-nintendo-entertainment-system",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nintendo-super-nintendo-entertainment-system/SMW2 Plus 2 - Yoshis Island.fig"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/5b9320355914e4428c01f4427cce9bd1.png"
      ]
    }
  },
  {
    id: "32",
    name: "Secret of Mana",
    platform: "nintendo-super-nintendo-entertainment-system",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nintendo-super-nintendo-entertainment-system/Secret of Mana (U) [!].smc"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/60bfd49b4397b0d232e3809c31275b47.png"
      ]
    }
  },
  {
    id: "33",
    name: "Super Bomberman 4",
    platform: "nintendo-super-nintendo-entertainment-system",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nintendo-super-nintendo-entertainment-system/Super Bomberman 4 (Japan).sfc"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/34646aa7293510dc8f7cf3b8ebd19f3e.png"
      ]
    }
  },
  {
    id: "34",
    name: "Super Mario World",
    platform: "nintendo-super-nintendo-entertainment-system",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nintendo-super-nintendo-entertainment-system/Super Mario World (U) [!].smc"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/2bf887cd37fa5ba4ce0ba9713013a4f7.png"
      ]
    }
  },
  {
    id: "35",
    name: "Super Mario World - Bowsers Kaizo Conspiracy",
    platform: "nintendo-super-nintendo-entertainment-system",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nintendo-super-nintendo-entertainment-system/Super Mario World - Bowsers Kaizo Conspiracy.sfc"
      }
    ],
    media: {
      grids: [
        "https://cdn.discordapp.com/attachments/999532455088377948/1199110836665454642/simonwjackson_poster_for_the_video_game_named_Super_Mario_World_fe62287d-87e5-4b06-a92f-2a6246021b4a.png?ex=65c159fd&is=65aee4fd&hm=5ea66996e38569618d9063803ba68d52401ff1c229975afdc38d551409318e45&"
      ]
    }
  },
  {
    id: "37",
    name: "Super Mario World 2 - Yoshi's Island",
    platform: "nintendo-super-nintendo-entertainment-system",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nintendo-super-nintendo-entertainment-system/Super Mario World 2 - Yoshi's Island (U) (V1.1).smc"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/59857cc70355243795b398b32447b862.png"
      ]
    }
  },
  {
    id: "44",
    name: "Super Metroid",
    platform: "nintendo-super-nintendo-entertainment-system",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nintendo-super-nintendo-entertainment-system/Super Metroid.smc"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/fc57da7d0724ec671e4a1ba477e1b33a.png"
      ]
    }
  },
  {
    id: "45",
    name: "Super Off Road",
    platform: "nintendo-super-nintendo-entertainment-system",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nintendo-super-nintendo-entertainment-system/Super Off Road (U) [!].smc"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/e84cb22cfed09d23ef7b2fbc3b51a696.png"
      ]
    }
  },
  {
    id: "46",
    name: "Tetris Battle Gaiden",
    platform: "nintendo-super-nintendo-entertainment-system",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nintendo-super-nintendo-entertainment-system/Tetris Battle Gaiden (English) (With Bosses).sfc"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/a96114cdac6fe98ac4ea7c0fea7b2a99.png"
      ]
    }
  },
  {
    id: "49",
    name: "BS Zelda",
    platform: "nintendo-super-nintendo-entertainment-system",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/nintendo-super-nintendo-entertainment-system/bszelda_map1.smc"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/355d6abc729ce346ac5d0bed17a733a2.png"
      ]
    }
  },
  {
    id: "53",
    name: "Cool Spot",
    platform: "sega-genesis",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/sega-genesis/Cool Spot (USA).md"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/091079d1b3a9ba6ebd800051147f6010.png"
      ]
    }
  },
  {
    id: "54",
    name: "Kenseiden",
    platform: "sega-master-system",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/sega-master-system/Kenseiden.sms"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/5758161a08dfb5a06599011e0ba8306d.png"
      ]
    }
  },
  {
    id: "55",
    name: "Gauntlet 3",
    platform: "sinclair-zx-spectrum",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/sinclair-zx-spectrum/GAUNT3.TAP"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/a85f905b3a89ab55d6ce7288b8c37622.png"
      ]
    }
  },
  {
    id: "56",
    name: "The Great Escape",
    platform: "sinclair-zx-spectrum",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/sinclair-zx-spectrum/The Great Escape.tap"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/48cf059cac6627c121520d27aeedd56c.png"
      ]
    }
  },
  {
    id: "57",
    name: "Castlevania Simon's Quest",
    platform: "sinclair-zx-spectrum",
    resources: [
      {
        host: "yari",
        location: "/storage/F7EF-F81E/sleet/gaming/games/sinclair-zx-spectrum/castlevania_si_en.tap"
      }
    ],
    media: {
      grids: [
        "https://cdn2.steamgriddb.com/grid/751c6a9fbeb6cc3eeac48f915f109564.png"
      ]
    }
  }
];
addRxPlugin(RxDBDevModePlugin);
addRxPlugin(RxDBQueryBuilderPlugin);
const initialize = async () => {
  const db2 = await createRxDatabase({
    name: "qawsuaasxx",
    storage: getRxStorageDexie(),
    ignoreDuplicate: true
  });
  const collection = await db2.addCollections({
    releases: {
      statics: {
        pinnedBy(user, hosts) {
          return this.find({
            selector: {
              id: {
                $in: user.pins.releases
              },
              resources: {
                $elemMatch: {
                  host: {
                    $in: hosts
                  }
                }
              }
            }
          });
        }
      },
      schema: {
        title: "releases",
        version: 0,
        type: "object",
        primaryKey: "id",
        properties: {
          id: {
            type: "string",
            maxLength: 250
          },
          platform: {
            type: "string"
          },
          created_at: {
            type: "string",
            format: "date-time"
          },
          updated_at: {
            type: "string",
            format: "date-time"
          },
          version: {
            type: ["string", "null"]
          },
          release_date: {
            type: ["string", "null"],
            format: "date-time"
          },
          name: {
            type: "string"
          },
          media: {
            type: "object",
            properties: {
              posters: {
                type: "array",
                items: {
                  type: "string"
                }
              },
              grids: {
                type: "array",
                items: {
                  type: "string"
                }
              },
              logos: {
                type: "array",
                items: {
                  type: "string"
                }
              },
              heroes: {
                type: "array",
                items: {
                  type: "string"
                }
              },
              icons: {
                type: "array",
                items: {
                  type: "string"
                }
              }
            }
          },
          resources: {
            type: "array",
            items: {
              type: "object",
              properties: {
                host: {
                  type: "string"
                },
                location: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    users: {
      statics: {
        getDefaultUser() {
          return this.findOne({
            selector: {
              name: "Default User"
            }
          });
        }
      },
      schema: {
        title: "user",
        version: 0,
        type: "object",
        primaryKey: "id",
        properties: {
          id: {
            type: "string",
            maxLength: 250
          },
          name: {
            type: "string"
          },
          pins: {
            type: "object",
            properties: {
              releases: {
                type: "array",
                ref: "releases",
                items: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    }
  });
  await collection.users.bulkInsert(users);
  await collection.releases.bulkInsert(releases);
  return db2;
};
var dist$2 = {};
var context = {};
Object.defineProperty(context, "__esModule", { value: true });
var react_1$5 = reactExports;
var Context2 = (0, react_1$5.createContext)(null);
context.default = Context2;
var Provider$1 = {};
var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  var desc = Object.getOwnPropertyDescriptor(m2, k2);
  if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m2[k2];
    } };
  }
  Object.defineProperty(o, k22, desc);
} : function(o, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o[k22] = m2[k2];
});
var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v2) {
  Object.defineProperty(o, "default", { enumerable: true, value: v2 });
} : function(o, v2) {
  o["default"] = v2;
});
var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
        __createBinding(result, mod, k2);
  }
  __setModuleDefault(result, mod);
  return result;
};
var __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(Provider$1, "__esModule", { value: true });
var react_1$4 = __importStar(reactExports);
var context_1$1 = __importDefault$3(context);
var Provider = function(_a) {
  var db2 = _a.db, children = _a.children;
  var context2 = (0, react_1$4.useMemo)(function() {
    return {
      db: db2
    };
  }, [db2]);
  return react_1$4.default.createElement(context_1$1.default.Provider, { value: context2 }, children);
};
Provider$1.default = Provider;
var useRxCollection$1 = {};
var useRxDB$1 = {};
var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(useRxDB$1, "__esModule", { value: true });
var react_1$3 = reactExports;
var context_1 = __importDefault$2(context);
function useRxDB() {
  var db2 = (0, react_1$3.useContext)(context_1.default).db;
  return db2;
}
useRxDB$1.default = useRxDB;
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(useRxCollection$1, "__esModule", { value: true });
var react_1$2 = reactExports;
var useRxDB_1 = __importDefault$1(useRxDB$1);
function useRxCollection(name) {
  var _a = (0, react_1$2.useState)(null), collection = _a[0], setCollection = _a[1];
  var db2 = (0, useRxDB_1.default)();
  (0, react_1$2.useEffect)(function() {
    if (!db2) {
      return;
    }
    var found = db2[name];
    if (found) {
      setCollection(found);
    }
    if (db2.newCollections$) {
      var sub_1 = db2.newCollections$.subscribe(function(col) {
        if (col[name]) {
          setCollection(col[name]);
        }
      });
      return function() {
        sub_1.unsubscribe();
      };
    }
  }, [db2, name]);
  return collection;
}
useRxCollection$1.default = useRxCollection;
var useRxData$1 = {};
var useRxQuery$1 = {};
var helpers = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isRxQuery = exports.isObject = exports.getCancelablePromise = void 0;
  var getCancelablePromise = function(promise) {
    var hasCanceled = false;
    var wrappedPromise = new Promise(function(resolve2, reject) {
      promise.then(function(val) {
        if (!hasCanceled) {
          resolve2(val);
        }
      }, function(error) {
        if (!hasCanceled) {
          reject(error);
        }
      });
    });
    return [
      wrappedPromise,
      function() {
        hasCanceled = true;
      }
    ];
  };
  exports.getCancelablePromise = getCancelablePromise;
  var isObject2 = function(val) {
    return typeof val === "object" && val !== null;
  };
  exports.isObject = isObject2;
  var isRxQuery = function(val) {
    return (0, exports.isObject)(val) && "skip" in val && "limit" in val && "$" in val && (0, exports.isObject)(val.$) && "subscribe" in val.$ && typeof val.$.subscribe === "function";
  };
  exports.isRxQuery = isRxQuery;
})(helpers);
var __assign$3 = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign$3 = Object.assign || function(t2) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign$3.apply(this, arguments);
};
Object.defineProperty(useRxQuery$1, "__esModule", { value: true });
var react_1$1 = reactExports;
var helpers_1 = helpers;
var ActionType;
(function(ActionType2) {
  ActionType2[ActionType2["Reset"] = 0] = "Reset";
  ActionType2[ActionType2["FetchMore"] = 1] = "FetchMore";
  ActionType2[ActionType2["FetchPage"] = 2] = "FetchPage";
  ActionType2[ActionType2["FetchSuccess"] = 3] = "FetchSuccess";
  ActionType2[ActionType2["CountPages"] = 4] = "CountPages";
  ActionType2[ActionType2["QueryChanged"] = 5] = "QueryChanged";
})(ActionType || (ActionType = {}));
var reducer = function(state, action) {
  switch (action.type) {
    case ActionType.Reset:
      return __assign$3(__assign$3({}, state), { result: [], isFetching: true, page: 1 });
    case ActionType.FetchMore:
      return __assign$3(__assign$3({}, state), { isFetching: true, page: state.page + 1 });
    case ActionType.FetchPage:
      return __assign$3(__assign$3({}, state), { isFetching: true, page: action.page });
    case ActionType.CountPages:
      return __assign$3(__assign$3({}, state), { pageCount: action.pageCount });
    case ActionType.FetchSuccess:
      return __assign$3(__assign$3({}, state), { result: action.docs, isFetching: false, isExhausted: !action.pageSize ? true : action.pagination === "Infinite" ? action.docs.length < state.page * action.pageSize : false });
    case ActionType.QueryChanged:
      return __assign$3(__assign$3({}, state), { isFetching: true });
    default:
      return state;
  }
};
var getResultArray = function(result, json) {
  if (!result) {
    return [];
  }
  if (result instanceof Map) {
    return Array.from(result, function(_a) {
      var doc = _a[1];
      return json ? doc.toJSON() : doc;
    });
  }
  var resultArray = Array.isArray(result) ? result : [result];
  return json ? resultArray.map(function(doc) {
    return doc.toJSON();
  }) : resultArray;
};
var getResultLength = function(result) {
  var resultArray = Array.isArray(result) ? result : [result];
  return resultArray.length;
};
function useRxQuery(query, options) {
  if (options === void 0) {
    options = {};
  }
  var pageSize = options.pageSize, _a = options.pagination, pagination = _a === void 0 ? "Infinite" : _a, json = options.json;
  var initialState = {
    result: [],
    page: pageSize ? 1 : void 0,
    isFetching: true,
    isExhausted: false,
    pageCount: 0
  };
  var _b = (0, react_1$1.useReducer)(reducer, initialState), state = _b[0], dispatch = _b[1];
  var fetchPage = (0, react_1$1.useCallback)(function(page) {
    if (!pageSize || pagination !== "Traditional") {
      return;
    }
    if (page < 1 || page > state.pageCount) {
      return;
    }
    dispatch({ type: ActionType.FetchPage, page });
  }, [pageSize, pagination, state.pageCount]);
  var fetchMore = (0, react_1$1.useCallback)(function() {
    if (!pageSize || pagination !== "Infinite") {
      return;
    }
    if (state.isFetching || state.isExhausted) {
      return;
    }
    dispatch({ type: ActionType.FetchMore });
  }, [pageSize, pagination, state.isFetching, state.isExhausted]);
  var resetList = (0, react_1$1.useCallback)(function() {
    if (!pageSize) {
      return;
    }
    if (state.page === 1) {
      return;
    }
    dispatch({ type: ActionType.Reset });
  }, [pageSize, state.page]);
  var performQuery = (0, react_1$1.useCallback)(function(query2) {
    var _query = query2;
    if (pageSize && pagination === "Traditional") {
      _query = _query.skip((state.page - 1) * pageSize).limit(pageSize);
    }
    if (pageSize && pagination === "Infinite") {
      _query = _query.limit(state.page * pageSize);
    }
    dispatch({
      type: ActionType.QueryChanged
    });
    var sub = _query.$.subscribe(function(result) {
      var docs = getResultArray(result, json);
      dispatch({
        type: ActionType.FetchSuccess,
        docs,
        pagination,
        pageSize
      });
    });
    return function() {
      sub.unsubscribe();
    };
  }, [json, pageSize, pagination, state.page]);
  (0, react_1$1.useEffect)(function() {
    if (!query) {
      return;
    }
    if ((0, helpers_1.isRxQuery)(query)) {
      return performQuery(query);
    }
  }, [query, performQuery]);
  (0, react_1$1.useEffect)(function() {
    if (!query || !pageSize || pagination !== "Traditional" || "then" in query) {
      return;
    }
    if ((0, helpers_1.isRxQuery)(query)) {
      var countQuerySub_1 = query.$.subscribe(function(result) {
        var resultLength = getResultLength(result);
        dispatch({
          type: ActionType.CountPages,
          pageCount: Math.ceil(resultLength / pageSize)
        });
      });
      return function() {
        countQuerySub_1.unsubscribe();
      };
    }
  }, [query, pageSize, pagination]);
  return {
    result: state.result,
    isFetching: state.isFetching,
    isExhausted: state.isExhausted,
    pageCount: state.pageCount,
    currentPage: state.page,
    fetchPage,
    fetchMore,
    resetList
  };
}
useRxQuery$1.default = useRxQuery;
var __assign$2 = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign$2 = Object.assign || function(t2) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign$2.apply(this, arguments);
};
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(useRxData$1, "__esModule", { value: true });
var react_1 = reactExports;
var useRxCollection_1 = __importDefault(useRxCollection$1);
var useRxQuery_1 = __importDefault(useRxQuery$1);
function useRxData(collectionName, queryConstructor, options) {
  if (options === void 0) {
    options = {};
  }
  var collection = (0, useRxCollection_1.default)(collectionName);
  var query = (0, react_1.useMemo)(function() {
    if (!collection || typeof queryConstructor !== "function") {
      return null;
    }
    return queryConstructor(collection);
  }, [collection, queryConstructor]);
  return options.json ? (
    // eslint-disable-next-line react-hooks/rules-of-hooks
    (0, useRxQuery_1.default)(query, __assign$2(__assign$2({}, options), { json: true }))
  ) : (
    // eslint-disable-next-line react-hooks/rules-of-hooks
    (0, useRxQuery_1.default)(query, __assign$2(__assign$2({}, options), { json: false }))
  );
}
useRxData$1.default = useRxData;
var plugins = {};
var __awaiter$3 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$3 = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
Object.defineProperty(plugins, "__esModule", { value: true });
plugins.observeNewCollections = void 0;
var rxjs_1 = cjs;
plugins.observeNewCollections = {
  name: "new-collection-observer",
  rxdb: true,
  prototypes: {
    RxDatabase: function(proto) {
      var newCollections$ = new rxjs_1.Subject();
      proto.newCollections$ = newCollections$;
      var orig = proto.addCollections;
      proto.addCollections = function() {
        var args2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args2[_i] = arguments[_i];
        }
        return __awaiter$3(this, void 0, void 0, function() {
          var col;
          return __generator$3(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, orig.apply(this, args2)];
              case 1:
                col = _a.sent();
                newCollections$.next(col);
                return [2, col];
            }
          });
        });
      };
    }
  }
};
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding2(exports2, m2, p2);
  };
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.useRxQuery = exports.useRxDB = exports.useRxData = exports.useRxCollection = exports.Provider = exports.Context = void 0;
  var context_12 = context;
  Object.defineProperty(exports, "Context", { enumerable: true, get: function() {
    return __importDefault2(context_12).default;
  } });
  __exportStar(context, exports);
  var Provider_1 = Provider$1;
  Object.defineProperty(exports, "Provider", { enumerable: true, get: function() {
    return __importDefault2(Provider_1).default;
  } });
  __exportStar(Provider$1, exports);
  var useRxCollection_12 = useRxCollection$1;
  Object.defineProperty(exports, "useRxCollection", { enumerable: true, get: function() {
    return __importDefault2(useRxCollection_12).default;
  } });
  __exportStar(useRxCollection$1, exports);
  var useRxData_1 = useRxData$1;
  Object.defineProperty(exports, "useRxData", { enumerable: true, get: function() {
    return __importDefault2(useRxData_1).default;
  } });
  __exportStar(useRxData$1, exports);
  var useRxDB_12 = useRxDB$1;
  Object.defineProperty(exports, "useRxDB", { enumerable: true, get: function() {
    return __importDefault2(useRxDB_12).default;
  } });
  __exportStar(useRxDB$1, exports);
  var useRxQuery_12 = useRxQuery$1;
  Object.defineProperty(exports, "useRxQuery", { enumerable: true, get: function() {
    return __importDefault2(useRxQuery_12).default;
  } });
  __exportStar(useRxQuery$1, exports);
  __exportStar(plugins, exports);
})(dist$2);
var __assign$1 = function() {
  __assign$1 = Object.assign || function __assign2(t2) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign$1.apply(this, arguments);
};
function __spreadArray$1(to, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l2 = from2.length, ar; i < l2; i++) {
      if (ar || !(i in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i);
        ar[i] = from2[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";
var abs = Math.abs;
var from = String.fromCharCode;
var assign = Object.assign;
function hash(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search, position2) {
  return value.indexOf(search, position2);
}
function charat(value, index) {
  return value.charCodeAt(index) | 0;
}
function substr(value, begin, end) {
  return value.slice(begin, end);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}
function filter(array, pattern) {
  return array.filter(function(value) {
    return !match(value, pattern);
  });
}
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root, parent, type2, props, children, length2, siblings) {
  return { value, root, parent, type: type2, props, children, line, column, length: length2, return: "", siblings };
}
function copy(root, props) {
  return assign(node("", null, null, "", null, null, 0, root.siblings), root, { length: -root.length }, props);
}
function lift(root) {
  while (root.root)
    root = copy(root.root, { children: [root] });
  append(root, root.siblings);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end) {
  return substr(characters, begin, end);
}
function token(type2) {
  switch (type2) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type2) {
  return trim(slice(position - 1, delimiter(type2 === 91 ? type2 + 2 : type2 === 40 ? type2 + 1 : type2)));
}
function whitespace(type2) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type2) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index, count2) {
  while (--count2 && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index, caret() + (count2 < 6 && peek() == 32 && next() == 32));
}
function delimiter(type2) {
  while (next())
    switch (character) {
      case type2:
        return position;
      case 34:
      case 39:
        if (type2 !== 34 && type2 !== 39)
          delimiter(character);
        break;
      case 40:
        if (type2 === 41)
          delimiter(type2);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type2, index) {
  while (next())
    if (type2 + character === 47 + 10)
      break;
    else if (type2 + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index, position - 1) + "*" + from(type2 === 47 ? type2 : next());
}
function identifier(index) {
  while (!token(peek()))
    next();
  return slice(index, position);
}
function compile(value) {
  return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index = 0;
  var offset = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type2 = "";
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type2;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f", abs(index ? points[index - 1] : 0)) != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent, declarations), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset:
            if (ampersand == -1)
              characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1, declarations) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2, declarations), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference = ruleset(characters2, root, parent, index, offset, rules, points, type2, props = [], children = [], length2, rulesets), rulesets);
            if (character2 === 123)
              if (offset === 0)
                parse(characters2, root, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type2, rules, props = [], length2, children), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index = offset = property = 0, variable = ampersand = 1, type2 = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset = length2 = strlen(type2 = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root, parent, index, offset, rules, points, type2, props, children, length2, siblings) {
  var post = offset - 1;
  var rule = offset === 0 ? rules : [""];
  var size = sizeof(rule);
  for (var i = 0, j2 = 0, k2 = 0; i < index; ++i)
    for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j2 = points[i])), z2 = value; x2 < size; ++x2)
      if (z2 = trim(j2 > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
        props[k2++] = z2;
  return node(value, root, parent, offset === 0 ? RULESET : type2, props, children, length2, siblings);
}
function comment(value, root, parent, siblings) {
  return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0, siblings);
}
function declaration(value, root, parent, length2, siblings) {
  return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2, siblings);
}
function prefix(value, length2, children) {
  switch (hash(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 4789:
      return MOZ + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
    case 6828:
    case 4268:
    case 2903:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/g, "") + (!match(value, /flex-|baseline/) ? MS + "grid-row-" + replace(value, /flex-|-self/g, "") : "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/g, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4200:
      if (!match(value, /flex-|baseline/))
        return MS + "grid-column-align" + substr(value, length2) + value;
      break;
    case 2592:
    case 3360:
      return MS + replace(value, "template-", "") + value;
    case 4384:
    case 3616:
      if (children && children.some(function(element, index) {
        return length2 = index, match(element.props, /grid-\w+-end/);
      })) {
        return ~indexof(value + (children = children[length2].value), "span", 0) ? value : MS + replace(value, "-start", "") + value + MS + "grid-row-span:" + (~indexof(children, "span", 0) ? match(children, /\d+/) : +match(children, /\d+/) - +match(value, /\d+/)) + ";";
      }
      return MS + replace(value, "-start", "") + value;
    case 4896:
    case 4128:
      return children && children.some(function(element) {
        return match(element.props, /grid-\w+-start/);
      }) ? value : MS + replace(replace(value, "-end", "-span"), "span ", "") + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6)
        switch (charat(value, length2 + 1)) {
          case 109:
            if (charat(value, length2 + 4) !== 45)
              break;
          case 102:
            return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          case 115:
            return ~indexof(value, "stretch", 0) ? prefix(replace(value, "stretch", "fill-available"), length2, children) + value : value;
        }
      break;
    case 5152:
    case 5920:
      return replace(value, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function(_2, a, b2, c, d, e2, f2) {
        return MS + a + ":" + b2 + f2 + (c ? MS + a + "-span:" + (d ? e2 : +e2 - +b2) + f2 : "") + value;
      });
    case 4949:
      if (charat(value, length2 + 6) === 121)
        return replace(value, ":", ":" + WEBKIT) + value;
      break;
    case 6444:
      switch (charat(value, charat(value, 14) === 45 ? 18 : 11)) {
        case 120:
          return replace(value, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
        case 100:
          return replace(value, ":", ":" + MS) + value;
      }
      break;
    case 5719:
    case 2647:
    case 2135:
    case 3927:
    case 2391:
      return replace(value, "scroll-", "scroll-snap-") + value;
  }
  return value;
}
function serialize(children, callback) {
  var output = "";
  for (var i = 0; i < children.length; i++)
    output += callback(children[i], i, children, callback) || "";
  return output;
}
function stringify(element, index, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length)
        break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      if (!strlen(element.value = element.props.join(",")))
        return "";
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index, children, callback) {
    var output = "";
    for (var i = 0; i < length2; i++)
      output += collection[i](element, index, children, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
function prefixer(element, index, children, callback) {
  if (element.length > -1) {
    if (!element.return)
      switch (element.type) {
        case DECLARATION:
          element.return = prefix(element.value, element.length, children);
          return;
        case KEYFRAMES:
          return serialize([copy(element, { value: replace(element.value, "@", "@" + WEBKIT) })], callback);
        case RULESET:
          if (element.length)
            return combine(children = element.props, function(value) {
              switch (match(value, callback = /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  lift(copy(element, { props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")] }));
                  lift(copy(element, { props: [value] }));
                  assign(element, { props: filter(children, callback) });
                  break;
                case "::placeholder":
                  lift(copy(element, { props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")] }));
                  lift(copy(element, { props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")] }));
                  lift(copy(element, { props: [replace(value, /:(plac\w+)/, MS + "input-$1")] }));
                  lift(copy(element, { props: [value] }));
                  assign(element, { props: filter(children, callback) });
                  break;
              }
              return "";
            });
      }
  }
}
var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var define_process_env_default = {};
var f = "undefined" != typeof process && void 0 !== define_process_env_default && (define_process_env_default.REACT_APP_SC_ATTR || define_process_env_default.SC_ATTR) || "data-styled", m$1 = "active", y = "data-styled-version", v$1 = "6.1.6", g = "/*!sc*/\n", S = "undefined" != typeof window && "HTMLElement" in window, w$1 = Boolean("boolean" == typeof SC_DISABLE_SPEEDY ? SC_DISABLE_SPEEDY : "undefined" != typeof process && void 0 !== define_process_env_default && void 0 !== define_process_env_default.REACT_APP_SC_DISABLE_SPEEDY && "" !== define_process_env_default.REACT_APP_SC_DISABLE_SPEEDY ? "false" !== define_process_env_default.REACT_APP_SC_DISABLE_SPEEDY && define_process_env_default.REACT_APP_SC_DISABLE_SPEEDY : "undefined" != typeof process && void 0 !== define_process_env_default && void 0 !== define_process_env_default.SC_DISABLE_SPEEDY && "" !== define_process_env_default.SC_DISABLE_SPEEDY ? "false" !== define_process_env_default.SC_DISABLE_SPEEDY && define_process_env_default.SC_DISABLE_SPEEDY : false), b = {}, _ = Object.freeze([]), C = Object.freeze({});
function I(e2, t2, n2) {
  return void 0 === n2 && (n2 = C), e2.theme !== n2.theme && e2.theme || t2 || n2.theme;
}
var A = /* @__PURE__ */ new Set(["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "u", "ul", "use", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"]), O = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g, D = /(^-|-$)/g;
function R(e2) {
  return e2.replace(O, "-").replace(D, "");
}
var T = /(a)(d)/gi, k$1 = 52, j = function(e2) {
  return String.fromCharCode(e2 + (e2 > 25 ? 39 : 97));
};
function x(e2) {
  var t2, n2 = "";
  for (t2 = Math.abs(e2); t2 > k$1; t2 = t2 / k$1 | 0)
    n2 = j(t2 % k$1) + n2;
  return (j(t2 % k$1) + n2).replace(T, "$1-$2");
}
var V, F = 5381, M = function(e2, t2) {
  for (var n2 = t2.length; n2; )
    e2 = 33 * e2 ^ t2.charCodeAt(--n2);
  return e2;
}, $ = function(e2) {
  return M(F, e2);
};
function z(e2) {
  return x($(e2) >>> 0);
}
function B(e2) {
  return e2.displayName || e2.name || "Component";
}
function L(e2) {
  return "string" == typeof e2 && true;
}
var G = "function" == typeof Symbol && Symbol.for, Y = G ? Symbol.for("react.memo") : 60115, W = G ? Symbol.for("react.forward_ref") : 60112, q$2 = { childContextTypes: true, contextType: true, contextTypes: true, defaultProps: true, displayName: true, getDefaultProps: true, getDerivedStateFromError: true, getDerivedStateFromProps: true, mixins: true, propTypes: true, type: true }, H = { name: true, length: true, prototype: true, caller: true, callee: true, arguments: true, arity: true }, U = { $$typeof: true, compare: true, defaultProps: true, displayName: true, propTypes: true, type: true }, J = ((V = {})[W] = { $$typeof: true, render: true, defaultProps: true, displayName: true, propTypes: true }, V[Y] = U, V);
function X(e2) {
  return ("type" in (t2 = e2) && t2.type.$$typeof) === Y ? U : "$$typeof" in e2 ? J[e2.$$typeof] : q$2;
  var t2;
}
var Z = Object.defineProperty, K = Object.getOwnPropertyNames, Q = Object.getOwnPropertySymbols, ee = Object.getOwnPropertyDescriptor, te = Object.getPrototypeOf, ne = Object.prototype;
function oe(e2, t2, n2) {
  if ("string" != typeof t2) {
    if (ne) {
      var o2 = te(t2);
      o2 && o2 !== ne && oe(e2, o2, n2);
    }
    var r2 = K(t2);
    Q && (r2 = r2.concat(Q(t2)));
    for (var s2 = X(e2), i2 = X(t2), a2 = 0; a2 < r2.length; ++a2) {
      var c2 = r2[a2];
      if (!(c2 in H || n2 && n2[c2] || i2 && c2 in i2 || s2 && c2 in s2)) {
        var l2 = ee(t2, c2);
        try {
          Z(e2, c2, l2);
        } catch (e3) {
        }
      }
    }
  }
  return e2;
}
function re(e2) {
  return "function" == typeof e2;
}
function se(e2) {
  return "object" == typeof e2 && "styledComponentId" in e2;
}
function ie(e2, t2) {
  return e2 && t2 ? "".concat(e2, " ").concat(t2) : e2 || t2 || "";
}
function ae(e2, t2) {
  if (0 === e2.length)
    return "";
  for (var n2 = e2[0], o2 = 1; o2 < e2.length; o2++)
    n2 += t2 ? t2 + e2[o2] : e2[o2];
  return n2;
}
function ce(e2) {
  return null !== e2 && "object" == typeof e2 && e2.constructor.name === Object.name && !("props" in e2 && e2.$$typeof);
}
function le(e2, t2, n2) {
  if (void 0 === n2 && (n2 = false), !n2 && !ce(e2) && !Array.isArray(e2))
    return t2;
  if (Array.isArray(t2))
    for (var o2 = 0; o2 < t2.length; o2++)
      e2[o2] = le(e2[o2], t2[o2]);
  else if (ce(t2))
    for (var o2 in t2)
      e2[o2] = le(e2[o2], t2[o2]);
  return e2;
}
function ue(e2, t2) {
  Object.defineProperty(e2, "toString", { value: t2 });
}
function he(t2) {
  for (var n2 = [], o2 = 1; o2 < arguments.length; o2++)
    n2[o2 - 1] = arguments[o2];
  return new Error("An error occurred. See https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#".concat(t2, " for more information.").concat(n2.length > 0 ? " Args: ".concat(n2.join(", ")) : ""));
}
var fe = function() {
  function e2(e3) {
    this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = e3;
  }
  return e2.prototype.indexOfGroup = function(e3) {
    for (var t2 = 0, n2 = 0; n2 < e3; n2++)
      t2 += this.groupSizes[n2];
    return t2;
  }, e2.prototype.insertRules = function(e3, t2) {
    if (e3 >= this.groupSizes.length) {
      for (var n2 = this.groupSizes, o2 = n2.length, r2 = o2; e3 >= r2; )
        if ((r2 <<= 1) < 0)
          throw he(16, "".concat(e3));
      this.groupSizes = new Uint32Array(r2), this.groupSizes.set(n2), this.length = r2;
      for (var s2 = o2; s2 < r2; s2++)
        this.groupSizes[s2] = 0;
    }
    for (var i2 = this.indexOfGroup(e3 + 1), a2 = (s2 = 0, t2.length); s2 < a2; s2++)
      this.tag.insertRule(i2, t2[s2]) && (this.groupSizes[e3]++, i2++);
  }, e2.prototype.clearGroup = function(e3) {
    if (e3 < this.length) {
      var t2 = this.groupSizes[e3], n2 = this.indexOfGroup(e3), o2 = n2 + t2;
      this.groupSizes[e3] = 0;
      for (var r2 = n2; r2 < o2; r2++)
        this.tag.deleteRule(n2);
    }
  }, e2.prototype.getGroup = function(e3) {
    var t2 = "";
    if (e3 >= this.length || 0 === this.groupSizes[e3])
      return t2;
    for (var n2 = this.groupSizes[e3], o2 = this.indexOfGroup(e3), r2 = o2 + n2, s2 = o2; s2 < r2; s2++)
      t2 += "".concat(this.tag.getRule(s2)).concat(g);
    return t2;
  }, e2;
}(), me = /* @__PURE__ */ new Map(), ye = /* @__PURE__ */ new Map(), ve = 1, ge = function(e2) {
  if (me.has(e2))
    return me.get(e2);
  for (; ye.has(ve); )
    ve++;
  var t2 = ve++;
  return me.set(e2, t2), ye.set(t2, e2), t2;
}, Se = function(e2, t2) {
  ve = t2 + 1, me.set(e2, t2), ye.set(t2, e2);
}, we = "style[".concat(f, "][").concat(y, '="').concat(v$1, '"]'), be = new RegExp("^".concat(f, '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)')), Ee = function(e2, t2, n2) {
  for (var o2, r2 = n2.split(","), s2 = 0, i2 = r2.length; s2 < i2; s2++)
    (o2 = r2[s2]) && e2.registerName(t2, o2);
}, Ne = function(e2, t2) {
  for (var n2, o2 = (null !== (n2 = t2.textContent) && void 0 !== n2 ? n2 : "").split(g), r2 = [], s2 = 0, i2 = o2.length; s2 < i2; s2++) {
    var a2 = o2[s2].trim();
    if (a2) {
      var c2 = a2.match(be);
      if (c2) {
        var l2 = 0 | parseInt(c2[1], 10), u2 = c2[2];
        0 !== l2 && (Se(u2, l2), Ee(e2, u2, c2[3]), e2.getTag().insertRules(l2, r2)), r2.length = 0;
      } else
        r2.push(a2);
    }
  }
};
function Pe() {
  return "undefined" != typeof __webpack_nonce__ ? __webpack_nonce__ : null;
}
var _e = function(e2) {
  var t2 = document.head, n2 = e2 || t2, o2 = document.createElement("style"), r2 = function(e3) {
    var t3 = Array.from(e3.querySelectorAll("style[".concat(f, "]")));
    return t3[t3.length - 1];
  }(n2), s2 = void 0 !== r2 ? r2.nextSibling : null;
  o2.setAttribute(f, m$1), o2.setAttribute(y, v$1);
  var i2 = Pe();
  return i2 && o2.setAttribute("nonce", i2), n2.insertBefore(o2, s2), o2;
}, Ce = function() {
  function e2(e3) {
    this.element = _e(e3), this.element.appendChild(document.createTextNode("")), this.sheet = function(e4) {
      if (e4.sheet)
        return e4.sheet;
      for (var t2 = document.styleSheets, n2 = 0, o2 = t2.length; n2 < o2; n2++) {
        var r2 = t2[n2];
        if (r2.ownerNode === e4)
          return r2;
      }
      throw he(17);
    }(this.element), this.length = 0;
  }
  return e2.prototype.insertRule = function(e3, t2) {
    try {
      return this.sheet.insertRule(t2, e3), this.length++, true;
    } catch (e4) {
      return false;
    }
  }, e2.prototype.deleteRule = function(e3) {
    this.sheet.deleteRule(e3), this.length--;
  }, e2.prototype.getRule = function(e3) {
    var t2 = this.sheet.cssRules[e3];
    return t2 && t2.cssText ? t2.cssText : "";
  }, e2;
}(), Ie = function() {
  function e2(e3) {
    this.element = _e(e3), this.nodes = this.element.childNodes, this.length = 0;
  }
  return e2.prototype.insertRule = function(e3, t2) {
    if (e3 <= this.length && e3 >= 0) {
      var n2 = document.createTextNode(t2);
      return this.element.insertBefore(n2, this.nodes[e3] || null), this.length++, true;
    }
    return false;
  }, e2.prototype.deleteRule = function(e3) {
    this.element.removeChild(this.nodes[e3]), this.length--;
  }, e2.prototype.getRule = function(e3) {
    return e3 < this.length ? this.nodes[e3].textContent : "";
  }, e2;
}(), Ae = function() {
  function e2(e3) {
    this.rules = [], this.length = 0;
  }
  return e2.prototype.insertRule = function(e3, t2) {
    return e3 <= this.length && (this.rules.splice(e3, 0, t2), this.length++, true);
  }, e2.prototype.deleteRule = function(e3) {
    this.rules.splice(e3, 1), this.length--;
  }, e2.prototype.getRule = function(e3) {
    return e3 < this.length ? this.rules[e3] : "";
  }, e2;
}(), Oe = S, De = { isServer: !S, useCSSOMInjection: !w$1 }, Re = function() {
  function e2(e3, n2, o2) {
    void 0 === e3 && (e3 = C), void 0 === n2 && (n2 = {});
    var r2 = this;
    this.options = __assign$1(__assign$1({}, De), e3), this.gs = n2, this.names = new Map(o2), this.server = !!e3.isServer, !this.server && S && Oe && (Oe = false, function(e4) {
      for (var t2 = document.querySelectorAll(we), n3 = 0, o3 = t2.length; n3 < o3; n3++) {
        var r3 = t2[n3];
        r3 && r3.getAttribute(f) !== m$1 && (Ne(e4, r3), r3.parentNode && r3.parentNode.removeChild(r3));
      }
    }(this)), ue(this, function() {
      return function(e4) {
        for (var t2 = e4.getTag(), n3 = t2.length, o3 = "", r3 = function(n4) {
          var r4 = function(e5) {
            return ye.get(e5);
          }(n4);
          if (void 0 === r4)
            return "continue";
          var s3 = e4.names.get(r4), i2 = t2.getGroup(n4);
          if (void 0 === s3 || 0 === i2.length)
            return "continue";
          var a2 = "".concat(f, ".g").concat(n4, '[id="').concat(r4, '"]'), c2 = "";
          void 0 !== s3 && s3.forEach(function(e5) {
            e5.length > 0 && (c2 += "".concat(e5, ","));
          }), o3 += "".concat(i2).concat(a2, '{content:"').concat(c2, '"}').concat(g);
        }, s2 = 0; s2 < n3; s2++)
          r3(s2);
        return o3;
      }(r2);
    });
  }
  return e2.registerId = function(e3) {
    return ge(e3);
  }, e2.prototype.reconstructWithOptions = function(n2, o2) {
    return void 0 === o2 && (o2 = true), new e2(__assign$1(__assign$1({}, this.options), n2), this.gs, o2 && this.names || void 0);
  }, e2.prototype.allocateGSInstance = function(e3) {
    return this.gs[e3] = (this.gs[e3] || 0) + 1;
  }, e2.prototype.getTag = function() {
    return this.tag || (this.tag = (e3 = function(e4) {
      var t2 = e4.useCSSOMInjection, n2 = e4.target;
      return e4.isServer ? new Ae(n2) : t2 ? new Ce(n2) : new Ie(n2);
    }(this.options), new fe(e3)));
    var e3;
  }, e2.prototype.hasNameForId = function(e3, t2) {
    return this.names.has(e3) && this.names.get(e3).has(t2);
  }, e2.prototype.registerName = function(e3, t2) {
    if (ge(e3), this.names.has(e3))
      this.names.get(e3).add(t2);
    else {
      var n2 = /* @__PURE__ */ new Set();
      n2.add(t2), this.names.set(e3, n2);
    }
  }, e2.prototype.insertRules = function(e3, t2, n2) {
    this.registerName(e3, t2), this.getTag().insertRules(ge(e3), n2);
  }, e2.prototype.clearNames = function(e3) {
    this.names.has(e3) && this.names.get(e3).clear();
  }, e2.prototype.clearRules = function(e3) {
    this.getTag().clearGroup(ge(e3)), this.clearNames(e3);
  }, e2.prototype.clearTag = function() {
    this.tag = void 0;
  }, e2;
}(), Te = /&/g, ke = /^\s*\/\/.*$/gm;
function je(e2, t2) {
  return e2.map(function(e3) {
    return "rule" === e3.type && (e3.value = "".concat(t2, " ").concat(e3.value), e3.value = e3.value.replaceAll(",", ",".concat(t2, " ")), e3.props = e3.props.map(function(e4) {
      return "".concat(t2, " ").concat(e4);
    })), Array.isArray(e3.children) && "@keyframes" !== e3.type && (e3.children = je(e3.children, t2)), e3;
  });
}
function xe(e2) {
  var t2, n2, o2, r2 = void 0 === e2 ? C : e2, s2 = r2.options, i2 = void 0 === s2 ? C : s2, a2 = r2.plugins, c2 = void 0 === a2 ? _ : a2, l2 = function(e3, o3, r3) {
    return r3.startsWith(n2) && r3.endsWith(n2) && r3.replaceAll(n2, "").length > 0 ? ".".concat(t2) : e3;
  }, u2 = c2.slice();
  u2.push(function(e3) {
    e3.type === RULESET && e3.value.includes("&") && (e3.props[0] = e3.props[0].replace(Te, n2).replace(o2, l2));
  }), i2.prefix && u2.push(prefixer), u2.push(stringify);
  var p2 = function(e3, r3, s3, a3) {
    void 0 === r3 && (r3 = ""), void 0 === s3 && (s3 = ""), void 0 === a3 && (a3 = "&"), t2 = a3, n2 = r3, o2 = new RegExp("\\".concat(n2, "\\b"), "g");
    var c3 = e3.replace(ke, ""), l3 = compile(s3 || r3 ? "".concat(s3, " ").concat(r3, " { ").concat(c3, " }") : c3);
    i2.namespace && (l3 = je(l3, i2.namespace));
    var p3 = [];
    return serialize(l3, middleware(u2.concat(rulesheet(function(e4) {
      return p3.push(e4);
    })))), p3;
  };
  return p2.hash = c2.length ? c2.reduce(function(e3, t3) {
    return t3.name || he(15), M(e3, t3.name);
  }, F).toString() : "", p2;
}
var Ve = new Re(), Fe = xe(), Me = React.createContext({ shouldForwardProp: void 0, styleSheet: Ve, stylis: Fe });
Me.Consumer;
React.createContext(void 0);
function Be() {
  return reactExports.useContext(Me);
}
var Ge = function() {
  function e2(e3, t2) {
    var n2 = this;
    this.inject = function(e4, t3) {
      void 0 === t3 && (t3 = Fe);
      var o2 = n2.name + t3.hash;
      e4.hasNameForId(n2.id, o2) || e4.insertRules(n2.id, o2, t3(n2.rules, o2, "@keyframes"));
    }, this.name = e3, this.id = "sc-keyframes-".concat(e3), this.rules = t2, ue(this, function() {
      throw he(12, String(n2.name));
    });
  }
  return e2.prototype.getName = function(e3) {
    return void 0 === e3 && (e3 = Fe), this.name + e3.hash;
  }, e2;
}(), Ye = function(e2) {
  return e2 >= "A" && e2 <= "Z";
};
function We(e2) {
  for (var t2 = "", n2 = 0; n2 < e2.length; n2++) {
    var o2 = e2[n2];
    if (1 === n2 && "-" === o2 && "-" === e2[0])
      return e2;
    Ye(o2) ? t2 += "-" + o2.toLowerCase() : t2 += o2;
  }
  return t2.startsWith("ms-") ? "-" + t2 : t2;
}
var qe = function(e2) {
  return null == e2 || false === e2 || "" === e2;
}, He = function(t2) {
  var n2, o2, r2 = [];
  for (var s2 in t2) {
    var i2 = t2[s2];
    t2.hasOwnProperty(s2) && !qe(i2) && (Array.isArray(i2) && i2.isCss || re(i2) ? r2.push("".concat(We(s2), ":"), i2, ";") : ce(i2) ? r2.push.apply(r2, __spreadArray$1(__spreadArray$1(["".concat(s2, " {")], He(i2), false), ["}"], false)) : r2.push("".concat(We(s2), ": ").concat((n2 = s2, null == (o2 = i2) || "boolean" == typeof o2 || "" === o2 ? "" : "number" != typeof o2 || 0 === o2 || n2 in unitlessKeys || n2.startsWith("--") ? String(o2).trim() : "".concat(o2, "px")), ";")));
  }
  return r2;
};
function Ue(e2, t2, n2, o2) {
  if (qe(e2))
    return [];
  if (se(e2))
    return [".".concat(e2.styledComponentId)];
  if (re(e2)) {
    if (!re(s2 = e2) || s2.prototype && s2.prototype.isReactComponent || !t2)
      return [e2];
    var r2 = e2(t2);
    return Ue(r2, t2, n2, o2);
  }
  var s2;
  return e2 instanceof Ge ? n2 ? (e2.inject(n2, o2), [e2.getName(o2)]) : [e2] : ce(e2) ? He(e2) : Array.isArray(e2) ? Array.prototype.concat.apply(_, e2.map(function(e3) {
    return Ue(e3, t2, n2, o2);
  })) : [e2.toString()];
}
function Je(e2) {
  for (var t2 = 0; t2 < e2.length; t2 += 1) {
    var n2 = e2[t2];
    if (re(n2) && !se(n2))
      return false;
  }
  return true;
}
var Xe = $(v$1), Ze = function() {
  function e2(e3, t2, n2) {
    this.rules = e3, this.staticRulesId = "", this.isStatic = (void 0 === n2 || n2.isStatic) && Je(e3), this.componentId = t2, this.baseHash = M(Xe, t2), this.baseStyle = n2, Re.registerId(t2);
  }
  return e2.prototype.generateAndInjectStyles = function(e3, t2, n2) {
    var o2 = this.baseStyle ? this.baseStyle.generateAndInjectStyles(e3, t2, n2) : "";
    if (this.isStatic && !n2.hash)
      if (this.staticRulesId && t2.hasNameForId(this.componentId, this.staticRulesId))
        o2 = ie(o2, this.staticRulesId);
      else {
        var r2 = ae(Ue(this.rules, e3, t2, n2)), s2 = x(M(this.baseHash, r2) >>> 0);
        if (!t2.hasNameForId(this.componentId, s2)) {
          var i2 = n2(r2, ".".concat(s2), void 0, this.componentId);
          t2.insertRules(this.componentId, s2, i2);
        }
        o2 = ie(o2, s2), this.staticRulesId = s2;
      }
    else {
      for (var a2 = M(this.baseHash, n2.hash), c2 = "", l2 = 0; l2 < this.rules.length; l2++) {
        var u2 = this.rules[l2];
        if ("string" == typeof u2)
          c2 += u2;
        else if (u2) {
          var p2 = ae(Ue(u2, e3, t2, n2));
          a2 = M(a2, p2 + l2), c2 += p2;
        }
      }
      if (c2) {
        var d2 = x(a2 >>> 0);
        t2.hasNameForId(this.componentId, d2) || t2.insertRules(this.componentId, d2, n2(c2, ".".concat(d2), void 0, this.componentId)), o2 = ie(o2, d2);
      }
    }
    return o2;
  }, e2;
}(), Ke = React.createContext(void 0);
Ke.Consumer;
var nt = {};
function rt(e2, r2, s2) {
  var i2 = se(e2), a2 = e2, c2 = !L(e2), p2 = r2.attrs, d2 = void 0 === p2 ? _ : p2, h2 = r2.componentId, f2 = void 0 === h2 ? function(e3, t2) {
    var n2 = "string" != typeof e3 ? "sc" : R(e3);
    nt[n2] = (nt[n2] || 0) + 1;
    var o2 = "".concat(n2, "-").concat(z(v$1 + n2 + nt[n2]));
    return t2 ? "".concat(t2, "-").concat(o2) : o2;
  }(r2.displayName, r2.parentComponentId) : h2, m2 = r2.displayName, y2 = void 0 === m2 ? function(e3) {
    return L(e3) ? "styled.".concat(e3) : "Styled(".concat(B(e3), ")");
  }(e2) : m2, g2 = r2.displayName && r2.componentId ? "".concat(R(r2.displayName), "-").concat(r2.componentId) : r2.componentId || f2, S2 = i2 && a2.attrs ? a2.attrs.concat(d2).filter(Boolean) : d2, w2 = r2.shouldForwardProp;
  if (i2 && a2.shouldForwardProp) {
    var b2 = a2.shouldForwardProp;
    if (r2.shouldForwardProp) {
      var E2 = r2.shouldForwardProp;
      w2 = function(e3, t2) {
        return b2(e3, t2) && E2(e3, t2);
      };
    } else
      w2 = b2;
  }
  var N2 = new Ze(s2, g2, i2 ? a2.componentStyle : void 0);
  function O2(e3, r3) {
    return function(e4, r4, s3) {
      var i3 = e4.attrs, a3 = e4.componentStyle, c3 = e4.defaultProps, p3 = e4.foldedComponentIds, d3 = e4.styledComponentId, h3 = e4.target, f3 = React.useContext(Ke), m3 = Be(), y3 = e4.shouldForwardProp || m3.shouldForwardProp;
      var v2 = I(r4, f3, c3) || C, g3 = function(e5, n2, o2) {
        for (var r5, s4 = __assign$1(__assign$1({}, n2), { className: void 0, theme: o2 }), i4 = 0; i4 < e5.length; i4 += 1) {
          var a4 = re(r5 = e5[i4]) ? r5(s4) : r5;
          for (var c4 in a4)
            s4[c4] = "className" === c4 ? ie(s4[c4], a4[c4]) : "style" === c4 ? __assign$1(__assign$1({}, s4[c4]), a4[c4]) : a4[c4];
        }
        return n2.className && (s4.className = ie(s4.className, n2.className)), s4;
      }(i3, r4, v2), S3 = g3.as || h3, w3 = {};
      for (var b3 in g3)
        void 0 === g3[b3] || "$" === b3[0] || "as" === b3 || "theme" === b3 && g3.theme === v2 || ("forwardedAs" === b3 ? w3.as = g3.forwardedAs : y3 && !y3(b3, S3) || (w3[b3] = g3[b3], y3 || true));
      var E3 = function(e5, t2) {
        var n2 = Be(), o2 = e5.generateAndInjectStyles(t2, n2.styleSheet, n2.stylis);
        return o2;
      }(a3, g3);
      var N3 = ie(p3, d3);
      return E3 && (N3 += " " + E3), g3.className && (N3 += " " + g3.className), w3[L(S3) && !A.has(S3) ? "class" : "className"] = N3, w3.ref = s3, reactExports.createElement(S3, w3);
    }(D2, e3, r3);
  }
  O2.displayName = y2;
  var D2 = React.forwardRef(O2);
  return D2.attrs = S2, D2.componentStyle = N2, D2.displayName = y2, D2.shouldForwardProp = w2, D2.foldedComponentIds = i2 ? ie(a2.foldedComponentIds, a2.styledComponentId) : "", D2.styledComponentId = g2, D2.target = i2 ? a2.target : e2, Object.defineProperty(D2, "defaultProps", { get: function() {
    return this._foldedDefaultProps;
  }, set: function(e3) {
    this._foldedDefaultProps = i2 ? function(e4) {
      for (var t2 = [], n2 = 1; n2 < arguments.length; n2++)
        t2[n2 - 1] = arguments[n2];
      for (var o2 = 0, r3 = t2; o2 < r3.length; o2++)
        le(e4, r3[o2], true);
      return e4;
    }({}, a2.defaultProps, e3) : e3;
  } }), ue(D2, function() {
    return ".".concat(D2.styledComponentId);
  }), c2 && oe(D2, e2, { attrs: true, componentStyle: true, displayName: true, foldedComponentIds: true, shouldForwardProp: true, styledComponentId: true, target: true }), D2;
}
function st(e2, t2) {
  for (var n2 = [e2[0]], o2 = 0, r2 = t2.length; o2 < r2; o2 += 1)
    n2.push(t2[o2], e2[o2 + 1]);
  return n2;
}
var it = function(e2) {
  return Object.assign(e2, { isCss: true });
};
function at(t2) {
  for (var n2 = [], o2 = 1; o2 < arguments.length; o2++)
    n2[o2 - 1] = arguments[o2];
  if (re(t2) || ce(t2))
    return it(Ue(st(_, __spreadArray$1([t2], n2, true))));
  var r2 = t2;
  return 0 === n2.length && 1 === r2.length && "string" == typeof r2[0] ? Ue(r2) : it(Ue(st(r2, n2)));
}
function ct(n2, o2, r2) {
  if (void 0 === r2 && (r2 = C), !o2)
    throw he(1, o2);
  var s2 = function(t2) {
    for (var s3 = [], i2 = 1; i2 < arguments.length; i2++)
      s3[i2 - 1] = arguments[i2];
    return n2(o2, r2, at.apply(void 0, __spreadArray$1([t2], s3, false)));
  };
  return s2.attrs = function(e2) {
    return ct(n2, o2, __assign$1(__assign$1({}, r2), { attrs: Array.prototype.concat(r2.attrs, e2).filter(Boolean) }));
  }, s2.withConfig = function(e2) {
    return ct(n2, o2, __assign$1(__assign$1({}, r2), e2));
  }, s2;
}
var lt = function(e2) {
  return ct(rt, e2);
}, ut = lt;
A.forEach(function(e2) {
  ut[e2] = lt(e2);
});
var pt = function() {
  function e2(e3, t2) {
    this.rules = e3, this.componentId = t2, this.isStatic = Je(e3), Re.registerId(this.componentId + 1);
  }
  return e2.prototype.createStyles = function(e3, t2, n2, o2) {
    var r2 = o2(ae(Ue(this.rules, t2, n2, o2)), ""), s2 = this.componentId + e3;
    n2.insertRules(s2, s2, r2);
  }, e2.prototype.removeStyles = function(e3, t2) {
    t2.clearRules(this.componentId + e3);
  }, e2.prototype.renderStyles = function(e3, t2, n2, o2) {
    e3 > 2 && Re.registerId(this.componentId + e3), this.removeStyles(e3, n2), this.createStyles(e3, t2, n2, o2);
  }, e2;
}();
function dt(n2) {
  for (var r2 = [], s2 = 1; s2 < arguments.length; s2++)
    r2[s2 - 1] = arguments[s2];
  var i2 = at.apply(void 0, __spreadArray$1([n2], r2, false)), a2 = "sc-global-".concat(z(JSON.stringify(i2))), c2 = new pt(i2, a2);
  var l2 = function(e2) {
    var t2 = Be(), n3 = React.useContext(Ke), r3 = React.useRef(t2.styleSheet.allocateGSInstance(a2)).current;
    return t2.styleSheet.server && u2(r3, e2, t2.styleSheet, n3, t2.stylis), React.useLayoutEffect(function() {
      if (!t2.styleSheet.server)
        return u2(r3, e2, t2.styleSheet, n3, t2.stylis), function() {
          return c2.removeStyles(r3, t2.styleSheet);
        };
    }, [r3, e2, t2.styleSheet, n3, t2.stylis]), null;
  };
  function u2(e2, n3, o2, r3, s3) {
    if (c2.isStatic)
      c2.renderStyles(e2, b, o2, s3);
    else {
      var i3 = __assign$1(__assign$1({}, n3), { theme: I(n3, r3, l2.defaultProps) });
      c2.renderStyles(e2, i3, o2, s3);
    }
  }
  return React.memo(l2);
}
var dist$1 = { exports: {} };
var isObject_1;
var hasRequiredIsObject;
function requireIsObject() {
  if (hasRequiredIsObject)
    return isObject_1;
  hasRequiredIsObject = 1;
  function isObject2(value) {
    var type2 = typeof value;
    return value != null && (type2 == "object" || type2 == "function");
  }
  isObject_1 = isObject2;
  return isObject_1;
}
var _freeGlobal;
var hasRequired_freeGlobal;
function require_freeGlobal() {
  if (hasRequired_freeGlobal)
    return _freeGlobal;
  hasRequired_freeGlobal = 1;
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  _freeGlobal = freeGlobal;
  return _freeGlobal;
}
var _root;
var hasRequired_root;
function require_root() {
  if (hasRequired_root)
    return _root;
  hasRequired_root = 1;
  var freeGlobal = require_freeGlobal();
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  _root = root;
  return _root;
}
var now_1;
var hasRequiredNow;
function requireNow() {
  if (hasRequiredNow)
    return now_1;
  hasRequiredNow = 1;
  var root = require_root();
  var now2 = function() {
    return root.Date.now();
  };
  now_1 = now2;
  return now_1;
}
var _trimmedEndIndex;
var hasRequired_trimmedEndIndex;
function require_trimmedEndIndex() {
  if (hasRequired_trimmedEndIndex)
    return _trimmedEndIndex;
  hasRequired_trimmedEndIndex = 1;
  var reWhitespace = /\s/;
  function trimmedEndIndex(string) {
    var index = string.length;
    while (index-- && reWhitespace.test(string.charAt(index))) {
    }
    return index;
  }
  _trimmedEndIndex = trimmedEndIndex;
  return _trimmedEndIndex;
}
var _baseTrim;
var hasRequired_baseTrim;
function require_baseTrim() {
  if (hasRequired_baseTrim)
    return _baseTrim;
  hasRequired_baseTrim = 1;
  var trimmedEndIndex = require_trimmedEndIndex();
  var reTrimStart = /^\s+/;
  function baseTrim(string) {
    return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
  }
  _baseTrim = baseTrim;
  return _baseTrim;
}
var _Symbol;
var hasRequired_Symbol;
function require_Symbol() {
  if (hasRequired_Symbol)
    return _Symbol;
  hasRequired_Symbol = 1;
  var root = require_root();
  var Symbol2 = root.Symbol;
  _Symbol = Symbol2;
  return _Symbol;
}
var _getRawTag;
var hasRequired_getRawTag;
function require_getRawTag() {
  if (hasRequired_getRawTag)
    return _getRawTag;
  hasRequired_getRawTag = 1;
  var Symbol2 = require_Symbol();
  var objectProto2 = Object.prototype;
  var hasOwnProperty = objectProto2.hasOwnProperty;
  var nativeObjectToString = objectProto2.toString;
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e2) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  _getRawTag = getRawTag;
  return _getRawTag;
}
var _objectToString;
var hasRequired_objectToString;
function require_objectToString() {
  if (hasRequired_objectToString)
    return _objectToString;
  hasRequired_objectToString = 1;
  var objectProto2 = Object.prototype;
  var nativeObjectToString = objectProto2.toString;
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  _objectToString = objectToString;
  return _objectToString;
}
var _baseGetTag;
var hasRequired_baseGetTag;
function require_baseGetTag() {
  if (hasRequired_baseGetTag)
    return _baseGetTag;
  hasRequired_baseGetTag = 1;
  var Symbol2 = require_Symbol(), getRawTag = require_getRawTag(), objectToString = require_objectToString();
  var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  _baseGetTag = baseGetTag;
  return _baseGetTag;
}
var isObjectLike_1;
var hasRequiredIsObjectLike;
function requireIsObjectLike() {
  if (hasRequiredIsObjectLike)
    return isObjectLike_1;
  hasRequiredIsObjectLike = 1;
  function isObjectLike2(value) {
    return value != null && typeof value == "object";
  }
  isObjectLike_1 = isObjectLike2;
  return isObjectLike_1;
}
var isSymbol_1;
var hasRequiredIsSymbol;
function requireIsSymbol() {
  if (hasRequiredIsSymbol)
    return isSymbol_1;
  hasRequiredIsSymbol = 1;
  var baseGetTag = require_baseGetTag(), isObjectLike2 = requireIsObjectLike();
  var symbolTag = "[object Symbol]";
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike2(value) && baseGetTag(value) == symbolTag;
  }
  isSymbol_1 = isSymbol;
  return isSymbol_1;
}
var toNumber_1;
var hasRequiredToNumber;
function requireToNumber() {
  if (hasRequiredToNumber)
    return toNumber_1;
  hasRequiredToNumber = 1;
  var baseTrim = require_baseTrim(), isObject2 = requireIsObject(), isSymbol = requireIsSymbol();
  var NAN = 0 / 0;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject2(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject2(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  toNumber_1 = toNumber;
  return toNumber_1;
}
var debounce_1;
var hasRequiredDebounce;
function requireDebounce() {
  if (hasRequiredDebounce)
    return debounce_1;
  hasRequiredDebounce = 1;
  var isObject2 = requireIsObject(), now2 = requireNow(), toNumber = requireToNumber();
  var FUNC_ERROR_TEXT = "Expected a function";
  var nativeMax = Math.max, nativeMin = Math.min;
  function debounce2(func, wait, options) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber(wait) || 0;
    if (isObject2(options)) {
      leading = !!options.leading;
      maxing = "maxWait" in options;
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    function invokeFunc(time) {
      var args2 = lastArgs, thisArg = lastThis;
      lastArgs = lastThis = void 0;
      lastInvokeTime = time;
      result = func.apply(thisArg, args2);
      return result;
    }
    function leadingEdge(time) {
      lastInvokeTime = time;
      timerId = setTimeout(timerExpired, wait);
      return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
      return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }
    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
      return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
      var time = now2();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      timerId = setTimeout(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
      timerId = void 0;
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = void 0;
      return result;
    }
    function cancel() {
      if (timerId !== void 0) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = void 0;
    }
    function flush() {
      return timerId === void 0 ? result : trailingEdge(now2());
    }
    function debounced() {
      var time = now2(), isInvoking = shouldInvoke(time);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;
      if (isInvoking) {
        if (timerId === void 0) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          clearTimeout(timerId);
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === void 0) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }
  debounce_1 = debounce2;
  return debounce_1;
}
var isFunction_1;
var hasRequiredIsFunction;
function requireIsFunction() {
  if (hasRequiredIsFunction)
    return isFunction_1;
  hasRequiredIsFunction = 1;
  var baseGetTag = require_baseGetTag(), isObject2 = requireIsObject();
  var asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
  function isFunction2(value) {
    if (!isObject2(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  isFunction_1 = isFunction2;
  return isFunction_1;
}
var _coreJsData;
var hasRequired_coreJsData;
function require_coreJsData() {
  if (hasRequired_coreJsData)
    return _coreJsData;
  hasRequired_coreJsData = 1;
  var root = require_root();
  var coreJsData = root["__core-js_shared__"];
  _coreJsData = coreJsData;
  return _coreJsData;
}
var _isMasked;
var hasRequired_isMasked;
function require_isMasked() {
  if (hasRequired_isMasked)
    return _isMasked;
  hasRequired_isMasked = 1;
  var coreJsData = require_coreJsData();
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  _isMasked = isMasked;
  return _isMasked;
}
var _toSource;
var hasRequired_toSource;
function require_toSource() {
  if (hasRequired_toSource)
    return _toSource;
  hasRequired_toSource = 1;
  var funcProto = Function.prototype;
  var funcToString = funcProto.toString;
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e2) {
      }
      try {
        return func + "";
      } catch (e2) {
      }
    }
    return "";
  }
  _toSource = toSource;
  return _toSource;
}
var _baseIsNative;
var hasRequired_baseIsNative;
function require_baseIsNative() {
  if (hasRequired_baseIsNative)
    return _baseIsNative;
  hasRequired_baseIsNative = 1;
  var isFunction2 = requireIsFunction(), isMasked = require_isMasked(), isObject2 = requireIsObject(), toSource = require_toSource();
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto = Function.prototype, objectProto2 = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto2.hasOwnProperty;
  var reIsNative = RegExp(
    "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function baseIsNative(value) {
    if (!isObject2(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  _baseIsNative = baseIsNative;
  return _baseIsNative;
}
var _getValue;
var hasRequired_getValue;
function require_getValue() {
  if (hasRequired_getValue)
    return _getValue;
  hasRequired_getValue = 1;
  function getValue2(object, key) {
    return object == null ? void 0 : object[key];
  }
  _getValue = getValue2;
  return _getValue;
}
var _getNative;
var hasRequired_getNative;
function require_getNative() {
  if (hasRequired_getNative)
    return _getNative;
  hasRequired_getNative = 1;
  var baseIsNative = require_baseIsNative(), getValue2 = require_getValue();
  function getNative(object, key) {
    var value = getValue2(object, key);
    return baseIsNative(value) ? value : void 0;
  }
  _getNative = getNative;
  return _getNative;
}
var _nativeCreate;
var hasRequired_nativeCreate;
function require_nativeCreate() {
  if (hasRequired_nativeCreate)
    return _nativeCreate;
  hasRequired_nativeCreate = 1;
  var getNative = require_getNative();
  var nativeCreate = getNative(Object, "create");
  _nativeCreate = nativeCreate;
  return _nativeCreate;
}
var _hashClear;
var hasRequired_hashClear;
function require_hashClear() {
  if (hasRequired_hashClear)
    return _hashClear;
  hasRequired_hashClear = 1;
  var nativeCreate = require_nativeCreate();
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }
  _hashClear = hashClear;
  return _hashClear;
}
var _hashDelete;
var hasRequired_hashDelete;
function require_hashDelete() {
  if (hasRequired_hashDelete)
    return _hashDelete;
  hasRequired_hashDelete = 1;
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  _hashDelete = hashDelete;
  return _hashDelete;
}
var _hashGet;
var hasRequired_hashGet;
function require_hashGet() {
  if (hasRequired_hashGet)
    return _hashGet;
  hasRequired_hashGet = 1;
  var nativeCreate = require_nativeCreate();
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var objectProto2 = Object.prototype;
  var hasOwnProperty = objectProto2.hasOwnProperty;
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : void 0;
  }
  _hashGet = hashGet;
  return _hashGet;
}
var _hashHas;
var hasRequired_hashHas;
function require_hashHas() {
  if (hasRequired_hashHas)
    return _hashHas;
  hasRequired_hashHas = 1;
  var nativeCreate = require_nativeCreate();
  var objectProto2 = Object.prototype;
  var hasOwnProperty = objectProto2.hasOwnProperty;
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
  }
  _hashHas = hashHas;
  return _hashHas;
}
var _hashSet;
var hasRequired_hashSet;
function require_hashSet() {
  if (hasRequired_hashSet)
    return _hashSet;
  hasRequired_hashSet = 1;
  var nativeCreate = require_nativeCreate();
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  _hashSet = hashSet;
  return _hashSet;
}
var _Hash;
var hasRequired_Hash;
function require_Hash() {
  if (hasRequired_Hash)
    return _Hash;
  hasRequired_Hash = 1;
  var hashClear = require_hashClear(), hashDelete = require_hashDelete(), hashGet = require_hashGet(), hashHas = require_hashHas(), hashSet = require_hashSet();
  function Hash(entries) {
    var index = -1, length2 = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length2) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  _Hash = Hash;
  return _Hash;
}
var _listCacheClear;
var hasRequired_listCacheClear;
function require_listCacheClear() {
  if (hasRequired_listCacheClear)
    return _listCacheClear;
  hasRequired_listCacheClear = 1;
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  _listCacheClear = listCacheClear;
  return _listCacheClear;
}
var eq_1;
var hasRequiredEq;
function requireEq() {
  if (hasRequiredEq)
    return eq_1;
  hasRequiredEq = 1;
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  eq_1 = eq;
  return eq_1;
}
var _assocIndexOf;
var hasRequired_assocIndexOf;
function require_assocIndexOf() {
  if (hasRequired_assocIndexOf)
    return _assocIndexOf;
  hasRequired_assocIndexOf = 1;
  var eq = requireEq();
  function assocIndexOf(array, key) {
    var length2 = array.length;
    while (length2--) {
      if (eq(array[length2][0], key)) {
        return length2;
      }
    }
    return -1;
  }
  _assocIndexOf = assocIndexOf;
  return _assocIndexOf;
}
var _listCacheDelete;
var hasRequired_listCacheDelete;
function require_listCacheDelete() {
  if (hasRequired_listCacheDelete)
    return _listCacheDelete;
  hasRequired_listCacheDelete = 1;
  var assocIndexOf = require_assocIndexOf();
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;
  function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }
  _listCacheDelete = listCacheDelete;
  return _listCacheDelete;
}
var _listCacheGet;
var hasRequired_listCacheGet;
function require_listCacheGet() {
  if (hasRequired_listCacheGet)
    return _listCacheGet;
  hasRequired_listCacheGet = 1;
  var assocIndexOf = require_assocIndexOf();
  function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? void 0 : data[index][1];
  }
  _listCacheGet = listCacheGet;
  return _listCacheGet;
}
var _listCacheHas;
var hasRequired_listCacheHas;
function require_listCacheHas() {
  if (hasRequired_listCacheHas)
    return _listCacheHas;
  hasRequired_listCacheHas = 1;
  var assocIndexOf = require_assocIndexOf();
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  _listCacheHas = listCacheHas;
  return _listCacheHas;
}
var _listCacheSet;
var hasRequired_listCacheSet;
function require_listCacheSet() {
  if (hasRequired_listCacheSet)
    return _listCacheSet;
  hasRequired_listCacheSet = 1;
  var assocIndexOf = require_assocIndexOf();
  function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  _listCacheSet = listCacheSet;
  return _listCacheSet;
}
var _ListCache;
var hasRequired_ListCache;
function require_ListCache() {
  if (hasRequired_ListCache)
    return _ListCache;
  hasRequired_ListCache = 1;
  var listCacheClear = require_listCacheClear(), listCacheDelete = require_listCacheDelete(), listCacheGet = require_listCacheGet(), listCacheHas = require_listCacheHas(), listCacheSet = require_listCacheSet();
  function ListCache(entries) {
    var index = -1, length2 = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length2) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  _ListCache = ListCache;
  return _ListCache;
}
var _Map;
var hasRequired_Map;
function require_Map() {
  if (hasRequired_Map)
    return _Map;
  hasRequired_Map = 1;
  var getNative = require_getNative(), root = require_root();
  var Map2 = getNative(root, "Map");
  _Map = Map2;
  return _Map;
}
var _mapCacheClear;
var hasRequired_mapCacheClear;
function require_mapCacheClear() {
  if (hasRequired_mapCacheClear)
    return _mapCacheClear;
  hasRequired_mapCacheClear = 1;
  var Hash = require_Hash(), ListCache = require_ListCache(), Map2 = require_Map();
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map2 || ListCache)(),
      "string": new Hash()
    };
  }
  _mapCacheClear = mapCacheClear;
  return _mapCacheClear;
}
var _isKeyable;
var hasRequired_isKeyable;
function require_isKeyable() {
  if (hasRequired_isKeyable)
    return _isKeyable;
  hasRequired_isKeyable = 1;
  function isKeyable(value) {
    var type2 = typeof value;
    return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
  }
  _isKeyable = isKeyable;
  return _isKeyable;
}
var _getMapData;
var hasRequired_getMapData;
function require_getMapData() {
  if (hasRequired_getMapData)
    return _getMapData;
  hasRequired_getMapData = 1;
  var isKeyable = require_isKeyable();
  function getMapData(map2, key) {
    var data = map2.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  _getMapData = getMapData;
  return _getMapData;
}
var _mapCacheDelete;
var hasRequired_mapCacheDelete;
function require_mapCacheDelete() {
  if (hasRequired_mapCacheDelete)
    return _mapCacheDelete;
  hasRequired_mapCacheDelete = 1;
  var getMapData = require_getMapData();
  function mapCacheDelete(key) {
    var result = getMapData(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  _mapCacheDelete = mapCacheDelete;
  return _mapCacheDelete;
}
var _mapCacheGet;
var hasRequired_mapCacheGet;
function require_mapCacheGet() {
  if (hasRequired_mapCacheGet)
    return _mapCacheGet;
  hasRequired_mapCacheGet = 1;
  var getMapData = require_getMapData();
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  _mapCacheGet = mapCacheGet;
  return _mapCacheGet;
}
var _mapCacheHas;
var hasRequired_mapCacheHas;
function require_mapCacheHas() {
  if (hasRequired_mapCacheHas)
    return _mapCacheHas;
  hasRequired_mapCacheHas = 1;
  var getMapData = require_getMapData();
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  _mapCacheHas = mapCacheHas;
  return _mapCacheHas;
}
var _mapCacheSet;
var hasRequired_mapCacheSet;
function require_mapCacheSet() {
  if (hasRequired_mapCacheSet)
    return _mapCacheSet;
  hasRequired_mapCacheSet = 1;
  var getMapData = require_getMapData();
  function mapCacheSet(key, value) {
    var data = getMapData(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  _mapCacheSet = mapCacheSet;
  return _mapCacheSet;
}
var _MapCache;
var hasRequired_MapCache;
function require_MapCache() {
  if (hasRequired_MapCache)
    return _MapCache;
  hasRequired_MapCache = 1;
  var mapCacheClear = require_mapCacheClear(), mapCacheDelete = require_mapCacheDelete(), mapCacheGet = require_mapCacheGet(), mapCacheHas = require_mapCacheHas(), mapCacheSet = require_mapCacheSet();
  function MapCache(entries) {
    var index = -1, length2 = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length2) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  _MapCache = MapCache;
  return _MapCache;
}
var _setCacheAdd;
var hasRequired_setCacheAdd;
function require_setCacheAdd() {
  if (hasRequired_setCacheAdd)
    return _setCacheAdd;
  hasRequired_setCacheAdd = 1;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  _setCacheAdd = setCacheAdd;
  return _setCacheAdd;
}
var _setCacheHas;
var hasRequired_setCacheHas;
function require_setCacheHas() {
  if (hasRequired_setCacheHas)
    return _setCacheHas;
  hasRequired_setCacheHas = 1;
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  _setCacheHas = setCacheHas;
  return _setCacheHas;
}
var _SetCache;
var hasRequired_SetCache;
function require_SetCache() {
  if (hasRequired_SetCache)
    return _SetCache;
  hasRequired_SetCache = 1;
  var MapCache = require_MapCache(), setCacheAdd = require_setCacheAdd(), setCacheHas = require_setCacheHas();
  function SetCache(values) {
    var index = -1, length2 = values == null ? 0 : values.length;
    this.__data__ = new MapCache();
    while (++index < length2) {
      this.add(values[index]);
    }
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  _SetCache = SetCache;
  return _SetCache;
}
var _baseFindIndex;
var hasRequired_baseFindIndex;
function require_baseFindIndex() {
  if (hasRequired_baseFindIndex)
    return _baseFindIndex;
  hasRequired_baseFindIndex = 1;
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length2 = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index-- : ++index < length2) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }
  _baseFindIndex = baseFindIndex;
  return _baseFindIndex;
}
var _baseIsNaN;
var hasRequired_baseIsNaN;
function require_baseIsNaN() {
  if (hasRequired_baseIsNaN)
    return _baseIsNaN;
  hasRequired_baseIsNaN = 1;
  function baseIsNaN(value) {
    return value !== value;
  }
  _baseIsNaN = baseIsNaN;
  return _baseIsNaN;
}
var _strictIndexOf;
var hasRequired_strictIndexOf;
function require_strictIndexOf() {
  if (hasRequired_strictIndexOf)
    return _strictIndexOf;
  hasRequired_strictIndexOf = 1;
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1, length2 = array.length;
    while (++index < length2) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }
  _strictIndexOf = strictIndexOf;
  return _strictIndexOf;
}
var _baseIndexOf;
var hasRequired_baseIndexOf;
function require_baseIndexOf() {
  if (hasRequired_baseIndexOf)
    return _baseIndexOf;
  hasRequired_baseIndexOf = 1;
  var baseFindIndex = require_baseFindIndex(), baseIsNaN = require_baseIsNaN(), strictIndexOf = require_strictIndexOf();
  function baseIndexOf(array, value, fromIndex) {
    return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
  }
  _baseIndexOf = baseIndexOf;
  return _baseIndexOf;
}
var _arrayIncludes;
var hasRequired_arrayIncludes;
function require_arrayIncludes() {
  if (hasRequired_arrayIncludes)
    return _arrayIncludes;
  hasRequired_arrayIncludes = 1;
  var baseIndexOf = require_baseIndexOf();
  function arrayIncludes(array, value) {
    var length2 = array == null ? 0 : array.length;
    return !!length2 && baseIndexOf(array, value, 0) > -1;
  }
  _arrayIncludes = arrayIncludes;
  return _arrayIncludes;
}
var _arrayIncludesWith;
var hasRequired_arrayIncludesWith;
function require_arrayIncludesWith() {
  if (hasRequired_arrayIncludesWith)
    return _arrayIncludesWith;
  hasRequired_arrayIncludesWith = 1;
  function arrayIncludesWith(array, value, comparator) {
    var index = -1, length2 = array == null ? 0 : array.length;
    while (++index < length2) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }
  _arrayIncludesWith = arrayIncludesWith;
  return _arrayIncludesWith;
}
var _arrayMap;
var hasRequired_arrayMap;
function require_arrayMap() {
  if (hasRequired_arrayMap)
    return _arrayMap;
  hasRequired_arrayMap = 1;
  function arrayMap(array, iteratee) {
    var index = -1, length2 = array == null ? 0 : array.length, result = Array(length2);
    while (++index < length2) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }
  _arrayMap = arrayMap;
  return _arrayMap;
}
var _baseUnary;
var hasRequired_baseUnary;
function require_baseUnary() {
  if (hasRequired_baseUnary)
    return _baseUnary;
  hasRequired_baseUnary = 1;
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  _baseUnary = baseUnary;
  return _baseUnary;
}
var _cacheHas;
var hasRequired_cacheHas;
function require_cacheHas() {
  if (hasRequired_cacheHas)
    return _cacheHas;
  hasRequired_cacheHas = 1;
  function cacheHas(cache, key) {
    return cache.has(key);
  }
  _cacheHas = cacheHas;
  return _cacheHas;
}
var _baseDifference;
var hasRequired_baseDifference;
function require_baseDifference() {
  if (hasRequired_baseDifference)
    return _baseDifference;
  hasRequired_baseDifference = 1;
  var SetCache = require_SetCache(), arrayIncludes = require_arrayIncludes(), arrayIncludesWith = require_arrayIncludesWith(), arrayMap = require_arrayMap(), baseUnary = require_baseUnary(), cacheHas = require_cacheHas();
  var LARGE_ARRAY_SIZE = 200;
  function baseDifference(array, values, iteratee, comparator) {
    var index = -1, includes = arrayIncludes, isCommon = true, length2 = array.length, result = [], valuesLength = values.length;
    if (!length2) {
      return result;
    }
    if (iteratee) {
      values = arrayMap(values, baseUnary(iteratee));
    }
    if (comparator) {
      includes = arrayIncludesWith;
      isCommon = false;
    } else if (values.length >= LARGE_ARRAY_SIZE) {
      includes = cacheHas;
      isCommon = false;
      values = new SetCache(values);
    }
    outer:
      while (++index < length2) {
        var value = array[index], computed = iteratee == null ? value : iteratee(value);
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        } else if (!includes(values, computed, comparator)) {
          result.push(value);
        }
      }
    return result;
  }
  _baseDifference = baseDifference;
  return _baseDifference;
}
var _arrayPush;
var hasRequired_arrayPush;
function require_arrayPush() {
  if (hasRequired_arrayPush)
    return _arrayPush;
  hasRequired_arrayPush = 1;
  function arrayPush(array, values) {
    var index = -1, length2 = values.length, offset = array.length;
    while (++index < length2) {
      array[offset + index] = values[index];
    }
    return array;
  }
  _arrayPush = arrayPush;
  return _arrayPush;
}
var _baseIsArguments;
var hasRequired_baseIsArguments;
function require_baseIsArguments() {
  if (hasRequired_baseIsArguments)
    return _baseIsArguments;
  hasRequired_baseIsArguments = 1;
  var baseGetTag = require_baseGetTag(), isObjectLike2 = requireIsObjectLike();
  var argsTag = "[object Arguments]";
  function baseIsArguments(value) {
    return isObjectLike2(value) && baseGetTag(value) == argsTag;
  }
  _baseIsArguments = baseIsArguments;
  return _baseIsArguments;
}
var isArguments_1;
var hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments)
    return isArguments_1;
  hasRequiredIsArguments = 1;
  var baseIsArguments = require_baseIsArguments(), isObjectLike2 = requireIsObjectLike();
  var objectProto2 = Object.prototype;
  var hasOwnProperty = objectProto2.hasOwnProperty;
  var propertyIsEnumerable = objectProto2.propertyIsEnumerable;
  var isArguments = baseIsArguments(/* @__PURE__ */ function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike2(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  isArguments_1 = isArguments;
  return isArguments_1;
}
var isArray_1;
var hasRequiredIsArray;
function requireIsArray() {
  if (hasRequiredIsArray)
    return isArray_1;
  hasRequiredIsArray = 1;
  var isArray2 = Array.isArray;
  isArray_1 = isArray2;
  return isArray_1;
}
var _isFlattenable;
var hasRequired_isFlattenable;
function require_isFlattenable() {
  if (hasRequired_isFlattenable)
    return _isFlattenable;
  hasRequired_isFlattenable = 1;
  var Symbol2 = require_Symbol(), isArguments = requireIsArguments(), isArray2 = requireIsArray();
  var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
  function isFlattenable(value) {
    return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  _isFlattenable = isFlattenable;
  return _isFlattenable;
}
var _baseFlatten;
var hasRequired_baseFlatten;
function require_baseFlatten() {
  if (hasRequired_baseFlatten)
    return _baseFlatten;
  hasRequired_baseFlatten = 1;
  var arrayPush = require_arrayPush(), isFlattenable = require_isFlattenable();
  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1, length2 = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while (++index < length2) {
      var value = array[index];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }
  _baseFlatten = baseFlatten;
  return _baseFlatten;
}
var identity_1;
var hasRequiredIdentity;
function requireIdentity() {
  if (hasRequiredIdentity)
    return identity_1;
  hasRequiredIdentity = 1;
  function identity2(value) {
    return value;
  }
  identity_1 = identity2;
  return identity_1;
}
var _apply;
var hasRequired_apply;
function require_apply() {
  if (hasRequired_apply)
    return _apply;
  hasRequired_apply = 1;
  function apply(func, thisArg, args2) {
    switch (args2.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args2[0]);
      case 2:
        return func.call(thisArg, args2[0], args2[1]);
      case 3:
        return func.call(thisArg, args2[0], args2[1], args2[2]);
    }
    return func.apply(thisArg, args2);
  }
  _apply = apply;
  return _apply;
}
var _overRest;
var hasRequired_overRest;
function require_overRest() {
  if (hasRequired_overRest)
    return _overRest;
  hasRequired_overRest = 1;
  var apply = require_apply();
  var nativeMax = Math.max;
  function overRest(func, start, transform) {
    start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
    return function() {
      var args2 = arguments, index = -1, length2 = nativeMax(args2.length - start, 0), array = Array(length2);
      while (++index < length2) {
        array[index] = args2[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args2[index];
      }
      otherArgs[start] = transform(array);
      return apply(func, this, otherArgs);
    };
  }
  _overRest = overRest;
  return _overRest;
}
var constant_1;
var hasRequiredConstant;
function requireConstant() {
  if (hasRequiredConstant)
    return constant_1;
  hasRequiredConstant = 1;
  function constant(value) {
    return function() {
      return value;
    };
  }
  constant_1 = constant;
  return constant_1;
}
var _defineProperty;
var hasRequired_defineProperty;
function require_defineProperty() {
  if (hasRequired_defineProperty)
    return _defineProperty;
  hasRequired_defineProperty = 1;
  var getNative = require_getNative();
  var defineProperty = function() {
    try {
      var func = getNative(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e2) {
    }
  }();
  _defineProperty = defineProperty;
  return _defineProperty;
}
var _baseSetToString;
var hasRequired_baseSetToString;
function require_baseSetToString() {
  if (hasRequired_baseSetToString)
    return _baseSetToString;
  hasRequired_baseSetToString = 1;
  var constant = requireConstant(), defineProperty = require_defineProperty(), identity2 = requireIdentity();
  var baseSetToString = !defineProperty ? identity2 : function(func, string) {
    return defineProperty(func, "toString", {
      "configurable": true,
      "enumerable": false,
      "value": constant(string),
      "writable": true
    });
  };
  _baseSetToString = baseSetToString;
  return _baseSetToString;
}
var _shortOut;
var hasRequired_shortOut;
function require_shortOut() {
  if (hasRequired_shortOut)
    return _shortOut;
  hasRequired_shortOut = 1;
  var HOT_COUNT = 800, HOT_SPAN = 16;
  var nativeNow = Date.now;
  function shortOut(func) {
    var count2 = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count2 >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count2 = 0;
      }
      return func.apply(void 0, arguments);
    };
  }
  _shortOut = shortOut;
  return _shortOut;
}
var _setToString;
var hasRequired_setToString;
function require_setToString() {
  if (hasRequired_setToString)
    return _setToString;
  hasRequired_setToString = 1;
  var baseSetToString = require_baseSetToString(), shortOut = require_shortOut();
  var setToString = shortOut(baseSetToString);
  _setToString = setToString;
  return _setToString;
}
var _baseRest;
var hasRequired_baseRest;
function require_baseRest() {
  if (hasRequired_baseRest)
    return _baseRest;
  hasRequired_baseRest = 1;
  var identity2 = requireIdentity(), overRest = require_overRest(), setToString = require_setToString();
  function baseRest(func, start) {
    return setToString(overRest(func, start, identity2), func + "");
  }
  _baseRest = baseRest;
  return _baseRest;
}
var isLength_1;
var hasRequiredIsLength;
function requireIsLength() {
  if (hasRequiredIsLength)
    return isLength_1;
  hasRequiredIsLength = 1;
  var MAX_SAFE_INTEGER = 9007199254740991;
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  isLength_1 = isLength;
  return isLength_1;
}
var isArrayLike_1;
var hasRequiredIsArrayLike;
function requireIsArrayLike() {
  if (hasRequiredIsArrayLike)
    return isArrayLike_1;
  hasRequiredIsArrayLike = 1;
  var isFunction2 = requireIsFunction(), isLength = requireIsLength();
  function isArrayLike2(value) {
    return value != null && isLength(value.length) && !isFunction2(value);
  }
  isArrayLike_1 = isArrayLike2;
  return isArrayLike_1;
}
var isArrayLikeObject_1;
var hasRequiredIsArrayLikeObject;
function requireIsArrayLikeObject() {
  if (hasRequiredIsArrayLikeObject)
    return isArrayLikeObject_1;
  hasRequiredIsArrayLikeObject = 1;
  var isArrayLike2 = requireIsArrayLike(), isObjectLike2 = requireIsObjectLike();
  function isArrayLikeObject(value) {
    return isObjectLike2(value) && isArrayLike2(value);
  }
  isArrayLikeObject_1 = isArrayLikeObject;
  return isArrayLikeObject_1;
}
var difference_1;
var hasRequiredDifference;
function requireDifference() {
  if (hasRequiredDifference)
    return difference_1;
  hasRequiredDifference = 1;
  var baseDifference = require_baseDifference(), baseFlatten = require_baseFlatten(), baseRest = require_baseRest(), isArrayLikeObject = requireIsArrayLikeObject();
  var difference = baseRest(function(array, values) {
    return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
  });
  difference_1 = difference;
  return difference_1;
}
var _arrayFilter;
var hasRequired_arrayFilter;
function require_arrayFilter() {
  if (hasRequired_arrayFilter)
    return _arrayFilter;
  hasRequired_arrayFilter = 1;
  function arrayFilter(array, predicate) {
    var index = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
    while (++index < length2) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  _arrayFilter = arrayFilter;
  return _arrayFilter;
}
var _createBaseFor;
var hasRequired_createBaseFor;
function require_createBaseFor() {
  if (hasRequired_createBaseFor)
    return _createBaseFor;
  hasRequired_createBaseFor = 1;
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index = -1, iterable = Object(object), props = keysFunc(object), length2 = props.length;
      while (length2--) {
        var key = props[fromRight ? length2 : ++index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }
  _createBaseFor = createBaseFor;
  return _createBaseFor;
}
var _baseFor;
var hasRequired_baseFor;
function require_baseFor() {
  if (hasRequired_baseFor)
    return _baseFor;
  hasRequired_baseFor = 1;
  var createBaseFor = require_createBaseFor();
  var baseFor = createBaseFor();
  _baseFor = baseFor;
  return _baseFor;
}
var _baseTimes;
var hasRequired_baseTimes;
function require_baseTimes() {
  if (hasRequired_baseTimes)
    return _baseTimes;
  hasRequired_baseTimes = 1;
  function baseTimes(n2, iteratee) {
    var index = -1, result = Array(n2);
    while (++index < n2) {
      result[index] = iteratee(index);
    }
    return result;
  }
  _baseTimes = baseTimes;
  return _baseTimes;
}
var isBuffer = { exports: {} };
var stubFalse_1;
var hasRequiredStubFalse;
function requireStubFalse() {
  if (hasRequiredStubFalse)
    return stubFalse_1;
  hasRequiredStubFalse = 1;
  function stubFalse() {
    return false;
  }
  stubFalse_1 = stubFalse;
  return stubFalse_1;
}
isBuffer.exports;
var hasRequiredIsBuffer;
function requireIsBuffer() {
  if (hasRequiredIsBuffer)
    return isBuffer.exports;
  hasRequiredIsBuffer = 1;
  (function(module, exports) {
    var root = require_root(), stubFalse = requireStubFalse();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer2 = nativeIsBuffer || stubFalse;
    module.exports = isBuffer2;
  })(isBuffer, isBuffer.exports);
  return isBuffer.exports;
}
var _isIndex;
var hasRequired_isIndex;
function require_isIndex() {
  if (hasRequired_isIndex)
    return _isIndex;
  hasRequired_isIndex = 1;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex(value, length2) {
    var type2 = typeof value;
    length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
    return !!length2 && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
  }
  _isIndex = isIndex;
  return _isIndex;
}
var _baseIsTypedArray;
var hasRequired_baseIsTypedArray;
function require_baseIsTypedArray() {
  if (hasRequired_baseIsTypedArray)
    return _baseIsTypedArray;
  hasRequired_baseIsTypedArray = 1;
  var baseGetTag = require_baseGetTag(), isLength = requireIsLength(), isObjectLike2 = requireIsObjectLike();
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  function baseIsTypedArray(value) {
    return isObjectLike2(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  _baseIsTypedArray = baseIsTypedArray;
  return _baseIsTypedArray;
}
var _nodeUtil = { exports: {} };
_nodeUtil.exports;
var hasRequired_nodeUtil;
function require_nodeUtil() {
  if (hasRequired_nodeUtil)
    return _nodeUtil.exports;
  hasRequired_nodeUtil = 1;
  (function(module, exports) {
    var freeGlobal = require_freeGlobal();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types2 = freeModule && freeModule.require && freeModule.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e2) {
      }
    }();
    module.exports = nodeUtil;
  })(_nodeUtil, _nodeUtil.exports);
  return _nodeUtil.exports;
}
var isTypedArray_1;
var hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray)
    return isTypedArray_1;
  hasRequiredIsTypedArray = 1;
  var baseIsTypedArray = require_baseIsTypedArray(), baseUnary = require_baseUnary(), nodeUtil = require_nodeUtil();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  isTypedArray_1 = isTypedArray2;
  return isTypedArray_1;
}
var _arrayLikeKeys;
var hasRequired_arrayLikeKeys;
function require_arrayLikeKeys() {
  if (hasRequired_arrayLikeKeys)
    return _arrayLikeKeys;
  hasRequired_arrayLikeKeys = 1;
  var baseTimes = require_baseTimes(), isArguments = requireIsArguments(), isArray2 = requireIsArray(), isBuffer2 = requireIsBuffer(), isIndex = require_isIndex(), isTypedArray2 = requireIsTypedArray();
  var objectProto2 = Object.prototype;
  var hasOwnProperty = objectProto2.hasOwnProperty;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
      (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
      isIndex(key, length2)))) {
        result.push(key);
      }
    }
    return result;
  }
  _arrayLikeKeys = arrayLikeKeys;
  return _arrayLikeKeys;
}
var _isPrototype;
var hasRequired_isPrototype;
function require_isPrototype() {
  if (hasRequired_isPrototype)
    return _isPrototype;
  hasRequired_isPrototype = 1;
  var objectProto2 = Object.prototype;
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
    return value === proto;
  }
  _isPrototype = isPrototype;
  return _isPrototype;
}
var _overArg;
var hasRequired_overArg;
function require_overArg() {
  if (hasRequired_overArg)
    return _overArg;
  hasRequired_overArg = 1;
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  _overArg = overArg;
  return _overArg;
}
var _nativeKeys;
var hasRequired_nativeKeys;
function require_nativeKeys() {
  if (hasRequired_nativeKeys)
    return _nativeKeys;
  hasRequired_nativeKeys = 1;
  var overArg = require_overArg();
  var nativeKeys = overArg(Object.keys, Object);
  _nativeKeys = nativeKeys;
  return _nativeKeys;
}
var _baseKeys;
var hasRequired_baseKeys;
function require_baseKeys() {
  if (hasRequired_baseKeys)
    return _baseKeys;
  hasRequired_baseKeys = 1;
  var isPrototype = require_isPrototype(), nativeKeys = require_nativeKeys();
  var objectProto2 = Object.prototype;
  var hasOwnProperty = objectProto2.hasOwnProperty;
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  _baseKeys = baseKeys;
  return _baseKeys;
}
var keys_1;
var hasRequiredKeys;
function requireKeys() {
  if (hasRequiredKeys)
    return keys_1;
  hasRequiredKeys = 1;
  var arrayLikeKeys = require_arrayLikeKeys(), baseKeys = require_baseKeys(), isArrayLike2 = requireIsArrayLike();
  function keys(object) {
    return isArrayLike2(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  keys_1 = keys;
  return keys_1;
}
var _baseForOwn;
var hasRequired_baseForOwn;
function require_baseForOwn() {
  if (hasRequired_baseForOwn)
    return _baseForOwn;
  hasRequired_baseForOwn = 1;
  var baseFor = require_baseFor(), keys = requireKeys();
  function baseForOwn(object, iteratee) {
    return object && baseFor(object, iteratee, keys);
  }
  _baseForOwn = baseForOwn;
  return _baseForOwn;
}
var _createBaseEach;
var hasRequired_createBaseEach;
function require_createBaseEach() {
  if (hasRequired_createBaseEach)
    return _createBaseEach;
  hasRequired_createBaseEach = 1;
  var isArrayLike2 = requireIsArrayLike();
  function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
      if (collection == null) {
        return collection;
      }
      if (!isArrayLike2(collection)) {
        return eachFunc(collection, iteratee);
      }
      var length2 = collection.length, index = fromRight ? length2 : -1, iterable = Object(collection);
      while (fromRight ? index-- : ++index < length2) {
        if (iteratee(iterable[index], index, iterable) === false) {
          break;
        }
      }
      return collection;
    };
  }
  _createBaseEach = createBaseEach;
  return _createBaseEach;
}
var _baseEach;
var hasRequired_baseEach;
function require_baseEach() {
  if (hasRequired_baseEach)
    return _baseEach;
  hasRequired_baseEach = 1;
  var baseForOwn = require_baseForOwn(), createBaseEach = require_createBaseEach();
  var baseEach = createBaseEach(baseForOwn);
  _baseEach = baseEach;
  return _baseEach;
}
var _baseFilter;
var hasRequired_baseFilter;
function require_baseFilter() {
  if (hasRequired_baseFilter)
    return _baseFilter;
  hasRequired_baseFilter = 1;
  var baseEach = require_baseEach();
  function baseFilter(collection, predicate) {
    var result = [];
    baseEach(collection, function(value, index, collection2) {
      if (predicate(value, index, collection2)) {
        result.push(value);
      }
    });
    return result;
  }
  _baseFilter = baseFilter;
  return _baseFilter;
}
var _stackClear;
var hasRequired_stackClear;
function require_stackClear() {
  if (hasRequired_stackClear)
    return _stackClear;
  hasRequired_stackClear = 1;
  var ListCache = require_ListCache();
  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }
  _stackClear = stackClear;
  return _stackClear;
}
var _stackDelete;
var hasRequired_stackDelete;
function require_stackDelete() {
  if (hasRequired_stackDelete)
    return _stackDelete;
  hasRequired_stackDelete = 1;
  function stackDelete(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
  }
  _stackDelete = stackDelete;
  return _stackDelete;
}
var _stackGet;
var hasRequired_stackGet;
function require_stackGet() {
  if (hasRequired_stackGet)
    return _stackGet;
  hasRequired_stackGet = 1;
  function stackGet(key) {
    return this.__data__.get(key);
  }
  _stackGet = stackGet;
  return _stackGet;
}
var _stackHas;
var hasRequired_stackHas;
function require_stackHas() {
  if (hasRequired_stackHas)
    return _stackHas;
  hasRequired_stackHas = 1;
  function stackHas(key) {
    return this.__data__.has(key);
  }
  _stackHas = stackHas;
  return _stackHas;
}
var _stackSet;
var hasRequired_stackSet;
function require_stackSet() {
  if (hasRequired_stackSet)
    return _stackSet;
  hasRequired_stackSet = 1;
  var ListCache = require_ListCache(), Map2 = require_Map(), MapCache = require_MapCache();
  var LARGE_ARRAY_SIZE = 200;
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs2 = data.__data__;
      if (!Map2 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
        pairs2.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs2);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }
  _stackSet = stackSet;
  return _stackSet;
}
var _Stack;
var hasRequired_Stack;
function require_Stack() {
  if (hasRequired_Stack)
    return _Stack;
  hasRequired_Stack = 1;
  var ListCache = require_ListCache(), stackClear = require_stackClear(), stackDelete = require_stackDelete(), stackGet = require_stackGet(), stackHas = require_stackHas(), stackSet = require_stackSet();
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  _Stack = Stack;
  return _Stack;
}
var _arraySome;
var hasRequired_arraySome;
function require_arraySome() {
  if (hasRequired_arraySome)
    return _arraySome;
  hasRequired_arraySome = 1;
  function arraySome(array, predicate) {
    var index = -1, length2 = array == null ? 0 : array.length;
    while (++index < length2) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }
  _arraySome = arraySome;
  return _arraySome;
}
var _equalArrays;
var hasRequired_equalArrays;
function require_equalArrays() {
  if (hasRequired_equalArrays)
    return _equalArrays;
  hasRequired_equalArrays = 1;
  var SetCache = require_SetCache(), arraySome = require_arraySome(), cacheHas = require_cacheHas();
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var arrStacked = stack.get(array);
    var othStacked = stack.get(other);
    if (arrStacked && othStacked) {
      return arrStacked == other && othStacked == array;
    }
    var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
    stack.set(array, other);
    stack.set(other, array);
    while (++index < arrLength) {
      var arrValue = array[index], othValue = other[index];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }
    stack["delete"](array);
    stack["delete"](other);
    return result;
  }
  _equalArrays = equalArrays;
  return _equalArrays;
}
var _Uint8Array;
var hasRequired_Uint8Array;
function require_Uint8Array() {
  if (hasRequired_Uint8Array)
    return _Uint8Array;
  hasRequired_Uint8Array = 1;
  var root = require_root();
  var Uint8Array2 = root.Uint8Array;
  _Uint8Array = Uint8Array2;
  return _Uint8Array;
}
var _mapToArray;
var hasRequired_mapToArray;
function require_mapToArray() {
  if (hasRequired_mapToArray)
    return _mapToArray;
  hasRequired_mapToArray = 1;
  function mapToArray(map2) {
    var index = -1, result = Array(map2.size);
    map2.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }
  _mapToArray = mapToArray;
  return _mapToArray;
}
var _setToArray;
var hasRequired_setToArray;
function require_setToArray() {
  if (hasRequired_setToArray)
    return _setToArray;
  hasRequired_setToArray = 1;
  function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }
  _setToArray = setToArray;
  return _setToArray;
}
var _equalByTag;
var hasRequired_equalByTag;
function require_equalByTag() {
  if (hasRequired_equalByTag)
    return _equalByTag;
  hasRequired_equalByTag = 1;
  var Symbol2 = require_Symbol(), Uint8Array2 = require_Uint8Array(), eq = requireEq(), equalArrays = require_equalArrays(), mapToArray = require_mapToArray(), setToArray = require_setToArray();
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;
      case arrayBufferTag:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
          return false;
        }
        return true;
      case boolTag:
      case dateTag:
      case numberTag:
        return eq(+object, +other);
      case errorTag:
        return object.name == other.name && object.message == other.message;
      case regexpTag:
      case stringTag:
        return object == other + "";
      case mapTag:
        var convert = mapToArray;
      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
        convert || (convert = setToArray);
        if (object.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG;
        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack["delete"](object);
        return result;
      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  _equalByTag = equalByTag;
  return _equalByTag;
}
var _baseGetAllKeys;
var hasRequired_baseGetAllKeys;
function require_baseGetAllKeys() {
  if (hasRequired_baseGetAllKeys)
    return _baseGetAllKeys;
  hasRequired_baseGetAllKeys = 1;
  var arrayPush = require_arrayPush(), isArray2 = requireIsArray();
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray2(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  _baseGetAllKeys = baseGetAllKeys;
  return _baseGetAllKeys;
}
var stubArray_1;
var hasRequiredStubArray;
function requireStubArray() {
  if (hasRequiredStubArray)
    return stubArray_1;
  hasRequiredStubArray = 1;
  function stubArray() {
    return [];
  }
  stubArray_1 = stubArray;
  return stubArray_1;
}
var _getSymbols;
var hasRequired_getSymbols;
function require_getSymbols() {
  if (hasRequired_getSymbols)
    return _getSymbols;
  hasRequired_getSymbols = 1;
  var arrayFilter = require_arrayFilter(), stubArray = requireStubArray();
  var objectProto2 = Object.prototype;
  var propertyIsEnumerable = objectProto2.propertyIsEnumerable;
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };
  _getSymbols = getSymbols;
  return _getSymbols;
}
var _getAllKeys;
var hasRequired_getAllKeys;
function require_getAllKeys() {
  if (hasRequired_getAllKeys)
    return _getAllKeys;
  hasRequired_getAllKeys = 1;
  var baseGetAllKeys = require_baseGetAllKeys(), getSymbols = require_getSymbols(), keys = requireKeys();
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }
  _getAllKeys = getAllKeys;
  return _getAllKeys;
}
var _equalObjects;
var hasRequired_equalObjects;
function require_equalObjects() {
  if (hasRequired_equalObjects)
    return _equalObjects;
  hasRequired_equalObjects = 1;
  var getAllKeys = require_getAllKeys();
  var COMPARE_PARTIAL_FLAG = 1;
  var objectProto2 = Object.prototype;
  var hasOwnProperty = objectProto2.hasOwnProperty;
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
        return false;
      }
    }
    var objStacked = stack.get(object);
    var othStacked = stack.get(other);
    if (objStacked && othStacked) {
      return objStacked == other && othStacked == object;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key], othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack["delete"](object);
    stack["delete"](other);
    return result;
  }
  _equalObjects = equalObjects;
  return _equalObjects;
}
var _DataView;
var hasRequired_DataView;
function require_DataView() {
  if (hasRequired_DataView)
    return _DataView;
  hasRequired_DataView = 1;
  var getNative = require_getNative(), root = require_root();
  var DataView = getNative(root, "DataView");
  _DataView = DataView;
  return _DataView;
}
var _Promise;
var hasRequired_Promise;
function require_Promise() {
  if (hasRequired_Promise)
    return _Promise;
  hasRequired_Promise = 1;
  var getNative = require_getNative(), root = require_root();
  var Promise2 = getNative(root, "Promise");
  _Promise = Promise2;
  return _Promise;
}
var _Set;
var hasRequired_Set;
function require_Set() {
  if (hasRequired_Set)
    return _Set;
  hasRequired_Set = 1;
  var getNative = require_getNative(), root = require_root();
  var Set2 = getNative(root, "Set");
  _Set = Set2;
  return _Set;
}
var _WeakMap;
var hasRequired_WeakMap;
function require_WeakMap() {
  if (hasRequired_WeakMap)
    return _WeakMap;
  hasRequired_WeakMap = 1;
  var getNative = require_getNative(), root = require_root();
  var WeakMap2 = getNative(root, "WeakMap");
  _WeakMap = WeakMap2;
  return _WeakMap;
}
var _getTag;
var hasRequired_getTag;
function require_getTag() {
  if (hasRequired_getTag)
    return _getTag;
  hasRequired_getTag = 1;
  var DataView = require_DataView(), Map2 = require_Map(), Promise2 = require_Promise(), Set2 = require_Set(), WeakMap2 = require_WeakMap(), baseGetTag = require_baseGetTag(), toSource = require_toSource();
  var mapTag = "[object Map]", objectTag = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
  var dataViewTag = "[object DataView]";
  var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
  var getTag = baseGetTag;
  if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
    getTag = function(value) {
      var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  _getTag = getTag;
  return _getTag;
}
var _baseIsEqualDeep;
var hasRequired_baseIsEqualDeep;
function require_baseIsEqualDeep() {
  if (hasRequired_baseIsEqualDeep)
    return _baseIsEqualDeep;
  hasRequired_baseIsEqualDeep = 1;
  var Stack = require_Stack(), equalArrays = require_equalArrays(), equalByTag = require_equalByTag(), equalObjects = require_equalObjects(), getTag = require_getTag(), isArray2 = requireIsArray(), isBuffer2 = requireIsBuffer(), isTypedArray2 = requireIsTypedArray();
  var COMPARE_PARTIAL_FLAG = 1;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
  var objectProto2 = Object.prototype;
  var hasOwnProperty = objectProto2.hasOwnProperty;
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer2(object)) {
      if (!isBuffer2(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack());
      return objIsArr || isTypedArray2(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack());
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }
  _baseIsEqualDeep = baseIsEqualDeep;
  return _baseIsEqualDeep;
}
var _baseIsEqual;
var hasRequired_baseIsEqual;
function require_baseIsEqual() {
  if (hasRequired_baseIsEqual)
    return _baseIsEqual;
  hasRequired_baseIsEqual = 1;
  var baseIsEqualDeep = require_baseIsEqualDeep(), isObjectLike2 = requireIsObjectLike();
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }
  _baseIsEqual = baseIsEqual;
  return _baseIsEqual;
}
var _baseIsMatch;
var hasRequired_baseIsMatch;
function require_baseIsMatch() {
  if (hasRequired_baseIsMatch)
    return _baseIsMatch;
  hasRequired_baseIsMatch = 1;
  var Stack = require_Stack(), baseIsEqual = require_baseIsEqual();
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length, length2 = index, noCustomizer = !customizer;
    if (object == null) {
      return !length2;
    }
    object = Object(object);
    while (index--) {
      var data = matchData[index];
      if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
        return false;
      }
    }
    while (++index < length2) {
      data = matchData[index];
      var key = data[0], objValue = object[key], srcValue = data[1];
      if (noCustomizer && data[2]) {
        if (objValue === void 0 && !(key in object)) {
          return false;
        }
      } else {
        var stack = new Stack();
        if (customizer) {
          var result = customizer(objValue, srcValue, key, object, source, stack);
        }
        if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
          return false;
        }
      }
    }
    return true;
  }
  _baseIsMatch = baseIsMatch;
  return _baseIsMatch;
}
var _isStrictComparable;
var hasRequired_isStrictComparable;
function require_isStrictComparable() {
  if (hasRequired_isStrictComparable)
    return _isStrictComparable;
  hasRequired_isStrictComparable = 1;
  var isObject2 = requireIsObject();
  function isStrictComparable(value) {
    return value === value && !isObject2(value);
  }
  _isStrictComparable = isStrictComparable;
  return _isStrictComparable;
}
var _getMatchData;
var hasRequired_getMatchData;
function require_getMatchData() {
  if (hasRequired_getMatchData)
    return _getMatchData;
  hasRequired_getMatchData = 1;
  var isStrictComparable = require_isStrictComparable(), keys = requireKeys();
  function getMatchData(object) {
    var result = keys(object), length2 = result.length;
    while (length2--) {
      var key = result[length2], value = object[key];
      result[length2] = [key, value, isStrictComparable(value)];
    }
    return result;
  }
  _getMatchData = getMatchData;
  return _getMatchData;
}
var _matchesStrictComparable;
var hasRequired_matchesStrictComparable;
function require_matchesStrictComparable() {
  if (hasRequired_matchesStrictComparable)
    return _matchesStrictComparable;
  hasRequired_matchesStrictComparable = 1;
  function matchesStrictComparable(key, srcValue) {
    return function(object) {
      if (object == null) {
        return false;
      }
      return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
    };
  }
  _matchesStrictComparable = matchesStrictComparable;
  return _matchesStrictComparable;
}
var _baseMatches;
var hasRequired_baseMatches;
function require_baseMatches() {
  if (hasRequired_baseMatches)
    return _baseMatches;
  hasRequired_baseMatches = 1;
  var baseIsMatch = require_baseIsMatch(), getMatchData = require_getMatchData(), matchesStrictComparable = require_matchesStrictComparable();
  function baseMatches(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function(object) {
      return object === source || baseIsMatch(object, source, matchData);
    };
  }
  _baseMatches = baseMatches;
  return _baseMatches;
}
var _isKey;
var hasRequired_isKey;
function require_isKey() {
  if (hasRequired_isKey)
    return _isKey;
  hasRequired_isKey = 1;
  var isArray2 = requireIsArray(), isSymbol = requireIsSymbol();
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
  function isKey(value, object) {
    if (isArray2(value)) {
      return false;
    }
    var type2 = typeof value;
    if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }
  _isKey = isKey;
  return _isKey;
}
var memoize_1;
var hasRequiredMemoize;
function requireMemoize() {
  if (hasRequiredMemoize)
    return memoize_1;
  hasRequiredMemoize = 1;
  var MapCache = require_MapCache();
  var FUNC_ERROR_TEXT = "Expected a function";
  function memoize(func, resolver) {
    if (typeof func != "function" || resolver != null && typeof resolver != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
      var args2 = arguments, key = resolver ? resolver.apply(this, args2) : args2[0], cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args2);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
  }
  memoize.Cache = MapCache;
  memoize_1 = memoize;
  return memoize_1;
}
var _memoizeCapped;
var hasRequired_memoizeCapped;
function require_memoizeCapped() {
  if (hasRequired_memoizeCapped)
    return _memoizeCapped;
  hasRequired_memoizeCapped = 1;
  var memoize = requireMemoize();
  var MAX_MEMOIZE_SIZE = 500;
  function memoizeCapped(func) {
    var result = memoize(func, function(key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key;
    });
    var cache = result.cache;
    return result;
  }
  _memoizeCapped = memoizeCapped;
  return _memoizeCapped;
}
var _stringToPath;
var hasRequired_stringToPath;
function require_stringToPath() {
  if (hasRequired_stringToPath)
    return _stringToPath;
  hasRequired_stringToPath = 1;
  var memoizeCapped = require_memoizeCapped();
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = memoizeCapped(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46) {
      result.push("");
    }
    string.replace(rePropName, function(match2, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match2);
    });
    return result;
  });
  _stringToPath = stringToPath;
  return _stringToPath;
}
var _baseToString;
var hasRequired_baseToString;
function require_baseToString() {
  if (hasRequired_baseToString)
    return _baseToString;
  hasRequired_baseToString = 1;
  var Symbol2 = require_Symbol(), arrayMap = require_arrayMap(), isArray2 = requireIsArray(), isSymbol = requireIsSymbol();
  var INFINITY = 1 / 0;
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isArray2(value)) {
      return arrayMap(value, baseToString) + "";
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  _baseToString = baseToString;
  return _baseToString;
}
var toString_1;
var hasRequiredToString;
function requireToString() {
  if (hasRequiredToString)
    return toString_1;
  hasRequiredToString = 1;
  var baseToString = require_baseToString();
  function toString2(value) {
    return value == null ? "" : baseToString(value);
  }
  toString_1 = toString2;
  return toString_1;
}
var _castPath;
var hasRequired_castPath;
function require_castPath() {
  if (hasRequired_castPath)
    return _castPath;
  hasRequired_castPath = 1;
  var isArray2 = requireIsArray(), isKey = require_isKey(), stringToPath = require_stringToPath(), toString2 = requireToString();
  function castPath(value, object) {
    if (isArray2(value)) {
      return value;
    }
    return isKey(value, object) ? [value] : stringToPath(toString2(value));
  }
  _castPath = castPath;
  return _castPath;
}
var _toKey;
var hasRequired_toKey;
function require_toKey() {
  if (hasRequired_toKey)
    return _toKey;
  hasRequired_toKey = 1;
  var isSymbol = requireIsSymbol();
  var INFINITY = 1 / 0;
  function toKey(value) {
    if (typeof value == "string" || isSymbol(value)) {
      return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  _toKey = toKey;
  return _toKey;
}
var _baseGet;
var hasRequired_baseGet;
function require_baseGet() {
  if (hasRequired_baseGet)
    return _baseGet;
  hasRequired_baseGet = 1;
  var castPath = require_castPath(), toKey = require_toKey();
  function baseGet(object, path) {
    path = castPath(path, object);
    var index = 0, length2 = path.length;
    while (object != null && index < length2) {
      object = object[toKey(path[index++])];
    }
    return index && index == length2 ? object : void 0;
  }
  _baseGet = baseGet;
  return _baseGet;
}
var get_1;
var hasRequiredGet;
function requireGet() {
  if (hasRequiredGet)
    return get_1;
  hasRequiredGet = 1;
  var baseGet = require_baseGet();
  function get(object, path, defaultValue) {
    var result = object == null ? void 0 : baseGet(object, path);
    return result === void 0 ? defaultValue : result;
  }
  get_1 = get;
  return get_1;
}
var _baseHasIn;
var hasRequired_baseHasIn;
function require_baseHasIn() {
  if (hasRequired_baseHasIn)
    return _baseHasIn;
  hasRequired_baseHasIn = 1;
  function baseHasIn(object, key) {
    return object != null && key in Object(object);
  }
  _baseHasIn = baseHasIn;
  return _baseHasIn;
}
var _hasPath;
var hasRequired_hasPath;
function require_hasPath() {
  if (hasRequired_hasPath)
    return _hasPath;
  hasRequired_hasPath = 1;
  var castPath = require_castPath(), isArguments = requireIsArguments(), isArray2 = requireIsArray(), isIndex = require_isIndex(), isLength = requireIsLength(), toKey = require_toKey();
  function hasPath(object, path, hasFunc) {
    path = castPath(path, object);
    var index = -1, length2 = path.length, result = false;
    while (++index < length2) {
      var key = toKey(path[index]);
      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }
      object = object[key];
    }
    if (result || ++index != length2) {
      return result;
    }
    length2 = object == null ? 0 : object.length;
    return !!length2 && isLength(length2) && isIndex(key, length2) && (isArray2(object) || isArguments(object));
  }
  _hasPath = hasPath;
  return _hasPath;
}
var hasIn_1;
var hasRequiredHasIn;
function requireHasIn() {
  if (hasRequiredHasIn)
    return hasIn_1;
  hasRequiredHasIn = 1;
  var baseHasIn = require_baseHasIn(), hasPath = require_hasPath();
  function hasIn(object, path) {
    return object != null && hasPath(object, path, baseHasIn);
  }
  hasIn_1 = hasIn;
  return hasIn_1;
}
var _baseMatchesProperty;
var hasRequired_baseMatchesProperty;
function require_baseMatchesProperty() {
  if (hasRequired_baseMatchesProperty)
    return _baseMatchesProperty;
  hasRequired_baseMatchesProperty = 1;
  var baseIsEqual = require_baseIsEqual(), get = requireGet(), hasIn = requireHasIn(), isKey = require_isKey(), isStrictComparable = require_isStrictComparable(), matchesStrictComparable = require_matchesStrictComparable(), toKey = require_toKey();
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  function baseMatchesProperty(path, srcValue) {
    if (isKey(path) && isStrictComparable(srcValue)) {
      return matchesStrictComparable(toKey(path), srcValue);
    }
    return function(object) {
      var objValue = get(object, path);
      return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
    };
  }
  _baseMatchesProperty = baseMatchesProperty;
  return _baseMatchesProperty;
}
var _baseProperty;
var hasRequired_baseProperty;
function require_baseProperty() {
  if (hasRequired_baseProperty)
    return _baseProperty;
  hasRequired_baseProperty = 1;
  function baseProperty(key) {
    return function(object) {
      return object == null ? void 0 : object[key];
    };
  }
  _baseProperty = baseProperty;
  return _baseProperty;
}
var _basePropertyDeep;
var hasRequired_basePropertyDeep;
function require_basePropertyDeep() {
  if (hasRequired_basePropertyDeep)
    return _basePropertyDeep;
  hasRequired_basePropertyDeep = 1;
  var baseGet = require_baseGet();
  function basePropertyDeep(path) {
    return function(object) {
      return baseGet(object, path);
    };
  }
  _basePropertyDeep = basePropertyDeep;
  return _basePropertyDeep;
}
var property_1;
var hasRequiredProperty;
function requireProperty() {
  if (hasRequiredProperty)
    return property_1;
  hasRequiredProperty = 1;
  var baseProperty = require_baseProperty(), basePropertyDeep = require_basePropertyDeep(), isKey = require_isKey(), toKey = require_toKey();
  function property(path) {
    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
  }
  property_1 = property;
  return property_1;
}
var _baseIteratee;
var hasRequired_baseIteratee;
function require_baseIteratee() {
  if (hasRequired_baseIteratee)
    return _baseIteratee;
  hasRequired_baseIteratee = 1;
  var baseMatches = require_baseMatches(), baseMatchesProperty = require_baseMatchesProperty(), identity2 = requireIdentity(), isArray2 = requireIsArray(), property = requireProperty();
  function baseIteratee(value) {
    if (typeof value == "function") {
      return value;
    }
    if (value == null) {
      return identity2;
    }
    if (typeof value == "object") {
      return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
    }
    return property(value);
  }
  _baseIteratee = baseIteratee;
  return _baseIteratee;
}
var filter_1;
var hasRequiredFilter;
function requireFilter() {
  if (hasRequiredFilter)
    return filter_1;
  hasRequiredFilter = 1;
  var arrayFilter = require_arrayFilter(), baseFilter = require_baseFilter(), baseIteratee = require_baseIteratee(), isArray2 = requireIsArray();
  function filter2(collection, predicate) {
    var func = isArray2(collection) ? arrayFilter : baseFilter;
    return func(collection, baseIteratee(predicate, 3));
  }
  filter_1 = filter2;
  return filter_1;
}
var _baseFindKey;
var hasRequired_baseFindKey;
function require_baseFindKey() {
  if (hasRequired_baseFindKey)
    return _baseFindKey;
  hasRequired_baseFindKey = 1;
  function baseFindKey(collection, predicate, eachFunc) {
    var result;
    eachFunc(collection, function(value, key, collection2) {
      if (predicate(value, key, collection2)) {
        result = key;
        return false;
      }
    });
    return result;
  }
  _baseFindKey = baseFindKey;
  return _baseFindKey;
}
var findKey_1;
var hasRequiredFindKey;
function requireFindKey() {
  if (hasRequiredFindKey)
    return findKey_1;
  hasRequiredFindKey = 1;
  var baseFindKey = require_baseFindKey(), baseForOwn = require_baseForOwn(), baseIteratee = require_baseIteratee();
  function findKey(object, predicate) {
    return baseFindKey(object, baseIteratee(predicate, 3), baseForOwn);
  }
  findKey_1 = findKey;
  return findKey_1;
}
var head_1;
var hasRequiredHead;
function requireHead() {
  if (hasRequiredHead)
    return head_1;
  hasRequiredHead = 1;
  function head(array) {
    return array && array.length ? array[0] : void 0;
  }
  head_1 = head;
  return head_1;
}
var first;
var hasRequiredFirst;
function requireFirst() {
  if (hasRequiredFirst)
    return first;
  hasRequiredFirst = 1;
  first = requireHead();
  return first;
}
var _arrayEach;
var hasRequired_arrayEach;
function require_arrayEach() {
  if (hasRequired_arrayEach)
    return _arrayEach;
  hasRequired_arrayEach = 1;
  function arrayEach(array, iteratee) {
    var index = -1, length2 = array == null ? 0 : array.length;
    while (++index < length2) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }
  _arrayEach = arrayEach;
  return _arrayEach;
}
var _castFunction;
var hasRequired_castFunction;
function require_castFunction() {
  if (hasRequired_castFunction)
    return _castFunction;
  hasRequired_castFunction = 1;
  var identity2 = requireIdentity();
  function castFunction(value) {
    return typeof value == "function" ? value : identity2;
  }
  _castFunction = castFunction;
  return _castFunction;
}
var forEach_1;
var hasRequiredForEach;
function requireForEach() {
  if (hasRequiredForEach)
    return forEach_1;
  hasRequiredForEach = 1;
  var arrayEach = require_arrayEach(), baseEach = require_baseEach(), castFunction = require_castFunction(), isArray2 = requireIsArray();
  function forEach(collection, iteratee) {
    var func = isArray2(collection) ? arrayEach : baseEach;
    return func(collection, castFunction(iteratee));
  }
  forEach_1 = forEach;
  return forEach_1;
}
var forOwn_1;
var hasRequiredForOwn;
function requireForOwn() {
  if (hasRequiredForOwn)
    return forOwn_1;
  hasRequiredForOwn = 1;
  var baseForOwn = require_baseForOwn(), castFunction = require_castFunction();
  function forOwn(object, iteratee) {
    return object && baseForOwn(object, castFunction(iteratee));
  }
  forOwn_1 = forOwn;
  return forOwn_1;
}
var noop_1;
var hasRequiredNoop;
function requireNoop() {
  if (hasRequiredNoop)
    return noop_1;
  hasRequiredNoop = 1;
  function noop2() {
  }
  noop_1 = noop2;
  return noop_1;
}
var _baseMap;
var hasRequired_baseMap;
function require_baseMap() {
  if (hasRequired_baseMap)
    return _baseMap;
  hasRequired_baseMap = 1;
  var baseEach = require_baseEach(), isArrayLike2 = requireIsArrayLike();
  function baseMap(collection, iteratee) {
    var index = -1, result = isArrayLike2(collection) ? Array(collection.length) : [];
    baseEach(collection, function(value, key, collection2) {
      result[++index] = iteratee(value, key, collection2);
    });
    return result;
  }
  _baseMap = baseMap;
  return _baseMap;
}
var _baseSortBy;
var hasRequired_baseSortBy;
function require_baseSortBy() {
  if (hasRequired_baseSortBy)
    return _baseSortBy;
  hasRequired_baseSortBy = 1;
  function baseSortBy(array, comparer) {
    var length2 = array.length;
    array.sort(comparer);
    while (length2--) {
      array[length2] = array[length2].value;
    }
    return array;
  }
  _baseSortBy = baseSortBy;
  return _baseSortBy;
}
var _compareAscending;
var hasRequired_compareAscending;
function require_compareAscending() {
  if (hasRequired_compareAscending)
    return _compareAscending;
  hasRequired_compareAscending = 1;
  var isSymbol = requireIsSymbol();
  function compareAscending(value, other) {
    if (value !== other) {
      var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
      var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
      if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
        return 1;
      }
      if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
        return -1;
      }
    }
    return 0;
  }
  _compareAscending = compareAscending;
  return _compareAscending;
}
var _compareMultiple;
var hasRequired_compareMultiple;
function require_compareMultiple() {
  if (hasRequired_compareMultiple)
    return _compareMultiple;
  hasRequired_compareMultiple = 1;
  var compareAscending = require_compareAscending();
  function compareMultiple(object, other, orders) {
    var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length2 = objCriteria.length, ordersLength = orders.length;
    while (++index < length2) {
      var result = compareAscending(objCriteria[index], othCriteria[index]);
      if (result) {
        if (index >= ordersLength) {
          return result;
        }
        var order = orders[index];
        return result * (order == "desc" ? -1 : 1);
      }
    }
    return object.index - other.index;
  }
  _compareMultiple = compareMultiple;
  return _compareMultiple;
}
var _baseOrderBy;
var hasRequired_baseOrderBy;
function require_baseOrderBy() {
  if (hasRequired_baseOrderBy)
    return _baseOrderBy;
  hasRequired_baseOrderBy = 1;
  var arrayMap = require_arrayMap(), baseGet = require_baseGet(), baseIteratee = require_baseIteratee(), baseMap = require_baseMap(), baseSortBy = require_baseSortBy(), baseUnary = require_baseUnary(), compareMultiple = require_compareMultiple(), identity2 = requireIdentity(), isArray2 = requireIsArray();
  function baseOrderBy(collection, iteratees, orders) {
    if (iteratees.length) {
      iteratees = arrayMap(iteratees, function(iteratee) {
        if (isArray2(iteratee)) {
          return function(value) {
            return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
          };
        }
        return iteratee;
      });
    } else {
      iteratees = [identity2];
    }
    var index = -1;
    iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
    var result = baseMap(collection, function(value, key, collection2) {
      var criteria = arrayMap(iteratees, function(iteratee) {
        return iteratee(value);
      });
      return { "criteria": criteria, "index": ++index, "value": value };
    });
    return baseSortBy(result, function(object, other) {
      return compareMultiple(object, other, orders);
    });
  }
  _baseOrderBy = baseOrderBy;
  return _baseOrderBy;
}
var _isIterateeCall;
var hasRequired_isIterateeCall;
function require_isIterateeCall() {
  if (hasRequired_isIterateeCall)
    return _isIterateeCall;
  hasRequired_isIterateeCall = 1;
  var eq = requireEq(), isArrayLike2 = requireIsArrayLike(), isIndex = require_isIndex(), isObject2 = requireIsObject();
  function isIterateeCall(value, index, object) {
    if (!isObject2(object)) {
      return false;
    }
    var type2 = typeof index;
    if (type2 == "number" ? isArrayLike2(object) && isIndex(index, object.length) : type2 == "string" && index in object) {
      return eq(object[index], value);
    }
    return false;
  }
  _isIterateeCall = isIterateeCall;
  return _isIterateeCall;
}
var sortBy_1;
var hasRequiredSortBy;
function requireSortBy() {
  if (hasRequiredSortBy)
    return sortBy_1;
  hasRequiredSortBy = 1;
  var baseFlatten = require_baseFlatten(), baseOrderBy = require_baseOrderBy(), baseRest = require_baseRest(), isIterateeCall = require_isIterateeCall();
  var sortBy2 = baseRest(function(collection, iteratees) {
    if (collection == null) {
      return [];
    }
    var length2 = iteratees.length;
    if (length2 > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
      iteratees = [];
    } else if (length2 > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
      iteratees = [iteratees[0]];
    }
    return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
  });
  sortBy_1 = sortBy2;
  return sortBy_1;
}
var throttle_1;
var hasRequiredThrottle;
function requireThrottle() {
  if (hasRequiredThrottle)
    return throttle_1;
  hasRequiredThrottle = 1;
  var debounce2 = requireDebounce(), isObject2 = requireIsObject();
  var FUNC_ERROR_TEXT = "Expected a function";
  function throttle2(func, wait, options) {
    var leading = true, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    if (isObject2(options)) {
      leading = "leading" in options ? !!options.leading : leading;
      trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    return debounce2(func, wait, {
      "leading": leading,
      "maxWait": wait,
      "trailing": trailing
    });
  }
  throttle_1 = throttle2;
  return throttle_1;
}
var uniqueId_1;
var hasRequiredUniqueId;
function requireUniqueId() {
  if (hasRequiredUniqueId)
    return uniqueId_1;
  hasRequiredUniqueId = 1;
  var toString2 = requireToString();
  var idCounter = 0;
  function uniqueId(prefix2) {
    var id2 = ++idCounter;
    return toString2(prefix2) + id2;
  }
  uniqueId_1 = uniqueId;
  return uniqueId_1;
}
(function(module, exports) {
  !function(e2, t2) {
    module.exports = t2(requireDebounce(), requireDifference(), requireFilter(), requireFindKey(), requireFirst(), requireForEach(), requireForOwn(), requireNoop(), requireSortBy(), requireThrottle(), requireUniqueId(), reactExports);
  }(commonjsGlobal, function(e2, t2, o, s, i, n2, r2, a, u2, c, l2, d) {
    return function() {
      var h2 = { 654: function(e3, t3, o2) {
        var s2, i2 = this && this.__assign || function() {
          return i2 = Object.assign || function(e4) {
            for (var t4, o3 = 1, s3 = arguments.length; o3 < s3; o3++)
              for (var i3 in t4 = arguments[o3])
                Object.prototype.hasOwnProperty.call(t4, i3) && (e4[i3] = t4[i3]);
            return e4;
          }, i2.apply(this, arguments);
        }, n3 = this && this.__createBinding || (Object.create ? function(e4, t4, o3, s3) {
          void 0 === s3 && (s3 = o3);
          var i3 = Object.getOwnPropertyDescriptor(t4, o3);
          i3 && !("get" in i3 ? !t4.__esModule : i3.writable || i3.configurable) || (i3 = { enumerable: true, get: function() {
            return t4[o3];
          } }), Object.defineProperty(e4, s3, i3);
        } : function(e4, t4, o3, s3) {
          void 0 === s3 && (s3 = o3), e4[s3] = t4[o3];
        }), r3 = this && this.__setModuleDefault || (Object.create ? function(e4, t4) {
          Object.defineProperty(e4, "default", { enumerable: true, value: t4 });
        } : function(e4, t4) {
          e4.default = t4;
        }), a2 = this && this.__importStar || function(e4) {
          if (e4 && e4.__esModule)
            return e4;
          var t4 = {};
          if (null != e4)
            for (var o3 in e4)
              "default" !== o3 && Object.prototype.hasOwnProperty.call(e4, o3) && n3(t4, e4, o3);
          return r3(t4, e4), t4;
        }, u3 = this && this.__spreadArray || function(e4, t4, o3) {
          if (o3 || 2 === arguments.length)
            for (var s3, i3 = 0, n4 = t4.length; i3 < n4; i3++)
              !s3 && i3 in t4 || (s3 || (s3 = Array.prototype.slice.call(t4, 0, i3)), s3[i3] = t4[i3]);
          return e4.concat(s3 || Array.prototype.slice.call(t4));
        }, c2 = this && this.__importDefault || function(e4) {
          return e4 && e4.__esModule ? e4 : { default: e4 };
        };
        Object.defineProperty(t3, "__esModule", { value: true }), t3.doesFocusableExist = t3.getCurrentFocusKey = t3.updateAllLayouts = t3.resume = t3.pause = t3.navigateByDirection = t3.setFocus = t3.setKeyMap = t3.destroy = t3.setThrottle = t3.init = t3.SpatialNavigation = t3.ROOT_FOCUS_KEY = void 0;
        var l3 = c2(o2(150)), d2 = c2(o2(117)), h3 = c2(o2(747)), f3 = c2(o2(23)), p2 = c2(o2(842)), y2 = c2(o2(682)), v2 = c2(o2(784)), g2 = c2(o2(432)), b2 = c2(o2(67)), F2 = c2(o2(35)), C2 = c2(o2(119)), K2 = a2(o2(964)), m2 = "left", w2 = "right", x2 = "up", E2 = "down", D2 = "enter", L2 = ((s2 = {}).left = [37, "ArrowLeft"], s2.up = [38, "ArrowUp"], s2.right = [39, "ArrowRight"], s2.down = [40, "ArrowDown"], s2.enter = [13, "Enter"], s2);
        t3.ROOT_FOCUS_KEY = "SN:ROOT";
        var P2 = ["#0FF", "#FF0", "#F0F"], N2 = { leading: true, trailing: false }, B2 = function() {
          function e4() {
            this.focusableComponents = {}, this.focusKey = null, this.parentsHavingFocusedChild = [], this.enabled = false, this.nativeMode = false, this.throttle = 0, this.throttleKeypresses = false, this.useGetBoundingClientRect = false, this.shouldFocusDOMNode = false, this.shouldUseNativeEvents = false, this.writingDirection = C2.default.LTR, this.pressedKeys = {}, this.paused = false, this.keyDownEventListener = null, this.keyUpEventListener = null, this.keyMap = L2, this.onKeyEvent = this.onKeyEvent.bind(this), this.pause = this.pause.bind(this), this.resume = this.resume.bind(this), this.setFocus = this.setFocus.bind(this), this.updateAllLayouts = this.updateAllLayouts.bind(this), this.navigateByDirection = this.navigateByDirection.bind(this), this.init = this.init.bind(this), this.setThrottle = this.setThrottle.bind(this), this.destroy = this.destroy.bind(this), this.setKeyMap = this.setKeyMap.bind(this), this.getCurrentFocusKey = this.getCurrentFocusKey.bind(this), this.doesFocusableExist = this.doesFocusableExist.bind(this), this.setFocusDebounced = (0, l3.default)(this.setFocus, 300, { leading: false, trailing: true }), this.debug = false, this.visualDebugger = null, this.logIndex = 0;
          }
          return e4.getCutoffCoordinate = function(e5, t4, o3, s3, i3) {
            var n4 = e5 ? s3.top : i3 === C2.default.LTR ? s3.left : s3.right, r4 = e5 ? s3.bottom : i3 === C2.default.LTR ? s3.right : s3.left;
            return t4 ? o3 ? n4 : r4 : o3 ? r4 : n4;
          }, e4.getRefCorners = function(e5, t4, o3) {
            var s3 = { a: { x: 0, y: 0 }, b: { x: 0, y: 0 } };
            switch (e5) {
              case x2:
                var i3 = t4 ? o3.bottom : o3.top;
                s3.a = { x: o3.left, y: i3 }, s3.b = { x: o3.right, y: i3 };
                break;
              case E2:
                i3 = t4 ? o3.top : o3.bottom, s3.a = { x: o3.left, y: i3 }, s3.b = { x: o3.right, y: i3 };
                break;
              case m2:
                var n4 = t4 ? o3.right : o3.left;
                s3.a = { x: n4, y: o3.top }, s3.b = { x: n4, y: o3.bottom };
                break;
              case w2:
                n4 = t4 ? o3.left : o3.right, s3.a = { x: n4, y: o3.top }, s3.b = { x: n4, y: o3.bottom };
            }
            return s3;
          }, e4.isAdjacentSlice = function(e5, t4, o3) {
            var s3 = e5.a, i3 = e5.b, n4 = t4.a, r4 = t4.b, a3 = o3 ? "x" : "y", u4 = s3[a3], c3 = i3[a3], l4 = n4[a3], d3 = r4[a3], h4 = 0.2 * (c3 - u4);
            return Math.max(0, Math.min(c3, d3) - Math.max(u4, l4)) >= h4;
          }, e4.getPrimaryAxisDistance = function(e5, t4, o3) {
            var s3 = e5.a, i3 = t4.a, n4 = o3 ? "y" : "x";
            return Math.abs(i3[n4] - s3[n4]);
          }, e4.getSecondaryAxisDistance = function(e5, t4, o3) {
            var s3 = e5.a, i3 = e5.b, n4 = t4.a, r4 = t4.b, a3 = o3 ? "x" : "y", u4 = s3[a3], c3 = i3[a3], l4 = n4[a3], d3 = r4[a3], h4 = [];
            return h4.push(Math.abs(l4 - u4)), h4.push(Math.abs(l4 - c3)), h4.push(Math.abs(d3 - u4)), h4.push(Math.abs(d3 - c3)), Math.min.apply(Math, h4);
          }, e4.prototype.sortSiblingsByPriority = function(t4, o3, s3, i3) {
            var n4 = this, r4 = s3 === E2 || s3 === x2, a3 = e4.getRefCorners(s3, false, o3);
            return (0, g2.default)(t4, function(t5) {
              var o4 = e4.getRefCorners(s3, true, t5.layout), u4 = e4.isAdjacentSlice(a3, o4, r4), c3 = u4 ? e4.getPrimaryAxisDistance : e4.getSecondaryAxisDistance, l4 = u4 ? e4.getSecondaryAxisDistance : e4.getPrimaryAxisDistance, d3 = c3(a3, o4, r4), h4 = l4(a3, o4, r4), f4 = 5 * d3 + h4, p3 = (f4 + 1) / (u4 ? 5 : 1);
              return n4.log("smartNavigate", "distance (primary, secondary, total weighted) for ".concat(t5.focusKey, " relative to ").concat(i3, " is"), d3, h4, f4), n4.log("smartNavigate", "priority for ".concat(t5.focusKey, " relative to ").concat(i3, " is"), p3), n4.visualDebugger && (n4.visualDebugger.drawPoint(o4.a.x, o4.a.y, "yellow", 6), n4.visualDebugger.drawPoint(o4.b.x, o4.b.y, "yellow", 6)), p3;
            });
          }, e4.prototype.init = function(e5) {
            var t4 = void 0 === e5 ? {} : e5, o3 = t4.debug, s3 = void 0 !== o3 && o3, i3 = t4.visualDebug, n4 = void 0 !== i3 && i3, r4 = t4.nativeMode, a3 = void 0 !== r4 && r4, u4 = t4.throttle, c3 = void 0 === u4 ? 0 : u4, l4 = t4.throttleKeypresses, d3 = void 0 !== l4 && l4, h4 = t4.useGetBoundingClientRect, f4 = void 0 !== h4 && h4, p3 = t4.shouldFocusDOMNode, y3 = void 0 !== p3 && p3, v3 = t4.shouldUseNativeEvents, g3 = void 0 !== v3 && v3, b3 = t4.rtl, K3 = void 0 !== b3 && b3;
            this.enabled || (this.enabled = true, this.nativeMode = a3, this.throttleKeypresses = d3, this.useGetBoundingClientRect = f4, this.shouldFocusDOMNode = y3 && !a3, this.shouldUseNativeEvents = g3, this.writingDirection = K3 ? C2.default.RTL : C2.default.LTR, this.debug = s3, this.nativeMode || (Number.isInteger(c3) && c3 > 0 && (this.throttle = c3), this.bindEventHandlers(), n4 && (this.visualDebugger = new F2.default(this.writingDirection), this.startDrawLayouts())));
          }, e4.prototype.setThrottle = function(e5) {
            var t4 = void 0 === e5 ? {} : e5, o3 = t4.throttle, s3 = void 0 === o3 ? 0 : o3, i3 = t4.throttleKeypresses, n4 = void 0 !== i3 && i3;
            this.throttleKeypresses = n4, this.nativeMode || (this.unbindEventHandlers(), Number.isInteger(s3) && (this.throttle = s3), this.bindEventHandlers());
          }, e4.prototype.startDrawLayouts = function() {
            var e5 = this, t4 = function() {
              requestAnimationFrame(function() {
                e5.visualDebugger.clearLayouts(), (0, v2.default)(e5.focusableComponents, function(t5, o3) {
                  e5.visualDebugger.drawLayout(t5.layout, o3, t5.parentFocusKey);
                }), t4();
              });
            };
            t4();
          }, e4.prototype.destroy = function() {
            this.enabled && (this.enabled = false, this.nativeMode = false, this.throttle = 0, this.throttleKeypresses = false, this.focusKey = null, this.parentsHavingFocusedChild = [], this.focusableComponents = {}, this.paused = false, this.keyMap = L2, this.unbindEventHandlers());
          }, e4.prototype.getEventType = function(e5) {
            return (0, f3.default)(this.getKeyMap(), function(t4) {
              return t4.includes(e5);
            });
          }, e4.getKeyCode = function(e5) {
            return e5.keyCode || e5.code;
          }, e4.prototype.bindEventHandlers = function() {
            var t4 = this;
            "undefined" != typeof window && window.addEventListener && (this.keyDownEventListener = function(o3) {
              if (true !== t4.paused) {
                t4.debug && (t4.logIndex += 1);
                var s3 = e4.getKeyCode(o3), i3 = t4.getEventType(s3);
                if (i3) {
                  t4.pressedKeys[i3] = t4.pressedKeys[i3] ? t4.pressedKeys[i3] + 1 : 1, t4.shouldUseNativeEvents || (o3.preventDefault(), o3.stopPropagation());
                  var n4 = { pressedKeys: t4.pressedKeys };
                  i3 === D2 && t4.focusKey ? t4.onEnterPress(n4) : false === t4.onArrowPress(i3, n4) ? (t4.log("keyDownEventListener", "default navigation prevented"), t4.visualDebugger && t4.visualDebugger.clear()) : t4.onKeyEvent(o3);
                }
              }
            }, this.throttle && (this.keyDownEventListenerThrottled = (0, b2.default)(this.keyDownEventListener.bind(this), this.throttle, N2)), this.keyUpEventListener = function(o3) {
              var s3 = e4.getKeyCode(o3), i3 = t4.getEventType(s3);
              delete t4.pressedKeys[i3], t4.throttle && !t4.throttleKeypresses && t4.keyDownEventListenerThrottled.cancel(), i3 === D2 && t4.focusKey && t4.onEnterRelease();
            }, window.addEventListener("keyup", this.keyUpEventListener), window.addEventListener("keydown", this.throttle ? this.keyDownEventListenerThrottled : this.keyDownEventListener));
          }, e4.prototype.unbindEventHandlers = function() {
            if ("undefined" != typeof window && window.removeEventListener) {
              window.removeEventListener("keyup", this.keyUpEventListener), this.keyUpEventListener = null;
              var e5 = this.throttle ? this.keyDownEventListenerThrottled : this.keyDownEventListener;
              window.removeEventListener("keydown", e5), this.keyDownEventListener = null;
            }
          }, e4.prototype.onEnterPress = function(e5) {
            var t4 = this.focusableComponents[this.focusKey];
            t4 ? t4.focusable ? t4.onEnterPress && t4.onEnterPress(e5) : this.log("onEnterPress", "componentNotFocusable") : this.log("onEnterPress", "noComponent");
          }, e4.prototype.onEnterRelease = function() {
            var e5 = this.focusableComponents[this.focusKey];
            e5 ? e5.focusable ? e5.onEnterRelease && e5.onEnterRelease() : this.log("onEnterRelease", "componentNotFocusable") : this.log("onEnterRelease", "noComponent");
          }, e4.prototype.onArrowPress = function(e5, t4) {
            var o3 = this.focusableComponents[this.focusKey];
            if (o3)
              return o3 && o3.onArrowPress && o3.onArrowPress(e5, t4);
            this.log("onArrowPress", "noComponent");
          }, e4.prototype.navigateByDirection = function(e5, t4) {
            if (true !== this.paused && this.enabled && !this.nativeMode) {
              var o3 = [E2, x2, m2, w2];
              o3.includes(e5) ? (this.log("navigateByDirection", "direction", e5), this.smartNavigate(e5, null, t4)) : this.log("navigateByDirection", "Invalid direction. You passed: `".concat(e5, "`, but you can use only these: "), o3);
            }
          }, e4.prototype.onKeyEvent = function(t4) {
            this.visualDebugger && this.visualDebugger.clear();
            var o3 = e4.getKeyCode(t4), s3 = (0, f3.default)(this.getKeyMap(), function(e5) {
              return e5.includes(o3);
            });
            this.smartNavigate(s3, null, { event: t4 });
          }, e4.prototype.smartNavigate = function(t4, o3, s3) {
            var i3 = this;
            if (!this.nativeMode) {
              var n4 = t4 === E2 || t4 === x2, r4 = t4 === E2 || (this.writingDirection === C2.default.LTR ? t4 === w2 : t4 === m2);
              this.log("smartNavigate", "direction", t4), this.log("smartNavigate", "fromParentFocusKey", o3), this.log("smartNavigate", "this.focusKey", this.focusKey), o3 || (0, v2.default)(this.focusableComponents, function(e5) {
                e5.layoutUpdated = false;
              });
              var a3 = this.focusableComponents[o3 || this.focusKey];
              if (o3 || a3) {
                if (this.log("smartNavigate", "currentComponent", a3 ? a3.focusKey : void 0, a3 ? a3.node : void 0, a3), a3) {
                  this.updateLayout(a3.focusKey);
                  var u4 = a3.parentFocusKey, c3 = a3.focusKey, l4 = a3.layout, d3 = e4.getCutoffCoordinate(n4, r4, false, l4, this.writingDirection), f4 = (0, h3.default)(this.focusableComponents, function(t5) {
                    if (t5.parentFocusKey === u4 && t5.focusable) {
                      i3.updateLayout(t5.focusKey);
                      var o4 = e4.getCutoffCoordinate(n4, r4, true, t5.layout, i3.writingDirection);
                      return n4 || i3.writingDirection === C2.default.LTR ? r4 ? o4 >= d3 : o4 <= d3 : r4 ? o4 <= d3 : o4 >= d3;
                    }
                    return false;
                  });
                  if (this.debug && (this.log("smartNavigate", "currentCutoffCoordinate", d3), this.log("smartNavigate", "siblings", "".concat(f4.length, " elements:"), f4.map(function(e5) {
                    return e5.focusKey;
                  }).join(", "), f4.map(function(e5) {
                    return e5.node;
                  }), f4.map(function(e5) {
                    return e5;
                  }))), this.visualDebugger) {
                    var y3 = e4.getRefCorners(t4, false, l4);
                    this.visualDebugger.drawPoint(y3.a.x, y3.a.y), this.visualDebugger.drawPoint(y3.b.x, y3.b.y);
                  }
                  var g3 = this.sortSiblingsByPriority(f4, l4, t4, c3), b3 = (0, p2.default)(g3);
                  if (this.log("smartNavigate", "nextComponent", b3 ? b3.focusKey : void 0, b3 ? b3.node : void 0, b3), b3)
                    this.setFocus(b3.focusKey, s3);
                  else {
                    var F3 = this.focusableComponents[u4], K3 = (null == F3 ? void 0 : F3.isFocusBoundary) ? F3.focusBoundaryDirections || [t4] : [];
                    F3 && K3.includes(t4) || this.smartNavigate(t4, u4, s3);
                  }
                }
              } else
                this.setFocus(this.getForcedFocusKey());
            }
          }, e4.prototype.saveLastFocusedChildKey = function(e5, t4) {
            e5 && (this.log("saveLastFocusedChildKey", "".concat(e5.focusKey, " lastFocusedChildKey set"), t4), e5.lastFocusedChildKey = t4);
          }, e4.prototype.log = function(e5, t4) {
            for (var o3 = [], s3 = 2; s3 < arguments.length; s3++)
              o3[s3 - 2] = arguments[s3];
            this.debug && console.log.apply(console, u3(["%c".concat(e5, "%c").concat(t4), "background: ".concat(P2[this.logIndex % P2.length], "; color: black; padding: 1px 5px;"), "background: #333; color: #BADA55; padding: 1px 5px;"], o3, false));
          }, e4.prototype.getCurrentFocusKey = function() {
            return this.focusKey;
          }, e4.prototype.getForcedFocusKey = function() {
            var e5, o3 = (0, h3.default)(this.focusableComponents, function(e6) {
              return e6.focusable && e6.forceFocus;
            }), s3 = this.sortSiblingsByPriority(o3, { x: 0, y: 0, width: 0, height: 0, left: 0, top: 0, right: 0, bottom: 0, node: null }, "down", t3.ROOT_FOCUS_KEY);
            return null === (e5 = (0, p2.default)(s3)) || void 0 === e5 ? void 0 : e5.focusKey;
          }, e4.prototype.getNextFocusKey = function(e5) {
            var t4 = this, o3 = this.focusableComponents[e5];
            if (!o3 || this.nativeMode)
              return e5;
            var s3 = (0, h3.default)(this.focusableComponents, function(t5) {
              return t5.parentFocusKey === e5 && t5.focusable;
            });
            if (s3.length > 0) {
              var i3 = o3.lastFocusedChildKey, n4 = o3.preferredChildFocusKey;
              if (this.log("getNextFocusKey", "lastFocusedChildKey is", i3), this.log("getNextFocusKey", "preferredChildFocusKey is", n4), i3 && o3.saveLastFocusedChild && this.isParticipatingFocusableComponent(i3))
                return this.log("getNextFocusKey", "lastFocusedChildKey will be focused", i3), this.getNextFocusKey(i3);
              if (n4 && this.isParticipatingFocusableComponent(n4))
                return this.log("getNextFocusKey", "preferredChildFocusKey will be focused", n4), this.getNextFocusKey(n4);
              s3.forEach(function(e6) {
                return t4.updateLayout(e6.focusKey);
              });
              var r4 = function(e6, t5) {
                var o4 = t5 === C2.default.LTR ? function(e7) {
                  var t6 = e7.layout;
                  return Math.abs(t6.left) + Math.abs(t6.top);
                } : function(e7) {
                  var t6 = e7.layout;
                  return Math.abs(window.innerWidth - t6.right) + Math.abs(t6.top);
                }, s4 = (0, g2.default)(e6, o4);
                return (0, p2.default)(s4);
              }(s3, this.writingDirection).focusKey;
              return this.log("getNextFocusKey", "childKey will be focused", r4), this.getNextFocusKey(r4);
            }
            return this.log("getNextFocusKey", "targetFocusKey", e5), e5;
          }, e4.prototype.addFocusable = function(e5) {
            var t4 = e5.focusKey, o3 = e5.node, s3 = e5.parentFocusKey, i3 = e5.onEnterPress, n4 = e5.onEnterRelease, r4 = e5.onArrowPress, a3 = e5.onFocus, u4 = e5.onBlur, c3 = e5.saveLastFocusedChild, l4 = e5.trackChildren, d3 = e5.onUpdateFocus, h4 = e5.onUpdateHasFocusedChild, f4 = e5.preferredChildFocusKey, p3 = e5.autoRestoreFocus, y3 = e5.forceFocus, v3 = e5.focusable, g3 = e5.isFocusBoundary, b3 = e5.focusBoundaryDirections;
            if (this.focusableComponents[t4] = { focusKey: t4, node: o3, parentFocusKey: s3, onEnterPress: i3, onEnterRelease: n4, onArrowPress: r4, onFocus: a3, onBlur: u4, onUpdateFocus: d3, onUpdateHasFocusedChild: h4, saveLastFocusedChild: c3, trackChildren: l4, preferredChildFocusKey: f4, focusable: v3, isFocusBoundary: g3, focusBoundaryDirections: b3, autoRestoreFocus: p3, forceFocus: y3, lastFocusedChildKey: null, layout: { x: 0, y: 0, width: 0, height: 0, left: 0, top: 0, right: 0, bottom: 0, node: o3 }, layoutUpdated: false }, o3 || console.warn('Component added without a node reference. This will result in its coordinates being empty and may cause lost focus. Check the "ref" passed to "useFocusable": ', this.focusableComponents[t4]), !this.nativeMode) {
              this.updateLayout(t4), this.log("addFocusable", "Component added: ", this.focusableComponents[t4]), t4 === this.focusKey && this.setFocus(f4 || t4);
              for (var F3 = this.focusableComponents[this.focusKey]; F3; ) {
                if (F3.parentFocusKey === t4) {
                  this.updateParentsHasFocusedChild(this.focusKey, {}), this.updateParentsLastFocusedChild(this.focusKey);
                  break;
                }
                F3 = this.focusableComponents[F3.parentFocusKey];
              }
            }
          }, e4.prototype.removeFocusable = function(e5) {
            var t4 = e5.focusKey, o3 = this.focusableComponents[t4];
            if (o3) {
              var s3 = o3.parentFocusKey;
              (0, o3.onUpdateFocus)(false), this.log("removeFocusable", "Component removed: ", o3), delete this.focusableComponents[t4];
              var i3 = this.parentsHavingFocusedChild.includes(t4);
              this.parentsHavingFocusedChild = this.parentsHavingFocusedChild.filter(function(e6) {
                return e6 !== t4;
              });
              var n4 = this.focusableComponents[s3], r4 = t4 === this.focusKey;
              if (n4 && n4.lastFocusedChildKey === t4 && (n4.lastFocusedChildKey = null), this.nativeMode)
                return;
              (r4 || i3) && n4 && n4.autoRestoreFocus && (this.log("removeFocusable", "Component removed: ", r4 ? "Leaf component" : "Container component", "Auto restoring focus to: ", s3), this.setFocusDebounced(s3));
            }
          }, e4.prototype.getNodeLayoutByFocusKey = function(e5) {
            var t4 = this.focusableComponents[e5];
            return t4 ? (this.updateLayout(t4.focusKey), t4.layout) : null;
          }, e4.prototype.setCurrentFocusedKey = function(e5, t4) {
            if (this.isFocusableComponent(this.focusKey) && e5 !== this.focusKey) {
              var o3 = this.focusableComponents[this.focusKey];
              o3.onUpdateFocus(false), o3.onBlur(this.getNodeLayoutByFocusKey(this.focusKey), t4), this.log("setCurrentFocusedKey", "onBlur", o3);
            }
            if (this.focusKey = e5, this.isFocusableComponent(this.focusKey)) {
              var s3 = this.focusableComponents[this.focusKey];
              this.shouldFocusDOMNode && s3.node && s3.node.focus(), s3.onUpdateFocus(true), s3.onFocus(this.getNodeLayoutByFocusKey(this.focusKey), t4), this.log("setCurrentFocusedKey", "onFocus", s3);
            }
          }, e4.prototype.updateParentsHasFocusedChild = function(e5, t4) {
            for (var o3 = this, s3 = [], i3 = this.focusableComponents[e5]; i3; ) {
              var n4 = i3.parentFocusKey, r4 = this.focusableComponents[n4];
              if (r4) {
                var a3 = r4.focusKey;
                s3.push(a3);
              }
              i3 = r4;
            }
            var u4 = (0, d2.default)(this.parentsHavingFocusedChild, s3), c3 = (0, d2.default)(s3, this.parentsHavingFocusedChild);
            (0, y2.default)(u4, function(e6) {
              var s4 = o3.focusableComponents[e6];
              s4 && s4.trackChildren && s4.onUpdateHasFocusedChild(false), o3.onIntermediateNodeBecameBlurred(e6, t4);
            }), (0, y2.default)(c3, function(e6) {
              var s4 = o3.focusableComponents[e6];
              s4 && s4.trackChildren && s4.onUpdateHasFocusedChild(true), o3.onIntermediateNodeBecameFocused(e6, t4);
            }), this.parentsHavingFocusedChild = s3;
          }, e4.prototype.updateParentsLastFocusedChild = function(e5) {
            for (var t4 = this.focusableComponents[e5]; t4; ) {
              var o3 = t4.parentFocusKey, s3 = this.focusableComponents[o3];
              s3 && this.saveLastFocusedChildKey(s3, t4.focusKey), t4 = s3;
            }
          }, e4.prototype.getKeyMap = function() {
            return this.keyMap;
          }, e4.prototype.setKeyMap = function(e5) {
            this.keyMap = i2(i2({}, this.getKeyMap()), function(e6) {
              var t4 = {};
              return Object.entries(e6).forEach(function(e7) {
                var o3 = e7[0], s3 = e7[1];
                t4[o3] = Array.isArray(s3) ? s3 : [s3];
              }), t4;
            }(e5));
          }, e4.prototype.isFocusableComponent = function(e5) {
            return !!this.focusableComponents[e5];
          }, e4.prototype.isParticipatingFocusableComponent = function(e5) {
            return this.isFocusableComponent(e5) && this.focusableComponents[e5].focusable;
          }, e4.prototype.onIntermediateNodeBecameFocused = function(e5, t4) {
            this.isParticipatingFocusableComponent(e5) && this.focusableComponents[e5].onFocus(this.getNodeLayoutByFocusKey(e5), t4);
          }, e4.prototype.onIntermediateNodeBecameBlurred = function(e5, t4) {
            this.isParticipatingFocusableComponent(e5) && this.focusableComponents[e5].onBlur(this.getNodeLayoutByFocusKey(e5), t4);
          }, e4.prototype.pause = function() {
            this.paused = true;
          }, e4.prototype.resume = function() {
            this.paused = false;
          }, e4.prototype.setFocus = function(e5, o3) {
            if (void 0 === o3 && (o3 = {}), this.setFocusDebounced.cancel(), this.enabled && !this.nativeMode) {
              this.log("setFocus", "focusKey", e5), e5 && e5 !== t3.ROOT_FOCUS_KEY || (e5 = this.getForcedFocusKey());
              var s3 = this.getNextFocusKey(e5);
              this.log("setFocus", "newFocusKey", s3), this.setCurrentFocusedKey(s3, o3), this.updateParentsHasFocusedChild(s3, o3), this.updateParentsLastFocusedChild(s3);
            }
          }, e4.prototype.updateAllLayouts = function() {
            var e5 = this;
            this.enabled && !this.nativeMode && (0, v2.default)(this.focusableComponents, function(t4, o3) {
              e5.updateLayout(o3);
            });
          }, e4.prototype.updateLayout = function(e5) {
            var t4 = this.focusableComponents[e5];
            if (t4 && !this.nativeMode && !t4.layoutUpdated) {
              var o3 = t4.node, s3 = this.useGetBoundingClientRect ? (0, K2.getBoundingClientRect)(o3) : (0, K2.default)(o3);
              t4.layout = i2(i2({}, s3), { node: o3 });
            }
          }, e4.prototype.updateFocusable = function(e5, t4) {
            var o3 = t4.node, s3 = t4.preferredChildFocusKey, i3 = t4.focusable, n4 = t4.isFocusBoundary, r4 = t4.focusBoundaryDirections, a3 = t4.onEnterPress, u4 = t4.onEnterRelease, c3 = t4.onArrowPress, l4 = t4.onFocus, d3 = t4.onBlur;
            if (!this.nativeMode) {
              var h4 = this.focusableComponents[e5];
              h4 && (h4.preferredChildFocusKey = s3, h4.focusable = i3, h4.isFocusBoundary = n4, h4.focusBoundaryDirections = r4, h4.onEnterPress = a3, h4.onEnterRelease = u4, h4.onArrowPress = c3, h4.onFocus = l4, h4.onBlur = d3, o3 && (h4.node = o3));
            }
          }, e4.prototype.isNativeMode = function() {
            return this.nativeMode;
          }, e4.prototype.doesFocusableExist = function(e5) {
            return !!this.focusableComponents[e5];
          }, e4;
        }();
        t3.SpatialNavigation = new B2(), t3.init = t3.SpatialNavigation.init, t3.setThrottle = t3.SpatialNavigation.setThrottle, t3.destroy = t3.SpatialNavigation.destroy, t3.setKeyMap = t3.SpatialNavigation.setKeyMap, t3.setFocus = t3.SpatialNavigation.setFocus, t3.navigateByDirection = t3.SpatialNavigation.navigateByDirection, t3.pause = t3.SpatialNavigation.pause, t3.resume = t3.SpatialNavigation.resume, t3.updateAllLayouts = t3.SpatialNavigation.updateAllLayouts, t3.getCurrentFocusKey = t3.SpatialNavigation.getCurrentFocusKey, t3.doesFocusableExist = t3.SpatialNavigation.doesFocusableExist;
      }, 35: function(e3, t3, o2) {
        var s2 = this && this.__importDefault || function(e4) {
          return e4 && e4.__esModule ? e4 : { default: e4 };
        };
        Object.defineProperty(t3, "__esModule", { value: true });
        var i2 = s2(o2(119)), n3 = "undefined" != typeof window && window.document, r3 = n3 ? window.innerWidth : 0, a2 = n3 ? window.innerHeight : 0, u3 = function() {
          function e4(t4) {
            n3 && (this.debugCtx = e4.createCanvas("sn-debug", "1010", t4), this.layoutsCtx = e4.createCanvas("sn-layouts", "1000", t4), this.writingDirection = t4);
          }
          return e4.createCanvas = function(e5, t4, o3) {
            var s3 = document.querySelector("#".concat(e5)) || document.createElement("canvas");
            s3.setAttribute("id", e5), s3.setAttribute("dir", o3 === i2.default.LTR ? "ltr" : "rtl");
            var n4 = s3.getContext("2d");
            return s3.style.zIndex = t4, s3.style.position = "fixed", s3.style.top = "0", s3.style.left = "0", document.body.appendChild(s3), s3.width = r3, s3.height = a2, n4;
          }, e4.prototype.clear = function() {
            n3 && this.debugCtx.clearRect(0, 0, r3, a2);
          }, e4.prototype.clearLayouts = function() {
            n3 && this.layoutsCtx.clearRect(0, 0, r3, a2);
          }, e4.prototype.drawLayout = function(e5, t4, o3) {
            if (n3) {
              this.layoutsCtx.strokeStyle = "green", this.layoutsCtx.strokeRect(e5.left, e5.top, e5.width, e5.height), this.layoutsCtx.font = "8px monospace", this.layoutsCtx.fillStyle = "red";
              var s3 = this.writingDirection === i2.default.LTR ? "left" : "right", r4 = e5[s3];
              this.layoutsCtx.fillText(t4, r4, e5.top + 10), this.layoutsCtx.fillText(o3, r4, e5.top + 25), this.layoutsCtx.fillText("".concat(s3, ": ").concat(r4), r4, e5.top + 40), this.layoutsCtx.fillText("top: ".concat(e5.top), r4, e5.top + 55);
            }
          }, e4.prototype.drawPoint = function(e5, t4, o3, s3) {
            void 0 === o3 && (o3 = "blue"), void 0 === s3 && (s3 = 10), n3 && (this.debugCtx.strokeStyle = o3, this.debugCtx.lineWidth = 3, this.debugCtx.strokeRect(e5 - s3 / 2, t4 - s3 / 2, s3, s3));
          }, e4;
        }();
        t3.default = u3;
      }, 119: function(e3, t3) {
        var o2;
        Object.defineProperty(t3, "__esModule", { value: true }), function(e4) {
          e4[e4.LTR = 0] = "LTR", e4[e4.RTL = 1] = "RTL";
        }(o2 || (o2 = {})), t3.default = o2;
      }, 607: function(e3, t3, o2) {
        var s2 = this && this.__createBinding || (Object.create ? function(e4, t4, o3, s3) {
          void 0 === s3 && (s3 = o3);
          var i3 = Object.getOwnPropertyDescriptor(t4, o3);
          i3 && !("get" in i3 ? !t4.__esModule : i3.writable || i3.configurable) || (i3 = { enumerable: true, get: function() {
            return t4[o3];
          } }), Object.defineProperty(e4, s3, i3);
        } : function(e4, t4, o3, s3) {
          void 0 === s3 && (s3 = o3), e4[s3] = t4[o3];
        }), i2 = this && this.__exportStar || function(e4, t4) {
          for (var o3 in e4)
            "default" === o3 || Object.prototype.hasOwnProperty.call(t4, o3) || s2(t4, e4, o3);
        };
        Object.defineProperty(t3, "__esModule", { value: true }), i2(o2(79), t3), i2(o2(445), t3), i2(o2(654), t3);
      }, 964: function(e3, t3) {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.getBoundingClientRect = void 0;
        var o2 = function(e4) {
          for (var t4 = e4.offsetParent, o3 = e4.offsetHeight, s2 = e4.offsetWidth, i2 = e4.offsetLeft, n3 = e4.offsetTop; t4 && 1 === t4.nodeType; )
            i2 += t4.offsetLeft - t4.scrollLeft, n3 += t4.offsetTop - t4.scrollTop, t4 = t4.offsetParent;
          return { height: o3, left: i2, top: n3, width: s2 };
        };
        t3.default = function(e4) {
          var t4 = e4 && e4.parentElement;
          if (e4 && t4) {
            var s2 = o2(t4), i2 = o2(e4), n3 = i2.height, r3 = i2.left, a2 = i2.top, u3 = i2.width;
            return { x: r3 - s2.left, y: a2 - s2.top, width: u3, height: n3, left: r3, top: a2, get right() {
              return this.left + this.width;
            }, get bottom() {
              return this.top + this.height;
            } };
          }
          return { x: 0, y: 0, width: 0, height: 0, left: 0, top: 0, right: 0, bottom: 0 };
        }, t3.getBoundingClientRect = function(e4) {
          if (e4 && e4.getBoundingClientRect) {
            var t4 = e4.getBoundingClientRect();
            return { x: t4.x, y: t4.y, width: t4.width, height: t4.height, left: t4.left, top: t4.top, get right() {
              return this.left + this.width;
            }, get bottom() {
              return this.top + this.height;
            } };
          }
          return { x: 0, y: 0, width: 0, height: 0, left: 0, top: 0, right: 0, bottom: 0 };
        };
      }, 445: function(e3, t3, o2) {
        Object.defineProperty(t3, "__esModule", { value: true }), t3.useFocusContext = t3.FocusContext = void 0;
        var s2 = o2(156), i2 = o2(654);
        t3.FocusContext = (0, s2.createContext)(i2.ROOT_FOCUS_KEY), t3.FocusContext.displayName = "FocusContext", t3.useFocusContext = function() {
          return (0, s2.useContext)(t3.FocusContext);
        };
      }, 79: function(e3, t3, o2) {
        var s2 = this && this.__importDefault || function(e4) {
          return e4 && e4.__esModule ? e4 : { default: e4 };
        };
        Object.defineProperty(t3, "__esModule", { value: true }), t3.useFocusable = void 0;
        var i2 = o2(156), n3 = s2(o2(604)), r3 = s2(o2(461)), a2 = o2(654), u3 = o2(445);
        t3.useFocusable = function(e4) {
          var t4 = void 0 === e4 ? {} : e4, o3 = t4.focusable, s3 = void 0 === o3 || o3, c2 = t4.saveLastFocusedChild, l3 = void 0 === c2 || c2, d2 = t4.trackChildren, h3 = void 0 !== d2 && d2, f3 = t4.autoRestoreFocus, p2 = void 0 === f3 || f3, y2 = t4.forceFocus, v2 = void 0 !== y2 && y2, g2 = t4.isFocusBoundary, b2 = void 0 !== g2 && g2, F2 = t4.focusBoundaryDirections, C2 = t4.focusKey, K2 = t4.preferredChildFocusKey, m2 = t4.onEnterPress, w2 = void 0 === m2 ? n3.default : m2, x2 = t4.onEnterRelease, E2 = void 0 === x2 ? n3.default : x2, D2 = t4.onArrowPress, L2 = void 0 === D2 ? function() {
            return true;
          } : D2, P2 = t4.onFocus, N2 = void 0 === P2 ? n3.default : P2, B2 = t4.onBlur, M2 = void 0 === B2 ? n3.default : B2, R2 = t4.extraProps, _2 = (0, i2.useCallback)(function(e5) {
            w2(R2, e5);
          }, [w2, R2]), O2 = (0, i2.useCallback)(function() {
            E2(R2);
          }, [E2, R2]), k2 = (0, i2.useCallback)(function(e5, t5) {
            return L2(e5, R2, t5);
          }, [R2, L2]), T2 = (0, i2.useCallback)(function(e5, t5) {
            N2(e5, R2, t5);
          }, [R2, N2]), A2 = (0, i2.useCallback)(function(e5, t5) {
            M2(e5, R2, t5);
          }, [R2, M2]), S2 = (0, i2.useRef)(null), q2 = (0, i2.useState)(false), U2 = q2[0], j2 = q2[1], H2 = (0, i2.useState)(false), I2 = H2[0], Y2 = H2[1], G2 = (0, u3.useFocusContext)(), W2 = (0, i2.useMemo)(function() {
            return C2 || (0, r3.default)("sn:focusable-item-");
          }, [C2]), z2 = (0, i2.useCallback)(function(e5) {
            void 0 === e5 && (e5 = {}), a2.SpatialNavigation.setFocus(W2, e5);
          }, [W2]);
          return (0, i2.useEffect)(function() {
            var e5 = S2.current;
            return a2.SpatialNavigation.addFocusable({ focusKey: W2, node: e5, parentFocusKey: G2, preferredChildFocusKey: K2, onEnterPress: _2, onEnterRelease: O2, onArrowPress: k2, onFocus: T2, onBlur: A2, onUpdateFocus: function(e6) {
              return void 0 === e6 && (e6 = false), j2(e6);
            }, onUpdateHasFocusedChild: function(e6) {
              return void 0 === e6 && (e6 = false), Y2(e6);
            }, saveLastFocusedChild: l3, trackChildren: h3, isFocusBoundary: b2, focusBoundaryDirections: F2, autoRestoreFocus: p2, forceFocus: v2, focusable: s3 }), function() {
              a2.SpatialNavigation.removeFocusable({ focusKey: W2 });
            };
          }, []), (0, i2.useEffect)(function() {
            var e5 = S2.current;
            a2.SpatialNavigation.updateFocusable(W2, { node: e5, preferredChildFocusKey: K2, focusable: s3, isFocusBoundary: b2, focusBoundaryDirections: F2, onEnterPress: _2, onEnterRelease: O2, onArrowPress: k2, onFocus: T2, onBlur: A2 });
          }, [W2, K2, s3, b2, F2, _2, O2, k2, T2, A2]), { ref: S2, focusSelf: z2, focused: U2, hasFocusedChild: I2, focusKey: W2 };
        };
      }, 150: function(t3) {
        t3.exports = e2;
      }, 117: function(e3) {
        e3.exports = t2;
      }, 747: function(e3) {
        e3.exports = o;
      }, 23: function(e3) {
        e3.exports = s;
      }, 842: function(e3) {
        e3.exports = i;
      }, 682: function(e3) {
        e3.exports = n2;
      }, 784: function(e3) {
        e3.exports = r2;
      }, 604: function(e3) {
        e3.exports = a;
      }, 432: function(e3) {
        e3.exports = u2;
      }, 67: function(e3) {
        e3.exports = c;
      }, 461: function(e3) {
        e3.exports = l2;
      }, 156: function(e3) {
        e3.exports = d;
      } }, f2 = {};
      return function e3(t3) {
        var o2 = f2[t3];
        if (void 0 !== o2)
          return o2.exports;
        var s2 = f2[t3] = { exports: {} };
        return h2[t3].call(s2.exports, s2, s2.exports, e3), s2.exports;
      }(607);
    }();
  });
})(dist$1);
var distExports = dist$1.exports;
var classnames = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(module) {
  (function() {
    var hasOwn = {}.hasOwnProperty;
    function classNames2() {
      var classes = "";
      for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        if (arg) {
          classes = appendClass(classes, parseValue(arg));
        }
      }
      return classes;
    }
    function parseValue(arg) {
      if (typeof arg === "string" || typeof arg === "number") {
        return arg;
      }
      if (typeof arg !== "object") {
        return "";
      }
      if (Array.isArray(arg)) {
        return classNames2.apply(null, arg);
      }
      if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
        return arg.toString();
      }
      var classes = "";
      for (var key in arg) {
        if (hasOwn.call(arg, key) && arg[key]) {
          classes = appendClass(classes, key);
        }
      }
      return classes;
    }
    function appendClass(value, newClass) {
      if (!newClass) {
        return value;
      }
      if (value) {
        return value + " " + newClass;
      }
      return value + newClass;
    }
    if (module.exports) {
      classNames2.default = classNames2;
      module.exports = classNames2;
    } else {
      window.classNames = classNames2;
    }
  })();
})(classnames);
var classnamesExports = classnames.exports;
const classNames = /* @__PURE__ */ getDefaultExportFromCjs(classnamesExports);
var define_import_meta_env_default$2 = { BASE_URL: "/", MODE: "production", DEV: false, PROD: true, SSR: false };
const createStoreImpl = (createState2) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace2) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace2 != null ? replace2 : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener2) => listener2(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState;
  const subscribe = (listener2) => {
    listeners.add(listener2);
    return () => listeners.delete(listener2);
  };
  const destroy = () => {
    if ((define_import_meta_env_default$2 ? "production" : void 0) !== "production") {
      console.warn(
        "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
      );
    }
    listeners.clear();
  };
  const api = { setState, getState, getInitialState, subscribe, destroy };
  const initialState = state = createState2(setState, getState, api);
  return api;
};
const createStore = (createState2) => createState2 ? createStoreImpl(createState2) : createStoreImpl;
var withSelector = { exports: {} };
var withSelector_production_min = {};
var shim = { exports: {} };
var useSyncExternalStoreShim_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var e = reactExports;
function h$1(a, b2) {
  return a === b2 && (0 !== a || 1 / a === 1 / b2) || a !== a && b2 !== b2;
}
var k = "function" === typeof Object.is ? Object.is : h$1, l = e.useState, m = e.useEffect, n$1 = e.useLayoutEffect, p$1 = e.useDebugValue;
function q$1(a, b2) {
  var d = b2(), f2 = l({ inst: { value: d, getSnapshot: b2 } }), c = f2[0].inst, g2 = f2[1];
  n$1(function() {
    c.value = d;
    c.getSnapshot = b2;
    r$1(c) && g2({ inst: c });
  }, [a, d, b2]);
  m(function() {
    r$1(c) && g2({ inst: c });
    return a(function() {
      r$1(c) && g2({ inst: c });
    });
  }, [a]);
  p$1(d);
  return d;
}
function r$1(a) {
  var b2 = a.getSnapshot;
  a = a.value;
  try {
    var d = b2();
    return !k(a, d);
  } catch (f2) {
    return true;
  }
}
function t$1(a, b2) {
  return b2();
}
var u$1 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? t$1 : q$1;
useSyncExternalStoreShim_production_min.useSyncExternalStore = void 0 !== e.useSyncExternalStore ? e.useSyncExternalStore : u$1;
{
  shim.exports = useSyncExternalStoreShim_production_min;
}
var shimExports = shim.exports;
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var h = reactExports, n = shimExports;
function p(a, b2) {
  return a === b2 && (0 !== a || 1 / a === 1 / b2) || a !== a && b2 !== b2;
}
var q = "function" === typeof Object.is ? Object.is : p, r = n.useSyncExternalStore, t = h.useRef, u = h.useEffect, v = h.useMemo, w = h.useDebugValue;
withSelector_production_min.useSyncExternalStoreWithSelector = function(a, b2, e2, l2, g2) {
  var c = t(null);
  if (null === c.current) {
    var f2 = { hasValue: false, value: null };
    c.current = f2;
  } else
    f2 = c.current;
  c = v(function() {
    function a2(a3) {
      if (!c2) {
        c2 = true;
        d2 = a3;
        a3 = l2(a3);
        if (void 0 !== g2 && f2.hasValue) {
          var b3 = f2.value;
          if (g2(b3, a3))
            return k2 = b3;
        }
        return k2 = a3;
      }
      b3 = k2;
      if (q(d2, a3))
        return b3;
      var e3 = l2(a3);
      if (void 0 !== g2 && g2(b3, e3))
        return b3;
      d2 = a3;
      return k2 = e3;
    }
    var c2 = false, d2, k2, m2 = void 0 === e2 ? null : e2;
    return [function() {
      return a2(b2());
    }, null === m2 ? void 0 : function() {
      return a2(m2());
    }];
  }, [b2, e2, l2, g2]);
  var d = r(a, c[0], c[1]);
  u(function() {
    f2.hasValue = true;
    f2.value = d;
  }, [d]);
  w(d);
  return d;
};
{
  withSelector.exports = withSelector_production_min;
}
var withSelectorExports = withSelector.exports;
const useSyncExternalStoreExports = /* @__PURE__ */ getDefaultExportFromCjs(withSelectorExports);
var define_import_meta_env_default$1 = { BASE_URL: "/", MODE: "production", DEV: false, PROD: true, SSR: false };
const { useDebugValue } = React;
const { useSyncExternalStoreWithSelector } = useSyncExternalStoreExports;
let didWarnAboutEqualityFn = false;
const identity = (arg) => arg;
function useStore(api, selector = identity, equalityFn) {
  if ((define_import_meta_env_default$1 ? "production" : void 0) !== "production" && equalityFn && !didWarnAboutEqualityFn) {
    console.warn(
      "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
    );
    didWarnAboutEqualityFn = true;
  }
  const slice2 = useSyncExternalStoreWithSelector(
    api.subscribe,
    api.getState,
    api.getServerState || api.getInitialState,
    selector,
    equalityFn
  );
  useDebugValue(slice2);
  return slice2;
}
const createImpl = (createState2) => {
  if ((define_import_meta_env_default$1 ? "production" : void 0) !== "production" && typeof createState2 !== "function") {
    console.warn(
      "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
    );
  }
  const api = typeof createState2 === "function" ? createStore(createState2) : createState2;
  const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);
  Object.assign(useBoundStore, api);
  return useBoundStore;
};
const create$2 = (createState2) => createState2 ? createImpl(createState2) : createImpl;
var gamepad = { exports: {} };
(function(module, exports) {
  !function(t2, e2) {
    module.exports = e2();
  }(commonjsGlobal, () => (() => {
    var t2 = { 944: function(t3) {
      var e3;
      e3 = () => (() => {
        var t4 = { d: (e5, n4) => {
          for (var r4 in n4)
            t4.o(n4, r4) && !t4.o(e5, r4) && Object.defineProperty(e5, r4, { enumerable: true, get: n4[r4] });
        }, o: (t5, e5) => Object.prototype.hasOwnProperty.call(t5, e5) }, e4 = {};
        function n3(t5) {
          return n3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t6) {
            return typeof t6;
          } : function(t6) {
            return t6 && "function" == typeof Symbol && t6.constructor === Symbol && t6 !== Symbol.prototype ? "symbol" : typeof t6;
          }, n3(t5);
        }
        function r3(t5, e5) {
          var n4 = "undefined" != typeof Symbol && t5[Symbol.iterator] || t5["@@iterator"];
          if (!n4) {
            if (Array.isArray(t5) || (n4 = i(t5)) || e5 && t5 && "number" == typeof t5.length) {
              n4 && (t5 = n4);
              var r4 = 0, o2 = function() {
              };
              return { s: o2, n: function() {
                return r4 >= t5.length ? { done: true } : { done: false, value: t5[r4++] };
              }, e: function(t6) {
                throw t6;
              }, f: o2 };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var a2, u3 = true, s2 = false;
          return { s: function() {
            n4 = n4.call(t5);
          }, n: function() {
            var t6 = n4.next();
            return u3 = t6.done, t6;
          }, e: function(t6) {
            s2 = true, a2 = t6;
          }, f: function() {
            try {
              u3 || null == n4.return || n4.return();
            } finally {
              if (s2)
                throw a2;
            }
          } };
        }
        function o(t5, e5) {
          return function(t6) {
            if (Array.isArray(t6))
              return t6;
          }(t5) || function(t6, e6) {
            var n4 = null == t6 ? null : "undefined" != typeof Symbol && t6[Symbol.iterator] || t6["@@iterator"];
            if (null != n4) {
              var r4, o2, i2, a2, u3 = [], s2 = true, l2 = false;
              try {
                if (i2 = (n4 = n4.call(t6)).next, 0 === e6) {
                  if (Object(n4) !== n4)
                    return;
                  s2 = false;
                } else
                  for (; !(s2 = (r4 = i2.call(n4)).done) && (u3.push(r4.value), u3.length !== e6); s2 = true)
                    ;
              } catch (t7) {
                l2 = true, o2 = t7;
              } finally {
                try {
                  if (!s2 && null != n4.return && (a2 = n4.return(), Object(a2) !== a2))
                    return;
                } finally {
                  if (l2)
                    throw o2;
                }
              }
              return u3;
            }
          }(t5, e5) || i(t5, e5) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function i(t5, e5) {
          if (t5) {
            if ("string" == typeof t5)
              return a(t5, e5);
            var n4 = Object.prototype.toString.call(t5).slice(8, -1);
            return "Object" === n4 && t5.constructor && (n4 = t5.constructor.name), "Map" === n4 || "Set" === n4 ? Array.from(t5) : "Arguments" === n4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4) ? a(t5, e5) : void 0;
          }
        }
        function a(t5, e5) {
          (null == e5 || e5 > t5.length) && (e5 = t5.length);
          for (var n4 = 0, r4 = new Array(e5); n4 < e5; n4++)
            r4[n4] = t5[n4];
          return r4;
        }
        function u2(t5, e5) {
          if (!(t5 instanceof e5))
            throw new TypeError("Cannot call a class as a function");
        }
        t4.d(e4, { default: () => s });
        var s = function() {
          function t5() {
            var e6 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
            u2(this, t5), this.strict = e6, this.defaults = /* @__PURE__ */ new Map(), this.validators = /* @__PURE__ */ new Map(), this.types = /* @__PURE__ */ new Map(), this.optional = /* @__PURE__ */ new Set(), this.required = /* @__PURE__ */ new Set();
          }
          var e5, i2;
          return e5 = t5, (i2 = [{ key: "allowExtra", value: function() {
            return this.strict = false, this;
          } }, { key: "setDefaults", value: function(t6) {
            var e6 = this;
            return Object.entries(t6).forEach(function(t7) {
              var n4 = o(t7, 2), r4 = n4[0], i3 = n4[1];
              return e6.defaults.set(r4, i3);
            }), this;
          } }, { key: "setValidators", value: function(t6) {
            var e6 = this;
            return Object.entries(t6).forEach(function(t7) {
              var n4 = o(t7, 2), r4 = n4[0], i3 = n4[1];
              return e6.validators.set(r4, i3);
            }), this;
          } }, { key: "setTypes", value: function(t6) {
            var e6 = this;
            return Object.entries(t6).forEach(function(t7) {
              var n4 = o(t7, 2), r4 = n4[0], i3 = n4[1];
              return e6.types.set(r4, i3);
            }), this;
          } }, { key: "setOptional", value: function(t6) {
            var e6 = this;
            return t6.forEach(function(t7) {
              return e6.optional.add(t7);
            }), this;
          } }, { key: "setRequired", value: function(t6) {
            var e6 = this;
            return t6.forEach(function(t7) {
              return e6.required.add(t7);
            }), this;
          } }, { key: "resolve", value: function(t6) {
            return this.validate(Object.assign(this.getDefaults(), t6));
          } }, { key: "getDefaults", value: function() {
            var t6, e6 = {}, n4 = r3(this.defaults);
            try {
              for (n4.s(); !(t6 = n4.n()).done; ) {
                var i3 = o(t6.value, 2), a2 = i3[0], u3 = i3[1];
                e6[a2] = u3;
              }
            } catch (t7) {
              n4.e(t7);
            } finally {
              n4.f();
            }
            return e6;
          } }, { key: "validate", value: function(t6) {
            for (var e6 in t6)
              this.validators.has(e6) && (t6[e6] = this.validators.get(e6)(t6[e6]));
            for (var n4 in t6) {
              if (!this.optionExists(n4))
                throw new Error('Unkown option "'.concat(n4, '".'));
              this.checkType(n4, t6[n4]);
            }
            var o2, i3 = r3(this.required.values());
            try {
              for (i3.s(); !(o2 = i3.n()).done; ) {
                var a2 = o2.value;
                if (void 0 === t6[a2])
                  throw new Error('Option "'.concat(a2, '" is required.'));
              }
            } catch (t7) {
              i3.e(t7);
            } finally {
              i3.f();
            }
            return t6;
          } }, { key: "checkType", value: function(t6, e6) {
            if (this.types.has(t6)) {
              var r4 = this.types.get(t6), o2 = n3(e6);
              if (o2 !== r4)
                throw new Error('Wrong value for option "'.concat(t6, '": expected type "').concat(r4, '", got "').concat(o2, '".'));
            }
          } }, { key: "optionExists", value: function(t6) {
            return !this.strict || this.defaults.has(t6) || this.validators.has(t6) || this.optional.has(t6) || this.required.has(t6) || this.types.has(t6);
          } }]) && function(t6, e6) {
            for (var r4 = 0; r4 < e6.length; r4++) {
              var o2 = e6[r4];
              o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(t6, (i3 = function(t7, e7) {
                if ("object" !== n3(t7) || null === t7)
                  return t7;
                var r5 = t7[Symbol.toPrimitive];
                if (void 0 !== r5) {
                  var o3 = r5.call(t7, "string");
                  if ("object" !== n3(o3))
                    return o3;
                  throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return String(t7);
              }(o2.key), "symbol" === n3(i3) ? i3 : String(i3)), o2);
            }
            var i3;
          }(e5.prototype, i2), Object.defineProperty(e5, "prototype", { writable: false }), t5;
        }();
        return e4.default;
      })(), t3.exports = e3();
    }, 162: function(t3) {
      t3.exports = (() => {
        var t4 = { d: (e4, n4) => {
          for (var r3 in n4)
            t4.o(n4, r3) && !t4.o(e4, r3) && Object.defineProperty(e4, r3, { enumerable: true, get: n4[r3] });
        }, o: (t5, e4) => Object.prototype.hasOwnProperty.call(t5, e4) }, e3 = {};
        t4.d(e3, { default: () => n3 });
        var n3 = function() {
          function t5() {
            !function(t6, e5) {
              if (!(t6 instanceof e5))
                throw new TypeError("Cannot call a class as a function");
            }(this, t5), this._events = {}, this.on = this.addEventListener, this.off = this.removeEventListener;
          }
          var e4;
          return (e4 = [{ key: "emit", value: function(t6, e5) {
            if (Object.prototype.hasOwnProperty.call(this._events, t6))
              for (var n4 = this._events[t6], r3 = { type: t6, detail: e5 }, o = n4.length, i = 0; i < o; i++)
                this.handle(n4[i], r3);
          } }, { key: "handle", value: function(t6, e5) {
            t6(e5);
          } }, { key: "addEventListener", value: function(t6, e5) {
            Object.prototype.hasOwnProperty.call(this._events, t6) || (this._events[t6] = []), this._events[t6].indexOf(e5) < 0 && this._events[t6].push(e5);
          } }, { key: "removeEventListener", value: function(t6, e5) {
            if (Object.prototype.hasOwnProperty.call(this._events, t6)) {
              var n4 = this._events[t6], r3 = n4.indexOf(e5);
              r3 >= 0 && n4.splice(r3, 1), 0 === n4.length && delete this._events[t6];
            }
          } }]) && function(t6, e5) {
            for (var n4 = 0; n4 < e5.length; n4++) {
              var r3 = e5[n4];
              r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(t6, r3.key, r3);
            }
          }(t5.prototype, e4), t5;
        }();
        return e3.default;
      })();
    } }, e2 = {};
    function n2(r3) {
      var o = e2[r3];
      if (void 0 !== o)
        return o.exports;
      var i = e2[r3] = { exports: {} };
      return t2[r3].call(i.exports, i, i.exports, n2), i.exports;
    }
    n2.n = (t3) => {
      var e3 = t3 && t3.__esModule ? () => t3.default : () => t3;
      return n2.d(e3, { a: e3 }), e3;
    }, n2.d = (t3, e3) => {
      for (var r3 in e3)
        n2.o(e3, r3) && !n2.o(t3, r3) && Object.defineProperty(t3, r3, { enumerable: true, get: e3[r3] });
    }, n2.o = (t3, e3) => Object.prototype.hasOwnProperty.call(t3, e3), n2.r = (t3) => {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t3, "__esModule", { value: true });
    };
    var r2 = {};
    return (() => {
      n2.r(r2), n2.d(r2, { GamepadHandler: () => h2, GamepadListener: () => A2 });
      var t3 = n2(162), e3 = n2.n(t3), o = n2(944), i = n2.n(o);
      function a(t4) {
        return a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, a(t4);
      }
      function u2(t4, e4) {
        if (!(t4 instanceof e4))
          throw new TypeError("Cannot call a class as a function");
      }
      function s(t4, e4) {
        for (var n3 = 0; n3 < e4.length; n3++) {
          var r3 = e4[n3];
          r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(t4, p2(r3.key), r3);
        }
      }
      function l2(t4, e4) {
        return l2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e5) {
          return t5.__proto__ = e5, t5;
        }, l2(t4, e4);
      }
      function c(t4, e4) {
        if (e4 && ("object" === a(e4) || "function" == typeof e4))
          return e4;
        if (void 0 !== e4)
          throw new TypeError("Derived constructors may only return object or undefined");
        return function(t5) {
          if (void 0 === t5)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t5;
        }(t4);
      }
      function f2(t4) {
        return f2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, f2(t4);
      }
      function p2(t4) {
        var e4 = function(t5, e5) {
          if ("object" !== a(t5) || null === t5)
            return t5;
          var n3 = t5[Symbol.toPrimitive];
          if (void 0 !== n3) {
            var r3 = n3.call(t5, "string");
            if ("object" !== a(r3))
              return r3;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(t5);
        }(t4);
        return "symbol" === a(e4) ? e4 : String(e4);
      }
      var d, y2, v2, h2 = function(t4) {
        !function(t5, e5) {
          if ("function" != typeof e5 && null !== e5)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e5 && e5.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e5 && l2(t5, e5);
        }(p3, t4);
        var e4, n3, r3, o2, i2, a2 = (o2 = p3, i2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t5) {
            return false;
          }
        }(), function() {
          var t5, e5 = f2(o2);
          if (i2) {
            var n4 = f2(this).constructor;
            t5 = Reflect.construct(e5, arguments, n4);
          } else
            t5 = e5.apply(this, arguments);
          return c(this, t5);
        });
        function p3(t5, e5) {
          var n4, r4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
          return u2(this, p3), (n4 = a2.call(this)).index = t5, n4.gamepad = e5, n4.options = n4.constructor.resolveOptions(r4), n4.axes = new Array(e5.axes.length).fill(null), n4.buttons = new Array(e5.buttons.length).fill(null), n4.initAxes(), n4.initButtons(), n4;
        }
        return e4 = p3, r3 = [{ key: "resolveOptions", value: function(t5) {
          var e5, n4, r4, o3, i3 = t5.axis, a3 = t5.button;
          return { axis: this.optionResolver.resolve(null !== (e5 = null !== (n4 = null != i3 ? i3 : a3) && void 0 !== n4 ? n4 : t5) && void 0 !== e5 ? e5 : {}), button: this.optionResolver.resolve(null !== (r4 = null !== (o3 = null != a3 ? a3 : i3) && void 0 !== o3 ? o3 : t5) && void 0 !== r4 ? r4 : {}) };
        } }], (n3 = [{ key: "initAxes", value: function() {
          for (var t5 = this.axes.length, e5 = 0; e5 < t5; e5++)
            this.axes[e5] = this.resolveAxisValue(e5);
        } }, { key: "initButtons", value: function() {
          for (var t5 = this.buttons.length, e5 = 0; e5 < t5; e5++)
            this.buttons[e5] = this.resolveButtonValue(e5);
        } }, { key: "update", value: function(t5) {
          this.gamepad = t5, this.updateAxis(), this.updateButtons();
        } }, { key: "updateAxis", value: function() {
          for (var t5 = this.axes.length, e5 = 0; e5 < t5; e5++)
            this.setAxisValue(e5, this.resolveAxisValue(e5));
        } }, { key: "updateButtons", value: function() {
          for (var t5 = this.buttons.length, e5 = 0; e5 < t5; e5++)
            this.setButtonValue(e5, this.resolveButtonValue(e5));
        } }, { key: "setAxisValue", value: function(t5, e5) {
          this.axes[t5] !== e5 && (this.axes[t5] = e5, this.emit("axis", { gamepad: this.gamepad, index: this.index, axis: t5, value: e5 }));
        } }, { key: "setButtonValue", value: function(t5, e5) {
          this.buttons[t5] !== e5 && (this.buttons[t5] = e5, this.emit("button", { gamepad: this.gamepad, index: this.index, button: t5, pressed: this.gamepad.buttons[t5].pressed, value: e5 }));
        } }, { key: "resolveAxisValue", value: function(t5) {
          var e5 = this.options.axis, n4 = e5.deadZone, r4 = e5.analog, o3 = e5.precision, i3 = this.gamepad.axes[t5];
          return n4 && i3 < n4 && i3 > -n4 ? 0 : r4 ? o3 ? Math.round(i3 * o3) / o3 : i3 : i3 > 0 ? 1 : i3 < 0 ? -1 : 0;
        } }, { key: "resolveButtonValue", value: function(t5) {
          var e5 = this.options.button, n4 = e5.deadZone, r4 = e5.analog, o3 = e5.precision, i3 = this.gamepad.buttons[t5].value;
          return n4 > 0 && i3 < n4 && i3 > -n4 ? 0 : r4 ? o3 ? Math.round(i3 * o3) / o3 : i3 : 0 === i3 ? 0 : 1;
        } }]) && s(e4.prototype, n3), r3 && s(e4, r3), Object.defineProperty(e4, "prototype", { writable: false }), p3;
      }(e3());
      function b2(t4) {
        return b2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, b2(t4);
      }
      function m2(t4, e4) {
        for (var n3 = 0; n3 < e4.length; n3++) {
          var r3 = e4[n3];
          r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(t4, g2(r3.key), r3);
        }
      }
      function g2(t4) {
        var e4 = function(t5, e5) {
          if ("object" !== b2(t5) || null === t5)
            return t5;
          var n3 = t5[Symbol.toPrimitive];
          if (void 0 !== n3) {
            var r3 = n3.call(t5, "string");
            if ("object" !== b2(r3))
              return r3;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(t5);
        }(t4);
        return "symbol" === b2(e4) ? e4 : String(e4);
      }
      d = h2, y2 = "optionResolver", v2 = new (i())().setDefaults({ analog: true, deadZone: 0, precision: 0 }).setTypes({ analog: "boolean", deadZone: "number", precision: "number" }).setValidators({ deadZone: function(t4) {
        return Math.max(Math.min(t4, 1), 0);
      }, precision: function(t4) {
        return t4 > 0 ? Math.pow(10, t4) : 0;
      } }), (y2 = p2(y2)) in d ? Object.defineProperty(d, y2, { value: v2, enumerable: true, configurable: true, writable: true }) : d[y2] = v2;
      var w2 = function() {
        function t4(e5) {
          !function(t5, e6) {
            if (!(t5 instanceof e6))
              throw new TypeError("Cannot call a class as a function");
          }(this, t4), this.callback = e5, this.frame = null, this.update = this.update.bind(this);
        }
        var e4, n3;
        return e4 = t4, (n3 = [{ key: "setCallback", value: function(t5) {
          this.callback = t5;
        } }, { key: "start", value: function() {
          this.frame || (this.frame = window.requestAnimationFrame(this.update));
        } }, { key: "stop", value: function() {
          this.frame && (window.cancelAnimationFrame(this.frame), this.frame = null);
        } }, { key: "update", value: function() {
          this.frame = window.requestAnimationFrame(this.update), this.callback();
        } }]) && m2(e4.prototype, n3), Object.defineProperty(e4, "prototype", { writable: false }), t4;
      }();
      function x2(t4) {
        return x2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t5) {
          return typeof t5;
        } : function(t5) {
          return t5 && "function" == typeof Symbol && t5.constructor === Symbol && t5 !== Symbol.prototype ? "symbol" : typeof t5;
        }, x2(t4);
      }
      function O2(t4, e4) {
        if (!(t4 instanceof e4))
          throw new TypeError("Cannot call a class as a function");
      }
      function j2(t4, e4) {
        for (var n3 = 0; n3 < e4.length; n3++) {
          var r3 = e4[n3];
          r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(t4, k2(r3.key), r3);
        }
      }
      function k2(t4) {
        var e4 = function(t5, e5) {
          if ("object" !== x2(t5) || null === t5)
            return t5;
          var n3 = t5[Symbol.toPrimitive];
          if (void 0 !== n3) {
            var r3 = n3.call(t5, "string");
            if ("object" !== x2(r3))
              return r3;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(t5);
        }(t4);
        return "symbol" === x2(e4) ? e4 : String(e4);
      }
      function S2(t4, e4) {
        return S2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t5, e5) {
          return t5.__proto__ = e5, t5;
        }, S2(t4, e4);
      }
      function P2(t4, e4) {
        if (e4 && ("object" === x2(e4) || "function" == typeof e4))
          return e4;
        if (void 0 !== e4)
          throw new TypeError("Derived constructors may only return object or undefined");
        return E2(t4);
      }
      function E2(t4) {
        if (void 0 === t4)
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t4;
      }
      function _2(t4) {
        return _2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t5) {
          return t5.__proto__ || Object.getPrototypeOf(t5);
        }, _2(t4);
      }
      var A2 = function(t4) {
        !function(t5, e5) {
          if ("function" != typeof e5 && null !== e5)
            throw new TypeError("Super expression must either be null or a function");
          t5.prototype = Object.create(e5 && e5.prototype, { constructor: { value: t5, writable: true, configurable: true } }), Object.defineProperty(t5, "prototype", { writable: false }), e5 && S2(t5, e5);
        }(a2, t4);
        var e4, n3, r3, o2, i2 = (r3 = a2, o2 = function() {
          if ("undefined" == typeof Reflect || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if ("function" == typeof Proxy)
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (t5) {
            return false;
          }
        }(), function() {
          var t5, e5 = _2(r3);
          if (o2) {
            var n4 = _2(this).constructor;
            t5 = Reflect.construct(e5, arguments, n4);
          } else
            t5 = e5.apply(this, arguments);
          return P2(this, t5);
        });
        function a2() {
          var t5, e5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          if (O2(this, a2), t5 = i2.call(this), "function" != typeof navigator.getGamepads)
            throw new Error("This browser does not support gamepad API.");
          return t5.options = e5, t5.onAxis = t5.onAxis.bind(E2(t5)), t5.update = t5.update.bind(E2(t5)), t5.start = t5.start.bind(E2(t5)), t5.stop = t5.stop.bind(E2(t5)), t5.discover = t5.discover.bind(E2(t5)), t5.onButton = t5.onButton.bind(E2(t5)), t5.handlers = new Array(4).fill(null), t5.loop = new w2(t5.update), window.addEventListener("error", t5.stop), t5;
        }
        return e4 = a2, (n3 = [{ key: "start", value: function() {
          this.loop.start();
        } }, { key: "stop", value: function() {
          this.loop.stop();
        } }, { key: "update", value: function() {
          var t5 = navigator.getGamepads();
          this.discover(t5[0], 0), this.discover(t5[1], 1), this.discover(t5[2], 2), this.discover(t5[3], 3);
        } }, { key: "discover", value: function(t5, e5) {
          t5 ? (null === this.handlers[e5] && this.registerHandler(e5, t5), this.handlers[e5].update(t5)) : this.handlers[e5] && this.removeGamepad(e5);
        } }, { key: "registerHandler", value: function(t5, e5) {
          var n4 = new h2(t5, e5, this.options);
          this.handlers[t5] = n4, n4.addEventListener("axis", this.onAxis), n4.addEventListener("button", this.onButton), this.emit("gamepad:connected", { index: t5, gamepad: e5 }), this.emit("gamepad:".concat(t5, ":connected"), { index: t5, gamepad: e5 });
        } }, { key: "removeGamepad", value: function(t5) {
          var e5 = this.handlers[t5];
          e5.removeEventListener("axis", this.onAxis), e5.removeEventListener("button", this.onButton), this.handlers[t5] = null, this.emit("gamepad:disconnected", { index: t5 }), this.emit("gamepad:".concat(t5, ":disconnected"), { index: t5 });
        } }, { key: "onAxis", value: function(t5) {
          var e5 = t5.detail.index;
          this.emit("gamepad:axis", t5.detail), this.emit("gamepad:".concat(e5, ":axis"), t5.detail), this.emit("gamepad:".concat(e5, ":axis:").concat(t5.detail.axis), t5.detail);
        } }, { key: "onButton", value: function(t5) {
          var e5 = t5.detail.index;
          this.emit("gamepad:button", t5.detail), this.emit("gamepad:".concat(e5, ":button"), t5.detail), this.emit("gamepad:".concat(e5, ":button:").concat(t5.detail.button), t5.detail);
        } }]) && j2(e4.prototype, n3), Object.defineProperty(e4, "prototype", { writable: false }), a2;
      }(e3());
    })(), r2;
  })());
})(gamepad);
var gamepadExports = gamepad.exports;
const useInputStore = create$2()((set, get) => ({
  subscribers: /* @__PURE__ */ new Set(),
  subscribe: (handler) => {
    const { subscribers } = get();
    set({ subscribers: new Set(subscribers).add(handler) });
  },
  unsubscribe: (handler) => {
    const { subscribers } = get();
    subscribers.delete(handler);
    set({ subscribers: new Set(subscribers) });
  },
  handleGamepadEvent: (event) => {
    get().subscribers.forEach((handler) => handler(event));
  },
  handleKeyboardEvent: (event) => {
    get().subscribers.forEach((handler) => handler(event));
  }
}));
const listener = new gamepadExports.GamepadListener({ analog: false });
listener.on("gamepad:connected", console.log);
listener.on("gamepad:disconnected", console.log);
listener.on("gamepad:button", (event) => {
  useInputStore.getState().handleGamepadEvent(event);
});
const ifNegative = (value, onTrue, onFalse) => value < 0 ? onTrue : onFalse;
const getDirectionFromAxisValue = (axis, value) => {
  if (value === 0)
    return null;
  switch (axis) {
    case 5:
    case 1:
      return ifNegative(value, "up", "down");
    case 4:
    case 0:
      return ifNegative(value, "left", "right");
    default:
      return null;
  }
};
listener.on("gamepad:axis", (axisEvent) => {
  const direction = getDirectionFromAxisValue(
    axisEvent.detail.axis,
    axisEvent.detail.value
  );
  if (direction)
    distExports.navigateByDirection(direction);
});
if (!window.hasGamepadListener) {
  listener.start();
  window.hasGamepadListener = true;
}
function handleKeyboardEvent(event) {
  if (event.repeat)
    return;
  const keyToAction = {
    ArrowDown: "down",
    ArrowUp: "up",
    ArrowLeft: "left",
    ArrowRight: "right",
    j: "down",
    k: "up",
    h: "left",
    l: "right"
  };
  if (keyToAction[event.key]) {
    if (event.type === "keydown") {
      distExports.navigateByDirection(keyToAction[event.key]);
    }
  } else {
    useInputStore.getState().handleGamepadEvent(event);
  }
}
if (!window.hasKeyboardListener) {
  window.addEventListener("keydown", handleKeyboardEvent);
  window.addEventListener("keyup", handleKeyboardEvent);
  window.hasKeyboardListener = true;
}
var dist = {};
var client = {};
var models = {};
(function(exports) {
  var __extends2 = commonjsGlobal && commonjsGlobal.__extends || /* @__PURE__ */ function() {
    var extendStatics2 = function(d, b2) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
        d2.__proto__ = b3;
      } || function(d2, b3) {
        for (var p2 in b3)
          if (Object.prototype.hasOwnProperty.call(b3, p2))
            d2[p2] = b3[p2];
      };
      return extendStatics2(d, b2);
    };
    return function(d, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics2(d, b2);
      function __() {
        this.constructor = d;
      }
      d.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createJSONRPCNotification = exports.createJSONRPCRequest = exports.createJSONRPCSuccessResponse = exports.createJSONRPCErrorResponse = exports.JSONRPCErrorCode = exports.JSONRPCErrorException = exports.isJSONRPCResponses = exports.isJSONRPCResponse = exports.isJSONRPCRequests = exports.isJSONRPCRequest = exports.isJSONRPCID = exports.JSONRPC = void 0;
  exports.JSONRPC = "2.0";
  var isJSONRPCID = function(id2) {
    return typeof id2 === "string" || typeof id2 === "number" || id2 === null;
  };
  exports.isJSONRPCID = isJSONRPCID;
  var isJSONRPCRequest = function(payload) {
    return payload.jsonrpc === exports.JSONRPC && payload.method !== void 0 && payload.result === void 0 && payload.error === void 0;
  };
  exports.isJSONRPCRequest = isJSONRPCRequest;
  var isJSONRPCRequests = function(payload) {
    return Array.isArray(payload) && payload.every(exports.isJSONRPCRequest);
  };
  exports.isJSONRPCRequests = isJSONRPCRequests;
  var isJSONRPCResponse = function(payload) {
    return payload.jsonrpc === exports.JSONRPC && payload.id !== void 0 && (payload.result !== void 0 || payload.error !== void 0);
  };
  exports.isJSONRPCResponse = isJSONRPCResponse;
  var isJSONRPCResponses = function(payload) {
    return Array.isArray(payload) && payload.every(exports.isJSONRPCResponse);
  };
  exports.isJSONRPCResponses = isJSONRPCResponses;
  var createJSONRPCError = function(code, message, data) {
    var error = { code, message };
    if (data != null) {
      error.data = data;
    }
    return error;
  };
  var JSONRPCErrorException = (
    /** @class */
    function(_super) {
      __extends2(JSONRPCErrorException2, _super);
      function JSONRPCErrorException2(message, code, data) {
        var _this = _super.call(this, message) || this;
        Object.setPrototypeOf(_this, JSONRPCErrorException2.prototype);
        _this.code = code;
        _this.data = data;
        return _this;
      }
      JSONRPCErrorException2.prototype.toObject = function() {
        return createJSONRPCError(this.code, this.message, this.data);
      };
      return JSONRPCErrorException2;
    }(Error)
  );
  exports.JSONRPCErrorException = JSONRPCErrorException;
  (function(JSONRPCErrorCode) {
    JSONRPCErrorCode[JSONRPCErrorCode["ParseError"] = -32700] = "ParseError";
    JSONRPCErrorCode[JSONRPCErrorCode["InvalidRequest"] = -32600] = "InvalidRequest";
    JSONRPCErrorCode[JSONRPCErrorCode["MethodNotFound"] = -32601] = "MethodNotFound";
    JSONRPCErrorCode[JSONRPCErrorCode["InvalidParams"] = -32602] = "InvalidParams";
    JSONRPCErrorCode[JSONRPCErrorCode["InternalError"] = -32603] = "InternalError";
  })(exports.JSONRPCErrorCode || (exports.JSONRPCErrorCode = {}));
  var createJSONRPCErrorResponse = function(id2, code, message, data) {
    return {
      jsonrpc: exports.JSONRPC,
      id: id2,
      error: createJSONRPCError(code, message, data)
    };
  };
  exports.createJSONRPCErrorResponse = createJSONRPCErrorResponse;
  var createJSONRPCSuccessResponse = function(id2, result) {
    return {
      jsonrpc: exports.JSONRPC,
      id: id2,
      result: result !== null && result !== void 0 ? result : null
    };
  };
  exports.createJSONRPCSuccessResponse = createJSONRPCSuccessResponse;
  var createJSONRPCRequest = function(id2, method, params) {
    return {
      jsonrpc: exports.JSONRPC,
      id: id2,
      method,
      params
    };
  };
  exports.createJSONRPCRequest = createJSONRPCRequest;
  var createJSONRPCNotification = function(method, params) {
    return {
      jsonrpc: exports.JSONRPC,
      method,
      params
    };
  };
  exports.createJSONRPCNotification = createJSONRPCNotification;
})(models);
var internal = {};
Object.defineProperty(internal, "__esModule", { value: true });
internal.DefaultErrorCode = void 0;
internal.DefaultErrorCode = 0;
var __awaiter$2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$2 = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
Object.defineProperty(client, "__esModule", { value: true });
client.JSONRPCClient = void 0;
var models_1$2 = models;
var internal_1$1 = internal;
var JSONRPCClient = (
  /** @class */
  function() {
    function JSONRPCClient2(_send, createID) {
      this._send = _send;
      this.createID = createID;
      this.idToResolveMap = /* @__PURE__ */ new Map();
      this.id = 0;
    }
    JSONRPCClient2.prototype._createID = function() {
      if (this.createID) {
        return this.createID();
      } else {
        return ++this.id;
      }
    };
    JSONRPCClient2.prototype.timeout = function(delay2, overrideCreateJSONRPCErrorResponse) {
      var _this = this;
      if (overrideCreateJSONRPCErrorResponse === void 0) {
        overrideCreateJSONRPCErrorResponse = function(id2) {
          return (0, models_1$2.createJSONRPCErrorResponse)(id2, internal_1$1.DefaultErrorCode, "Request timeout");
        };
      }
      var timeoutRequest = function(ids, request) {
        var timeoutID = setTimeout(function() {
          ids.forEach(function(id2) {
            var resolve2 = _this.idToResolveMap.get(id2);
            if (resolve2) {
              _this.idToResolveMap.delete(id2);
              resolve2(overrideCreateJSONRPCErrorResponse(id2));
            }
          });
        }, delay2);
        return request().then(function(result) {
          clearTimeout(timeoutID);
          return result;
        }, function(error) {
          clearTimeout(timeoutID);
          return Promise.reject(error);
        });
      };
      var requestAdvanced = function(request, clientParams) {
        var ids = (!Array.isArray(request) ? [request] : request).map(function(request2) {
          return request2.id;
        }).filter(isDefinedAndNonNull);
        return timeoutRequest(ids, function() {
          return _this.requestAdvanced(request, clientParams);
        });
      };
      return {
        request: function(method, params, clientParams) {
          var id2 = _this._createID();
          return timeoutRequest([id2], function() {
            return _this.requestWithID(method, params, clientParams, id2);
          });
        },
        requestAdvanced: function(request, clientParams) {
          return requestAdvanced(request, clientParams);
        }
      };
    };
    JSONRPCClient2.prototype.request = function(method, params, clientParams) {
      return this.requestWithID(method, params, clientParams, this._createID());
    };
    JSONRPCClient2.prototype.requestWithID = function(method, params, clientParams, id2) {
      return __awaiter$2(this, void 0, void 0, function() {
        var request, response;
        return __generator$2(this, function(_a) {
          switch (_a.label) {
            case 0:
              request = (0, models_1$2.createJSONRPCRequest)(id2, method, params);
              return [4, this.requestAdvanced(request, clientParams)];
            case 1:
              response = _a.sent();
              if (response.result !== void 0 && !response.error) {
                return [2, response.result];
              } else if (response.result === void 0 && response.error) {
                return [2, Promise.reject(new models_1$2.JSONRPCErrorException(response.error.message, response.error.code, response.error.data))];
              } else {
                return [2, Promise.reject(new Error("An unexpected error occurred"))];
              }
          }
        });
      });
    };
    JSONRPCClient2.prototype.requestAdvanced = function(requests, clientParams) {
      var _this = this;
      var areRequestsOriginallyArray = Array.isArray(requests);
      if (!Array.isArray(requests)) {
        requests = [requests];
      }
      var requestsWithID = requests.filter(function(request) {
        return isDefinedAndNonNull(request.id);
      });
      var promises = requestsWithID.map(function(request) {
        return new Promise(function(resolve2) {
          return _this.idToResolveMap.set(request.id, resolve2);
        });
      });
      var promise = Promise.all(promises).then(function(responses) {
        if (areRequestsOriginallyArray || !responses.length) {
          return responses;
        } else {
          return responses[0];
        }
      });
      return this.send(areRequestsOriginallyArray ? requests : requests[0], clientParams).then(function() {
        return promise;
      }, function(error) {
        requestsWithID.forEach(function(request) {
          _this.receive((0, models_1$2.createJSONRPCErrorResponse)(request.id, internal_1$1.DefaultErrorCode, error && error.message || "Failed to send a request"));
        });
        return promise;
      });
    };
    JSONRPCClient2.prototype.notify = function(method, params, clientParams) {
      var request = (0, models_1$2.createJSONRPCNotification)(method, params);
      this.send(request, clientParams).then(void 0, function() {
        return void 0;
      });
    };
    JSONRPCClient2.prototype.send = function(payload, clientParams) {
      return __awaiter$2(this, void 0, void 0, function() {
        return __generator$2(this, function(_a) {
          return [2, this._send(payload, clientParams)];
        });
      });
    };
    JSONRPCClient2.prototype.rejectAllPendingRequests = function(message) {
      this.idToResolveMap.forEach(function(resolve2, id2) {
        return resolve2((0, models_1$2.createJSONRPCErrorResponse)(id2, internal_1$1.DefaultErrorCode, message));
      });
      this.idToResolveMap.clear();
    };
    JSONRPCClient2.prototype.receive = function(responses) {
      var _this = this;
      if (!Array.isArray(responses)) {
        responses = [responses];
      }
      responses.forEach(function(response) {
        var resolve2 = _this.idToResolveMap.get(response.id);
        if (resolve2) {
          _this.idToResolveMap.delete(response.id);
          resolve2(response);
        }
      });
    };
    return JSONRPCClient2;
  }()
);
client.JSONRPCClient = JSONRPCClient;
var isDefinedAndNonNull = function(value) {
  return value !== void 0 && value !== null;
};
var interfaces = {};
Object.defineProperty(interfaces, "__esModule", { value: true });
var server = {};
var __assign = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign = Object.assign || function(t2) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
var __awaiter$1 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$1 = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __spreadArray = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l2 = from2.length, ar; i < l2; i++) {
      if (ar || !(i in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i);
        ar[i] = from2[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
};
Object.defineProperty(server, "__esModule", { value: true });
server.JSONRPCServer = void 0;
var models_1$1 = models;
var internal_1 = internal;
var createParseErrorResponse = function() {
  return (0, models_1$1.createJSONRPCErrorResponse)(null, models_1$1.JSONRPCErrorCode.ParseError, "Parse error");
};
var createInvalidRequestResponse = function(request) {
  return (0, models_1$1.createJSONRPCErrorResponse)((0, models_1$1.isJSONRPCID)(request.id) ? request.id : null, models_1$1.JSONRPCErrorCode.InvalidRequest, "Invalid Request");
};
var createMethodNotFoundResponse = function(id2) {
  return (0, models_1$1.createJSONRPCErrorResponse)(id2, models_1$1.JSONRPCErrorCode.MethodNotFound, "Method not found");
};
var JSONRPCServer = (
  /** @class */
  function() {
    function JSONRPCServer2(options) {
      if (options === void 0) {
        options = {};
      }
      var _a;
      this.mapErrorToJSONRPCErrorResponse = defaultMapErrorToJSONRPCErrorResponse;
      this.nameToMethodDictionary = {};
      this.middleware = null;
      this.errorListener = (_a = options.errorListener) !== null && _a !== void 0 ? _a : console.warn;
    }
    JSONRPCServer2.prototype.hasMethod = function(name) {
      return !!this.nameToMethodDictionary[name];
    };
    JSONRPCServer2.prototype.addMethod = function(name, method) {
      this.addMethodAdvanced(name, this.toJSONRPCMethod(method));
    };
    JSONRPCServer2.prototype.removeMethod = function(name) {
      delete this.nameToMethodDictionary[name];
    };
    JSONRPCServer2.prototype.toJSONRPCMethod = function(method) {
      return function(request, serverParams) {
        var response = method(request.params, serverParams);
        return Promise.resolve(response).then(function(result) {
          return mapResultToJSONRPCResponse(request.id, result);
        });
      };
    };
    JSONRPCServer2.prototype.addMethodAdvanced = function(name, method) {
      var _a;
      this.nameToMethodDictionary = __assign(__assign({}, this.nameToMethodDictionary), (_a = {}, _a[name] = method, _a));
    };
    JSONRPCServer2.prototype.receiveJSON = function(json, serverParams) {
      var request = this.tryParseRequestJSON(json);
      if (request) {
        return this.receive(request, serverParams);
      } else {
        return Promise.resolve(createParseErrorResponse());
      }
    };
    JSONRPCServer2.prototype.tryParseRequestJSON = function(json) {
      try {
        return JSON.parse(json);
      } catch (_a) {
        return null;
      }
    };
    JSONRPCServer2.prototype.receive = function(request, serverParams) {
      if (Array.isArray(request)) {
        return this.receiveMultiple(request, serverParams);
      } else {
        return this.receiveSingle(request, serverParams);
      }
    };
    JSONRPCServer2.prototype.receiveMultiple = function(requests, serverParams) {
      return __awaiter$1(this, void 0, void 0, function() {
        var responses;
        var _this = this;
        return __generator$1(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, Promise.all(requests.map(function(request) {
                return _this.receiveSingle(request, serverParams);
              }))];
            case 1:
              responses = _a.sent().filter(isNonNull);
              if (responses.length === 1) {
                return [2, responses[0]];
              } else if (responses.length) {
                return [2, responses];
              } else {
                return [2, null];
              }
          }
        });
      });
    };
    JSONRPCServer2.prototype.receiveSingle = function(request, serverParams) {
      return __awaiter$1(this, void 0, void 0, function() {
        var method, response;
        return __generator$1(this, function(_a) {
          switch (_a.label) {
            case 0:
              method = this.nameToMethodDictionary[request.method];
              if (!!(0, models_1$1.isJSONRPCRequest)(request))
                return [3, 1];
              return [2, createInvalidRequestResponse(request)];
            case 1:
              return [4, this.callMethod(method, request, serverParams)];
            case 2:
              response = _a.sent();
              return [2, mapResponse(request, response)];
          }
        });
      });
    };
    JSONRPCServer2.prototype.applyMiddleware = function() {
      var middlewares = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        middlewares[_i] = arguments[_i];
      }
      if (this.middleware) {
        this.middleware = this.combineMiddlewares(__spreadArray([
          this.middleware
        ], middlewares, true));
      } else {
        this.middleware = this.combineMiddlewares(middlewares);
      }
    };
    JSONRPCServer2.prototype.combineMiddlewares = function(middlewares) {
      if (!middlewares.length) {
        return null;
      } else {
        return middlewares.reduce(this.middlewareReducer);
      }
    };
    JSONRPCServer2.prototype.middlewareReducer = function(prevMiddleware, nextMiddleware) {
      return function(next2, request, serverParams) {
        return prevMiddleware(function(request2, serverParams2) {
          return nextMiddleware(next2, request2, serverParams2);
        }, request, serverParams);
      };
    };
    JSONRPCServer2.prototype.callMethod = function(method, request, serverParams) {
      var _this = this;
      var callMethod = function(request2, serverParams2) {
        if (method) {
          return method(request2, serverParams2);
        } else if (request2.id !== void 0) {
          return Promise.resolve(createMethodNotFoundResponse(request2.id));
        } else {
          return Promise.resolve(null);
        }
      };
      var onError = function(error) {
        _this.errorListener('An unexpected error occurred while executing "'.concat(request.method, '" JSON-RPC method:'), error);
        return Promise.resolve(_this.mapErrorToJSONRPCErrorResponseIfNecessary(request.id, error));
      };
      try {
        return (this.middleware || noopMiddleware)(callMethod, request, serverParams).then(void 0, onError);
      } catch (error) {
        return onError(error);
      }
    };
    JSONRPCServer2.prototype.mapErrorToJSONRPCErrorResponseIfNecessary = function(id2, error) {
      if (id2 !== void 0) {
        return this.mapErrorToJSONRPCErrorResponse(id2, error);
      } else {
        return null;
      }
    };
    return JSONRPCServer2;
  }()
);
server.JSONRPCServer = JSONRPCServer;
var isNonNull = function(value) {
  return value !== null;
};
var noopMiddleware = function(next2, request, serverParams) {
  return next2(request, serverParams);
};
var mapResultToJSONRPCResponse = function(id2, result) {
  if (id2 !== void 0) {
    return (0, models_1$1.createJSONRPCSuccessResponse)(id2, result);
  } else {
    return null;
  }
};
var defaultMapErrorToJSONRPCErrorResponse = function(id2, error) {
  var _a;
  var message = (_a = error === null || error === void 0 ? void 0 : error.message) !== null && _a !== void 0 ? _a : "An unexpected error occurred";
  var code = internal_1.DefaultErrorCode;
  var data;
  if (error instanceof models_1$1.JSONRPCErrorException) {
    code = error.code;
    data = error.data;
  }
  return (0, models_1$1.createJSONRPCErrorResponse)(id2, code, message, data);
};
var mapResponse = function(request, response) {
  if (response) {
    return response;
  } else if (request.id !== void 0) {
    return (0, models_1$1.createJSONRPCErrorResponse)(request.id, models_1$1.JSONRPCErrorCode.InternalError, "Internal error");
  } else {
    return null;
  }
};
var serverAndClient = {};
var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
Object.defineProperty(serverAndClient, "__esModule", { value: true });
serverAndClient.JSONRPCServerAndClient = void 0;
var models_1 = models;
var JSONRPCServerAndClient = (
  /** @class */
  function() {
    function JSONRPCServerAndClient2(server2, client2, options) {
      if (options === void 0) {
        options = {};
      }
      var _a;
      this.server = server2;
      this.client = client2;
      this.errorListener = (_a = options.errorListener) !== null && _a !== void 0 ? _a : console.warn;
    }
    JSONRPCServerAndClient2.prototype.applyServerMiddleware = function() {
      var _a;
      var middlewares = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        middlewares[_i] = arguments[_i];
      }
      (_a = this.server).applyMiddleware.apply(_a, middlewares);
    };
    JSONRPCServerAndClient2.prototype.hasMethod = function(name) {
      return this.server.hasMethod(name);
    };
    JSONRPCServerAndClient2.prototype.addMethod = function(name, method) {
      this.server.addMethod(name, method);
    };
    JSONRPCServerAndClient2.prototype.addMethodAdvanced = function(name, method) {
      this.server.addMethodAdvanced(name, method);
    };
    JSONRPCServerAndClient2.prototype.removeMethod = function(name) {
      this.server.removeMethod(name);
    };
    JSONRPCServerAndClient2.prototype.timeout = function(delay2) {
      return this.client.timeout(delay2);
    };
    JSONRPCServerAndClient2.prototype.request = function(method, params, clientParams) {
      return this.client.request(method, params, clientParams);
    };
    JSONRPCServerAndClient2.prototype.requestAdvanced = function(jsonRPCRequest, clientParams) {
      return this.client.requestAdvanced(jsonRPCRequest, clientParams);
    };
    JSONRPCServerAndClient2.prototype.notify = function(method, params, clientParams) {
      this.client.notify(method, params, clientParams);
    };
    JSONRPCServerAndClient2.prototype.rejectAllPendingRequests = function(message) {
      this.client.rejectAllPendingRequests(message);
    };
    JSONRPCServerAndClient2.prototype.receiveAndSend = function(payload, serverParams, clientParams) {
      return __awaiter(this, void 0, void 0, function() {
        var response, message;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (!((0, models_1.isJSONRPCResponse)(payload) || (0, models_1.isJSONRPCResponses)(payload)))
                return [3, 1];
              this.client.receive(payload);
              return [3, 4];
            case 1:
              if (!((0, models_1.isJSONRPCRequest)(payload) || (0, models_1.isJSONRPCRequests)(payload)))
                return [3, 3];
              return [4, this.server.receive(payload, serverParams)];
            case 2:
              response = _a.sent();
              if (response) {
                return [2, this.client.send(response, clientParams)];
              }
              return [3, 4];
            case 3:
              message = "Received an invalid JSON-RPC message";
              this.errorListener(message, payload);
              return [2, Promise.reject(new Error(message))];
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    return JSONRPCServerAndClient2;
  }()
);
serverAndClient.JSONRPCServerAndClient = JSONRPCServerAndClient;
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    var desc = Object.getOwnPropertyDescriptor(m2, k2);
    if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m2[k2];
      } };
    }
    Object.defineProperty(o, k22, desc);
  } : function(o, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
        __createBinding2(exports2, m2, p2);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(client, exports);
  __exportStar(interfaces, exports);
  __exportStar(models, exports);
  __exportStar(server, exports);
  __exportStar(serverAndClient, exports);
})(dist);
var _function = {};
(function(exports) {
  var __spreadArray2 = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from2, pack) {
    if (pack || arguments.length === 2)
      for (var i = 0, l2 = from2.length, ar; i < l2; i++) {
        if (ar || !(i in from2)) {
          if (!ar)
            ar = Array.prototype.slice.call(from2, 0, i);
          ar[i] = from2[i];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from2));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.dual = exports.getEndomorphismMonoid = exports.not = exports.SK = exports.hole = exports.pipe = exports.untupled = exports.tupled = exports.absurd = exports.decrement = exports.increment = exports.tuple = exports.flow = exports.flip = exports.constVoid = exports.constUndefined = exports.constNull = exports.constFalse = exports.constTrue = exports.constant = exports.unsafeCoerce = exports.identity = exports.apply = exports.getRing = exports.getSemiring = exports.getMonoid = exports.getSemigroup = exports.getBooleanAlgebra = void 0;
  var getBooleanAlgebra = function(B2) {
    return function() {
      return {
        meet: function(x2, y2) {
          return function(a) {
            return B2.meet(x2(a), y2(a));
          };
        },
        join: function(x2, y2) {
          return function(a) {
            return B2.join(x2(a), y2(a));
          };
        },
        zero: function() {
          return B2.zero;
        },
        one: function() {
          return B2.one;
        },
        implies: function(x2, y2) {
          return function(a) {
            return B2.implies(x2(a), y2(a));
          };
        },
        not: function(x2) {
          return function(a) {
            return B2.not(x2(a));
          };
        }
      };
    };
  };
  exports.getBooleanAlgebra = getBooleanAlgebra;
  var getSemigroup = function(S2) {
    return function() {
      return {
        concat: function(f2, g2) {
          return function(a) {
            return S2.concat(f2(a), g2(a));
          };
        }
      };
    };
  };
  exports.getSemigroup = getSemigroup;
  var getMonoid = function(M2) {
    var getSemigroupM = (0, exports.getSemigroup)(M2);
    return function() {
      return {
        concat: getSemigroupM().concat,
        empty: function() {
          return M2.empty;
        }
      };
    };
  };
  exports.getMonoid = getMonoid;
  var getSemiring = function(S2) {
    return {
      add: function(f2, g2) {
        return function(x2) {
          return S2.add(f2(x2), g2(x2));
        };
      },
      zero: function() {
        return S2.zero;
      },
      mul: function(f2, g2) {
        return function(x2) {
          return S2.mul(f2(x2), g2(x2));
        };
      },
      one: function() {
        return S2.one;
      }
    };
  };
  exports.getSemiring = getSemiring;
  var getRing = function(R2) {
    var S2 = (0, exports.getSemiring)(R2);
    return {
      add: S2.add,
      mul: S2.mul,
      one: S2.one,
      zero: S2.zero,
      sub: function(f2, g2) {
        return function(x2) {
          return R2.sub(f2(x2), g2(x2));
        };
      }
    };
  };
  exports.getRing = getRing;
  var apply = function(a) {
    return function(f2) {
      return f2(a);
    };
  };
  exports.apply = apply;
  function identity2(a) {
    return a;
  }
  exports.identity = identity2;
  exports.unsafeCoerce = identity2;
  function constant(a) {
    return function() {
      return a;
    };
  }
  exports.constant = constant;
  exports.constTrue = constant(true);
  exports.constFalse = constant(false);
  exports.constNull = constant(null);
  exports.constUndefined = constant(void 0);
  exports.constVoid = exports.constUndefined;
  function flip(f2) {
    return function() {
      var args2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i];
      }
      if (args2.length > 1) {
        return f2(args2[1], args2[0]);
      }
      return function(a) {
        return f2(a)(args2[0]);
      };
    };
  }
  exports.flip = flip;
  function flow2(ab2, bc2, cd2, de2, ef2, fg2, gh2, hi2, ij2) {
    switch (arguments.length) {
      case 1:
        return ab2;
      case 2:
        return function() {
          return bc2(ab2.apply(this, arguments));
        };
      case 3:
        return function() {
          return cd2(bc2(ab2.apply(this, arguments)));
        };
      case 4:
        return function() {
          return de2(cd2(bc2(ab2.apply(this, arguments))));
        };
      case 5:
        return function() {
          return ef2(de2(cd2(bc2(ab2.apply(this, arguments)))));
        };
      case 6:
        return function() {
          return fg2(ef2(de2(cd2(bc2(ab2.apply(this, arguments))))));
        };
      case 7:
        return function() {
          return gh2(fg2(ef2(de2(cd2(bc2(ab2.apply(this, arguments)))))));
        };
      case 8:
        return function() {
          return hi2(gh2(fg2(ef2(de2(cd2(bc2(ab2.apply(this, arguments))))))));
        };
      case 9:
        return function() {
          return ij2(hi2(gh2(fg2(ef2(de2(cd2(bc2(ab2.apply(this, arguments)))))))));
        };
    }
    return;
  }
  exports.flow = flow2;
  function tuple() {
    var t2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      t2[_i] = arguments[_i];
    }
    return t2;
  }
  exports.tuple = tuple;
  function increment(n2) {
    return n2 + 1;
  }
  exports.increment = increment;
  function decrement(n2) {
    return n2 - 1;
  }
  exports.decrement = decrement;
  function absurd(_2) {
    throw new Error("Called `absurd` function which should be uncallable");
  }
  exports.absurd = absurd;
  function tupled(f2) {
    return function(a) {
      return f2.apply(void 0, a);
    };
  }
  exports.tupled = tupled;
  function untupled(f2) {
    return function() {
      var a = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        a[_i] = arguments[_i];
      }
      return f2(a);
    };
  }
  exports.untupled = untupled;
  function pipe2(a, ab2, bc2, cd2, de2, ef2, fg2, gh2, hi2) {
    switch (arguments.length) {
      case 1:
        return a;
      case 2:
        return ab2(a);
      case 3:
        return bc2(ab2(a));
      case 4:
        return cd2(bc2(ab2(a)));
      case 5:
        return de2(cd2(bc2(ab2(a))));
      case 6:
        return ef2(de2(cd2(bc2(ab2(a)))));
      case 7:
        return fg2(ef2(de2(cd2(bc2(ab2(a))))));
      case 8:
        return gh2(fg2(ef2(de2(cd2(bc2(ab2(a)))))));
      case 9:
        return hi2(gh2(fg2(ef2(de2(cd2(bc2(ab2(a))))))));
      default: {
        var ret = arguments[0];
        for (var i = 1; i < arguments.length; i++) {
          ret = arguments[i](ret);
        }
        return ret;
      }
    }
  }
  exports.pipe = pipe2;
  exports.hole = absurd;
  var SK = function(_2, b2) {
    return b2;
  };
  exports.SK = SK;
  function not2(predicate) {
    return function(a) {
      return !predicate(a);
    };
  }
  exports.not = not2;
  var getEndomorphismMonoid = function() {
    return {
      concat: function(first2, second) {
        return flow2(first2, second);
      },
      empty: identity2
    };
  };
  exports.getEndomorphismMonoid = getEndomorphismMonoid;
  var dual = function(arity, body) {
    var isDataFirst = typeof arity === "number" ? function(args2) {
      return args2.length >= arity;
    } : arity;
    return function() {
      var args2 = Array.from(arguments);
      if (isDataFirst(arguments)) {
        return body.apply(this, args2);
      }
      return function(self2) {
        return body.apply(void 0, __spreadArray2([self2], args2, false));
      };
    };
  };
  exports.dual = dual;
})(_function);
const isNotification = (data) => dist.isJSONRPCRequest(data) && !dist.isJSONRPCID(data.id);
const expectingReply = (data) => !isNotification(data);
const sendMessage = (send) => (request) => {
  try {
    send(JSON.stringify(request));
    return Promise.resolve();
  } catch (error) {
    return Promise.reject(error);
  }
};
const create$1 = (server2, serverParams, messages) => {
  const client2 = new dist.JSONRPCClient(
    _function.pipe(messages.send, sendMessage)
  );
  messages.receive(async (data) => {
    if (dist.isJSONRPCRequest(data)) {
      const result = await server2.receive(data, serverParams);
      if (expectingReply(data)) {
        _function.pipe(result, JSON.stringify, messages.send);
      }
    } else if (dist.isJSONRPCResponse(data)) {
      client2.receive(data);
    }
  });
  return client2;
};
const createClient = (rpcServer) => {
  return create$1(
    rpcServer,
    {},
    {
      send: (request) => window.ReactNativeWebView.postMessage(request),
      receive: (callback) => window.receiveMessageFromReactNative = (data) => callback(data)
    }
  );
};
const connectToNodes = (rpcNode) => ({
  // fiji: {
  //   rpcClient: createWebSocketClientNode(rpcNode, "fiji", 3000),
  //   hasStreaming: true,
  //   isHeadless: false,
  //   os: "linux",
  // },
  // zao: {
  //   rpcClient: createWebSocketClient(rpcServer, "zao", 3000),
  //   hasStreaming: true,
  //   isHeadless: true,
  //   os: "linux",
  // },
  yari: {
    rpcClient: createClient(rpcNode),
    hasStreaming: false,
    isHeadless: false,
    os: "android"
  }
});
const createServer = () => {
  const jsonRpcServer = new dist.JSONRPCServer();
  jsonRpcServer.addMethod("echo", ({ message }) => {
    console.log({ message });
    return message + "123";
  });
  return jsonRpcServer;
};
const nodes = _function.pipe(createServer(), connectToNodes);
const useUserInput = (focused, handleGamepadEvent) => {
  const { subscribe, unsubscribe } = useInputStore();
  reactExports.useEffect(() => {
    if (focused) {
      subscribe(handleGamepadEvent);
    } else {
      unsubscribe(handleGamepadEvent);
    }
    return () => unsubscribe(handleGamepadEvent);
  }, [focused, subscribe, unsubscribe]);
};
const withActionable = (WrappedComponent) => {
  return ({ onInput, onFocus, ...props }) => {
    const { ref, focused } = distExports.useFocusable({ onFocus });
    const handleGamepadInput = (event) => {
      const buttonToActionIndex = ["accept"];
      const keyToAction = {
        Space: "accept",
        Enter: "accept"
        /* ACCEPT */
      };
      if (event.code) {
        onInput({
          type: keyToAction[event.code],
          state: event.type === "keydown" ? "pressed" : "released"
        });
      } else {
        onInput({
          type: buttonToActionIndex[event.detail.button],
          state: event.detail.pressed ? "pressed" : "released"
        });
      }
    };
    useUserInput(focused, handleGamepadInput);
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref, style: { display: "inherit" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(WrappedComponent, { ...props, onInput, focused }) });
  };
};
const ReleaseItemBase = ({ image, name, focused, pressed }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: classNames({
        release: true
        // unavailable: !available,
      }),
      style: {
        paddingRight: "1rem",
        color: pressed ? "green" : focused ? "red" : "",
        border: pressed ? "2px solid green" : focused ? "2px solid white" : "",
        width: "15rem"
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { alt: name, width: 200, src: image, style: {
        height: "auto",
        maxWidth: "100%",
        objectFit: "contain"
      } })
    }
  );
};
const ReleaseItemActionable = withActionable(ReleaseItemBase);
const ReleaseItem = ({ release, onFocus }) => {
  var _a, _b;
  const [pressed, setPressed] = reactExports.useState(false);
  const handleInput = reactExports.useCallback(
    (actionEvent) => {
      switch (actionEvent.type) {
        case "accept": {
          if (actionEvent.state === "pressed") {
            setPressed(true);
          } else {
            setPressed(false);
            nodes.yari.rpcClient.request("@elevate/core/releases/launch", release);
          }
        }
      }
    },
    [release, setPressed]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ReleaseItemActionable,
    {
      image: (_b = (_a = release == null ? void 0 : release.media) == null ? void 0 : _a.grids) == null ? void 0 : _b[0],
      name: release == null ? void 0 : release.name,
      onInput: handleInput,
      onFocus,
      pressed
    }
  );
};
var define_import_meta_env_default = { BASE_URL: "/", MODE: "production", DEV: false, PROD: true, SSR: false };
function createJSONStorage(getStorage, options) {
  let storage;
  try {
    storage = getStorage();
  } catch (e2) {
    return;
  }
  const persistStorage = {
    getItem: (name) => {
      var _a;
      const parse2 = (str2) => {
        if (str2 === null) {
          return null;
        }
        return JSON.parse(str2, options == null ? void 0 : options.reviver);
      };
      const str = (_a = storage.getItem(name)) != null ? _a : null;
      if (str instanceof Promise) {
        return str.then(parse2);
      }
      return parse2(str);
    },
    setItem: (name, newValue) => storage.setItem(
      name,
      JSON.stringify(newValue, options == null ? void 0 : options.replacer)
    ),
    removeItem: (name) => storage.removeItem(name)
  };
  return persistStorage;
}
const toThenable = (fn) => (input) => {
  try {
    const result = fn(input);
    if (result instanceof Promise) {
      return result;
    }
    return {
      then(onFulfilled) {
        return toThenable(onFulfilled)(result);
      },
      catch(_onRejected) {
        return this;
      }
    };
  } catch (e2) {
    return {
      then(_onFulfilled) {
        return this;
      },
      catch(onRejected) {
        return toThenable(onRejected)(e2);
      }
    };
  }
};
const oldImpl = (config2, baseOptions) => (set, get, api) => {
  let options = {
    getStorage: () => localStorage,
    serialize: JSON.stringify,
    deserialize: JSON.parse,
    partialize: (state) => state,
    version: 0,
    merge: (persistedState, currentState) => ({
      ...currentState,
      ...persistedState
    }),
    ...baseOptions
  };
  let hasHydrated = false;
  const hydrationListeners = /* @__PURE__ */ new Set();
  const finishHydrationListeners = /* @__PURE__ */ new Set();
  let storage;
  try {
    storage = options.getStorage();
  } catch (e2) {
  }
  if (!storage) {
    return config2(
      (...args2) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
        );
        set(...args2);
      },
      get,
      api
    );
  }
  const thenableSerialize = toThenable(options.serialize);
  const setItem = () => {
    const state = options.partialize({ ...get() });
    let errorInSync;
    const thenable = thenableSerialize({ state, version: options.version }).then(
      (serializedValue) => storage.setItem(options.name, serializedValue)
    ).catch((e2) => {
      errorInSync = e2;
    });
    if (errorInSync) {
      throw errorInSync;
    }
    return thenable;
  };
  const savedSetState = api.setState;
  api.setState = (state, replace2) => {
    savedSetState(state, replace2);
    void setItem();
  };
  const configResult = config2(
    (...args2) => {
      set(...args2);
      void setItem();
    },
    get,
    api
  );
  let stateFromStorage;
  const hydrate = () => {
    var _a;
    if (!storage)
      return;
    hasHydrated = false;
    hydrationListeners.forEach((cb2) => cb2(get()));
    const postRehydrationCallback = ((_a = options.onRehydrateStorage) == null ? void 0 : _a.call(options, get())) || void 0;
    return toThenable(storage.getItem.bind(storage))(options.name).then((storageValue) => {
      if (storageValue) {
        return options.deserialize(storageValue);
      }
    }).then((deserializedStorageValue) => {
      if (deserializedStorageValue) {
        if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
          if (options.migrate) {
            return options.migrate(
              deserializedStorageValue.state,
              deserializedStorageValue.version
            );
          }
          console.error(
            `State loaded from storage couldn't be migrated since no migrate function was provided`
          );
        } else {
          return deserializedStorageValue.state;
        }
      }
    }).then((migratedState) => {
      var _a2;
      stateFromStorage = options.merge(
        migratedState,
        (_a2 = get()) != null ? _a2 : configResult
      );
      set(stateFromStorage, true);
      return setItem();
    }).then(() => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
      hasHydrated = true;
      finishHydrationListeners.forEach((cb2) => cb2(stateFromStorage));
    }).catch((e2) => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e2);
    });
  };
  api.persist = {
    setOptions: (newOptions) => {
      options = {
        ...options,
        ...newOptions
      };
      if (newOptions.getStorage) {
        storage = newOptions.getStorage();
      }
    },
    clearStorage: () => {
      storage == null ? void 0 : storage.removeItem(options.name);
    },
    getOptions: () => options,
    rehydrate: () => hydrate(),
    hasHydrated: () => hasHydrated,
    onHydrate: (cb2) => {
      hydrationListeners.add(cb2);
      return () => {
        hydrationListeners.delete(cb2);
      };
    },
    onFinishHydration: (cb2) => {
      finishHydrationListeners.add(cb2);
      return () => {
        finishHydrationListeners.delete(cb2);
      };
    }
  };
  hydrate();
  return stateFromStorage || configResult;
};
const newImpl = (config2, baseOptions) => (set, get, api) => {
  let options = {
    storage: createJSONStorage(() => localStorage),
    partialize: (state) => state,
    version: 0,
    merge: (persistedState, currentState) => ({
      ...currentState,
      ...persistedState
    }),
    ...baseOptions
  };
  let hasHydrated = false;
  const hydrationListeners = /* @__PURE__ */ new Set();
  const finishHydrationListeners = /* @__PURE__ */ new Set();
  let storage = options.storage;
  if (!storage) {
    return config2(
      (...args2) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
        );
        set(...args2);
      },
      get,
      api
    );
  }
  const setItem = () => {
    const state = options.partialize({ ...get() });
    return storage.setItem(options.name, {
      state,
      version: options.version
    });
  };
  const savedSetState = api.setState;
  api.setState = (state, replace2) => {
    savedSetState(state, replace2);
    void setItem();
  };
  const configResult = config2(
    (...args2) => {
      set(...args2);
      void setItem();
    },
    get,
    api
  );
  api.getInitialState = () => configResult;
  let stateFromStorage;
  const hydrate = () => {
    var _a, _b;
    if (!storage)
      return;
    hasHydrated = false;
    hydrationListeners.forEach((cb2) => {
      var _a2;
      return cb2((_a2 = get()) != null ? _a2 : configResult);
    });
    const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get()) != null ? _a : configResult)) || void 0;
    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {
      if (deserializedStorageValue) {
        if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
          if (options.migrate) {
            return options.migrate(
              deserializedStorageValue.state,
              deserializedStorageValue.version
            );
          }
          console.error(
            `State loaded from storage couldn't be migrated since no migrate function was provided`
          );
        } else {
          return deserializedStorageValue.state;
        }
      }
    }).then((migratedState) => {
      var _a2;
      stateFromStorage = options.merge(
        migratedState,
        (_a2 = get()) != null ? _a2 : configResult
      );
      set(stateFromStorage, true);
      return setItem();
    }).then(() => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
      stateFromStorage = get();
      hasHydrated = true;
      finishHydrationListeners.forEach((cb2) => cb2(stateFromStorage));
    }).catch((e2) => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e2);
    });
  };
  api.persist = {
    setOptions: (newOptions) => {
      options = {
        ...options,
        ...newOptions
      };
      if (newOptions.storage) {
        storage = newOptions.storage;
      }
    },
    clearStorage: () => {
      storage == null ? void 0 : storage.removeItem(options.name);
    },
    getOptions: () => options,
    rehydrate: () => hydrate(),
    hasHydrated: () => hasHydrated,
    onHydrate: (cb2) => {
      hydrationListeners.add(cb2);
      return () => {
        hydrationListeners.delete(cb2);
      };
    },
    onFinishHydration: (cb2) => {
      finishHydrationListeners.add(cb2);
      return () => {
        finishHydrationListeners.delete(cb2);
      };
    }
  };
  if (!options.skipHydration) {
    hydrate();
  }
  return stateFromStorage || configResult;
};
const persistImpl = (config2, baseOptions) => {
  if ("getStorage" in baseOptions || "serialize" in baseOptions || "deserialize" in baseOptions) {
    if ((define_import_meta_env_default ? "production" : void 0) !== "production") {
      console.warn(
        "[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."
      );
    }
    return oldImpl(config2, baseOptions);
  }
  return newImpl(config2, baseOptions);
};
const persist = persistImpl;
function shallow(objA, objB) {
  if (Object.is(objA, objB)) {
    return true;
  }
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  if (objA instanceof Map && objB instanceof Map) {
    if (objA.size !== objB.size)
      return false;
    for (const [key, value] of objA) {
      if (!Object.is(value, objB.get(key))) {
        return false;
      }
    }
    return true;
  }
  if (objA instanceof Set && objB instanceof Set) {
    if (objA.size !== objB.size)
      return false;
    for (const value of objA) {
      if (!objB.has(value)) {
        return false;
      }
    }
    return true;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length) {
    return false;
  }
  for (let i = 0; i < keysA.length; i++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }
  return true;
}
const { useRef } = React;
function useShallow(selector) {
  const prev2 = useRef();
  return (state) => {
    const next2 = selector(state);
    return shallow(prev2.current, next2) ? prev2.current : prev2.current = next2;
  };
}
(function(to, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l2 = from2.length, ar; i < l2; i++) {
      if (ar || !(i in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i);
        ar[i] = from2[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
});
function flow(ab2, bc2, cd2, de2, ef2, fg2, gh2, hi2, ij2) {
  switch (arguments.length) {
    case 1:
      return ab2;
    case 2:
      return function() {
        return bc2(ab2.apply(this, arguments));
      };
    case 3:
      return function() {
        return cd2(bc2(ab2.apply(this, arguments)));
      };
    case 4:
      return function() {
        return de2(cd2(bc2(ab2.apply(this, arguments))));
      };
    case 5:
      return function() {
        return ef2(de2(cd2(bc2(ab2.apply(this, arguments)))));
      };
    case 6:
      return function() {
        return fg2(ef2(de2(cd2(bc2(ab2.apply(this, arguments))))));
      };
    case 7:
      return function() {
        return gh2(fg2(ef2(de2(cd2(bc2(ab2.apply(this, arguments)))))));
      };
    case 8:
      return function() {
        return hi2(gh2(fg2(ef2(de2(cd2(bc2(ab2.apply(this, arguments))))))));
      };
    case 9:
      return function() {
        return ij2(hi2(gh2(fg2(ef2(de2(cd2(bc2(ab2.apply(this, arguments)))))))));
      };
  }
  return;
}
function pipe(a, ab2, bc2, cd2, de2, ef2, fg2, gh2, hi2) {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab2(a);
    case 3:
      return bc2(ab2(a));
    case 4:
      return cd2(bc2(ab2(a)));
    case 5:
      return de2(cd2(bc2(ab2(a))));
    case 6:
      return ef2(de2(cd2(bc2(ab2(a)))));
    case 7:
      return fg2(ef2(de2(cd2(bc2(ab2(a))))));
    case 8:
      return gh2(fg2(ef2(de2(cd2(bc2(ab2(a)))))));
    case 9:
      return hi2(gh2(fg2(ef2(de2(cd2(bc2(ab2(a))))))));
    default: {
      var ret = arguments[0];
      for (var i = 1; i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
    }
  }
}
const getJsonFromEvent = flow(
  (event) => event.data.toString(),
  JSON.parse
);
const trySendMessage = (socket, message) => {
  socket.send(message);
};
const create = (rpcServer, host, port) => {
  const socket = new WebSocket(`ws://${host}:${port}/socket`);
  const client2 = create$1(
    rpcServer,
    void 0,
    {
      send: (request) => trySendMessage(socket, request),
      receive: (process2) => {
        socket.onmessage = (e2) => {
          pipe(e2, getJsonFromEvent, process2);
        };
      }
    }
  );
  socket.onclose = (event) => {
    client2.rejectAllPendingRequests(`Connection is closed (${event.reason}).`);
  };
  return client2;
};
const frontendJsonRpcServer = createServer();
const useSettingsStore = create$2(
  persist(
    (set) => ({
      hostName: null,
      nodes: {},
      setSettings: (obj) => set(obj)
    }),
    {
      name: "settings"
      // name of the item in the storage (must be unique)
    }
  )
);
distExports.setKeyMap({ left: null, up: null, right: null, down: null, enter: null });
distExports.init({
  debug: false,
  visualDebug: false,
  shouldFocusDOMNode: true
  // INFO: Needed for RN (i think)
});
const ContentRowWrapper = ut.div`
  margin-bottom: 37px;
`;
const ContentRowTitle = ut.div`
  color: white;
  margin-bottom: 22px;
  font-size: 27px;
  font-weight: 700;
  font-family: "Segoe UI";
  padding-left: 60px;
`;
const ContentRowScrollingWrapper = ut.div`
  overflow-x: auto;
  overflow-y: hidden;
  flex-shrink: 1;
  flex-grow: 1;
  padding-left: 60px;
`;
const ContentRowScrollingContent = ut.div`
  display: flex;
  flex-direction: row;
`;
function Collection({
  title: rowTitle,
  onAssetPress,
  onFocus,
  collection
}) {
  const { ref, focusKey } = distExports.useFocusable({
    onFocus
  });
  const scrollingRef = reactExports.useRef(null);
  const onAssetFocus = reactExports.useCallback(
    ({ x: x2 }) => {
      console.log("scrolling");
      scrollingRef.current.scrollTo({
        left: x2,
        behavior: "smooth"
      });
    },
    [scrollingRef]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(distExports.FocusContext.Provider, { value: focusKey, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ContentRowWrapper, { ref, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ContentRowTitle, { children: rowTitle }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ContentRowScrollingWrapper, { ref: scrollingRef, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ContentRowScrollingContent, { children: collection.map((release) => /* @__PURE__ */ jsxRuntimeExports.jsx(ReleaseItem, { release, onFocus: onAssetFocus })) }) })
  ] }) });
}
const ContentWrapper = ut.div`
  flex: 1;
  overflow: hidden;
  display: flex;
  flex-direction: column;
`;
const ScrollingRows = ut.div`
  overflow-y: auto;
  overflow-x: hidden;
  flex-shrink: 1;
  flex-grow: 1;
`;
const useDefaultUser = () => {
  const { result: users2 } = dist$2.useRxData(
    "users",
    // a function returning the query to be applied
    (users22) => users22.getDefaultUser()
  );
  return users2[0] ?? null;
};
function DevButton({ children }) {
  const { ref, focused, focusSelf } = distExports.useFocusable();
  reactExports.useEffect(() => {
    focusSelf();
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref,
      style: {
        border: focused ? "10px solid #333" : "10px solid #00000000",
        opacity: 0
      },
      children
    }
  );
}
const Pinned = ({ onRowFocus }) => {
  const user = useDefaultUser();
  const { result: pins } = dist$2.useRxData("releases", (releases2) => {
    if (!user)
      return null;
    return releases2.pinnedBy(user, ["yari"]);
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection, { collection: pins, title: "Pinned", onFocus: onRowFocus });
};
const Library = ({ onRowFocus }) => {
  const { result: library } = dist$2.useRxData(
    "releases",
    (releases2) => releases2.find()
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection, { collection: library, title: "Library", onFocus: onRowFocus });
};
function Content() {
  const { ref } = distExports.useFocusable();
  reactExports.useState(null);
  const onRowFocus = reactExports.useCallback(
    ({ y: y2 }) => {
      ref.current.scrollTo({
        top: y2,
        behavior: "smooth"
      });
    },
    [ref]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ContentWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(DevButton, { method: "scan", children: "Scan" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollingRows, { ref, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Pinned, { onRowFocus }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Library, { onRowFocus }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Library, { onRowFocus }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Library, { onRowFocus }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Library, { onRowFocus }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Library, { onRowFocus }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Library, { onRowFocus }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Library, { onRowFocus })
    ] }) })
  ] });
}
const AppContainer = ut.div`
  background-color: #221c35;
  width: 100vw;
  height: 100vh;
  display: flex;
  flex-direction: row;
`;
const GlobalStyle = dt`
  ::-webkit-scrollbar {
    display: none;
  }
`;
function Providers({ children }) {
  const [db2, setDb] = reactExports.useState();
  const [hostName, set] = useSettingsStore(
    useShallow((state) => [state.hostName, state.setSettings])
  );
  reactExports.useEffect(() => {
    initialize().then(setDb);
  }, []);
  const [count2, setCount] = reactExports.useState(1);
  const delay2 = 500;
  useInterval(
    () => {
      if (window.isMobileHost) {
        set({
          hostName: "yari",
          nodes: {
            yari: {
              client: null
            }
          }
        });
      } else if (count2 === 8) {
        set({
          hostName: "fiji",
          nodes: {
            fiji: {
              client: create(
                frontendJsonRpcServer,
                "fiji",
                3e3
              )
            }
          }
        });
      }
      setCount(count2 + 1);
    },
    !hostName ? delay2 : null
  );
  if (!db2)
    return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(dist$2.Provider, { db: db2, children }) });
}
const App = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Providers, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(AppContainer, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyle, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Content, {})
  ] }) });
};
client$1.createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) })
);

</script>
    <style>
:root {
  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: none;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}

html {
  font-size: 8px;
}

body {
  background-color: black;
  color: white;
}

.release {
  display: flex;
  /* justify-content: center; */
  padding: 10px;
  margin-right: 30px;
}

.unavailable {
  opacity: 0.2;
  filter: grayscale(0.8);
}

</style>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>
